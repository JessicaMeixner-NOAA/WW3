
\section{~System documentation} \label{chapt:sys}
\newcounters
\vssub
\subsection{~Introduction}
\vssub

In this chapter a brief system documentation is presented. Discussed are the
custom preprocessor used by \ws\ (\para\ref{sec:w3adc}), the contents of the
different source code files (\para\ref{sec:files}), optimization
(\para\ref{sec:optim}), and the internal data storage
(\para\ref{sec:common}). For a more elaborate documentation, reference is made
to the source code itself, which is fully documented.

% -------------------------------------------------------------
\vssub
\subsection{~The preprocessor} \label{sec:w3adc}
\vssub

The \ws\ source code files are not ready to use {\fortran} files; mandatory
and optional program options still have to be selected, and test output may be
activated\footnote{~Exceptions are some modules that are not originally part
of \ws, like the exact interaction modules. Such modules with the extension
{\file .f} of {\file .f90} bypass the preprocessor and get copied to the work
directory with the {\file .f} extension.}. Compile level options are activated
using `switches'. The arbitrary switch '{\F swt}' is included in the \ws\
files as comment of the form {\F !/swt}, where the switch name {\F swt} is
followed by a space or by a '{\F /}'. If a switch is selected, the
preprocessor removes the comment characters, thus activating the corresponding
source code line. If '{\F/}' follows the switch, it is also removed, thus
allowing the selective inclusion of hardware-dependent compiler directives
etc. The switches are case sensitive, and available switches are presented in
\para\ref{sec:switches}. Files which contain the switch {\F c/swt} can be
found by typing \command{find\_switch '!/SWT'} A list of all switches included
in the \ws\ files can be obtained by typing \command{all\_switches}

\pb

Pre-processing is performed by the program {\code w3adc}. This program is
found in the file {\file w3adc.f}, which contains a ready to compile
{\fortran} source code and a full documentation\footnote{~Presently still in
fixed-format {\fortran}-77.}. Various properties of {\code w3adc} are set in
{\F parameter} statements in {\file w3adc.f}, i.e., the maximum length of
switches, the maximum number of include files, the maximum number of lines in
an include file and the line length. {\code w3adc} reads its `commands' from
standard input. An example input file for {\code w3adc} is given in
figure~\ref{fig:w3adc}. Line-by-line, the input consists of

% fig:w3adc
\input{fig_ad3}

\begin{list}{$\rightarrow$}{\itemsep 0mm \parsep 0mm}
\item	Test indicator and compress indicator
\item	File names of the input and output code
\item	Switches to be turned on in a single string (see
          \para\ref{sec:switches})
\item	Multiple lines with include string identifying an
          include file and name of this file.
\end{list}

\noindent
A test indicator 0 disables test output, and increasing values increase the
detail of the test output. A compress indicator 0 leaves the file as is. A
compress indicator 1 results in the removal of all comment lines indicated by
'{\F !}', except for empty switches, i.e., lines starting with '{\F !/}'. A
compress indicator 2 results in the subsequent removal of all comments.
Comment lines are not allowed in this input file. The above input for {\F
w3adc} is read using free format. Therefore quotes are needed around
strings. Echo and test output is send to the standard output device. To
facilitate the use of the preprocessor, several \unix\ scripts are provided
with \ws\ as discussed in \para\ref{sec:comp}. Note that compiler directives
are protected from file compression by defining them using a switch.

Note that the present version of {\F w3adc} assumes that the computer
system allows for file identification by name. If this option is not available
on the system, the program is easily adapted to read by unit number.


% -------------------------------------------------------------
\vssub
\subsection{~Program files} \label{sec:files}
\vssub

The \ws\ source code files are stored in files with the extension {\file
ftn}\footnote{~with the exception of some modules provided by others.}.
Starting with version 2.00, the code has been organized in modules. Only the
main programs are not packaged in modules.  Originally, variables were bundled
with the code modules, resulting in a single static data structure. In model
version 3.06, a separate dynamical data structure was introduced, allow for
the presence of multiple wave grids in a single program, as a preparation for
the development of the the multi-grid model driver.

The subroutines contained in the modules are described in some detail below.
The relation between the various subroutines is graphically depicted in
Figs.~\ref{fig:w3init} through \ref{fig:post}. Three groups of codes are
considered. The first are the main wave model subroutine modules, which are
generally identified by the file name structure {\file
w3{\it{xxxx}}md.ftn}. These modules are described in \para\ref{sec:wave_mod}.
The second group consists of modules specific to the multi-grid wave model
driver, which are generally identified by the file name structure {\file
wm{\it{xxxx}}md.ftn}. These modules are described in \para\ref{sec:multi_mod}.
The final group consists of auxiliary programs and wave model drivers, and is
described in \para\ref{sec:aux_mod}. Section~\ref{sec:data_ass} briefly
describes the data assimilation module.


\pb
% -------------------------------------------------------------
%\vsssub
\subsubsection{~Wave model modules} \label{sec:wave_mod}
\vsssub

At the core of the wave model are the wave model initialization module and the
wave model module.

\vspace{\baselineskip} \noindent
Main wave model initialization module \hfill {\file w3initmd.ftn}

\begin{flisti}
\fit{w3init}{The initialization routine {\F w3init}, which
             prepares the wave model for computations (internal).}
\fit{w3mpii}{\mpi\ initialization (internal).}
\fit{w3mpio}{\mpi\ initialization for I/O (internal).}
\fit{w3mpip}{\mpi\ initialization for I/O (internal, point output only).}
\end{flisti}

\vspace{\baselineskip} \noindent
Main wave model module \hfill {\file w3wavemd.ftn}

\begin{flisti}
\fit{w3wave}{The actual wave model {\F w3wave}.}
\fit{w3gath}{Data transpose to gather data for spatial propagation in
             a single array (internal).}
\fit{w3scat}{Corresponding scatter operation (internal).}
\fit{w3nmin}{Calculate minimum number of sea points per processor
             (internal).}
\end{flisti}

\noindent
The main wave model routines and all other subroutines require a data
structure to exist. The data structure is contained in the following
modules. 

\vspace{\baselineskip} \noindent
Define model grids and parameter settings \hfill {\file w3gdatmd.ftn}

\begin{flisti}
\fit{w3nmod}{Set number of grids to be considered.}
\fit{w3dimx}{Set dimensions for spatial grid and allocate storage.}
\fit{w3dims}{Set dimensions for spectral grid and allocate storage.}
\fit{w3dimug}{Set dimensions for arrays specific to the triangle-based grids (grid connectivity ...).}
\fit{w3setg}{Set pointers to selected grid.}
\end{flisti}

\noindent
Dynamic wave data describing sea state \hfill {\file w3wdatmd.ftn}

\begin{flisti}
\fit{w3ndat}{Set number of grids to be considered.}
\fit{w3dimw}{Set dimensions and allocate storage.}
\fit{w3setw}{Set pointers to selected grid.}
\end{flisti}

\noindent
Auxiliary storage \hfill {\file w3adatmd.ftn}

\begin{flisti}
\fit{w3naux}{Set number of grids to be considered.}
\fit{w3dima, w3dmnl}{}
\fit{      }{Set dimensions and allocate storage.}
\fit{w3seta}{Set pointers to selected grid.}
\end{flisti}

\noindent
Model output \hfill {\file w3odatmd.ftn}

\begin{flisti}
\fit{w3nout}{Set number of grids to be considered.}
\fit{w3dmo2, w3dmo3, w3dmo5}{}
\fit{      }{Set dimensions and allocate storage.}
\fit{w3seto}{Set pointers to selected grid.}
\end{flisti}

\noindent
Model input \hfill {\file w3idatmd.ftn}

\begin{flisti}
\fit{w3ninp}{Set number of grids to be considered.}
\fit{w3dimi}{Set dimensions and allocate storage.}
\fit{w3seti}{Set pointers to selected grid.}
\end{flisti}

\noindent
There are presently four propagation schemes available for 
rectangular and curvilinear grids, as well as a 'slot'
for a user supplied propagation routine, and there 
are four schemes for triangle-baseed grids. The propagation schemes are packaged
in the following modules. 

\vspace{\baselineskip} \noindent
Propagation module (first order) \hfill {\file w3pro1md.ftn}

\begin{flisti}
\fit{w3map1}{Generation of auxiliary maps.}
\fit{w3xyp1}{Propagation in physical space.}
\fit{w3ktp1}{Propagation in spectral space.}
\end{flisti}

\noindent
Propagation module (UQ scheme with diffusion) \hfill {\file w3pro2md.ftn}

\begin{flisti}
\fit{w3map2}{Generation of auxiliary maps.}
\fit{w3xyp2}{Propagation in physical space.}
\fit{w3ktp2}{Propagation in spectral space.}
\end{flisti}

\noindent
Propagation module (UQ scheme with averaging) \hfill {\file w3pro3md.ftn}

\begin{flisti}
\fit{w3map3}{Generation of auxiliary maps.}
\fit{w3mapt}{Generation of transparency maps.}
\fit{w3xyp3}{Propagation in physical space.}
\fit{w3ktp3}{Propagation in spectral space.}
\end{flisti}

%\noindent
%Propagation module (UQ scheme with divergent advection) \hfill {\file w3pro4md.ftn}

%\begin{flisti}
%\fit{w3map4}{Generation of auxiliary maps.}
%\fit{w3xyp4}{Propagation in physical space.}
%\fit{w3ktp4}{Propagation in spectral space.}
%\end{flisti}

\noindent
Propagation module (generic \uq) \hfill {\file w3uqckmd.ftn}

\begin{flisti}
\fit{w3qck{\it{n}}}{Routines performing \uq\ scheme in arbitrary
                 spaces (1: regular grid. 2: irregular grid
                         3: regular grid with obstructions).}
\end{flisti}

\noindent
Propagation module (slot for user supplied routines) \hfill {\file
w3proxmd.ftn}

\begin{flisti}
\fit{w3xypx}{Propagation in physical space.}
\fit{w3ktpx}{Propagation in spectral space.}
\end{flisti}

\noindent
Triangle-based propagation schemes \hfill {\file w3profsmd.ftn}

\begin{flisti}
\fit{w3xypug}{Interface to the unstructured propagation schemes}
\fit{w3cflug}{Computes the maximum CFL number for spatial propagation}
\fit{w3xypfsn2}{N-scheme}
\fit{w3xypfspsi2}{PSI-scheme}
\fit{w3xypfspsi2}{PSI-scheme}
\fit{w3xypfsnimp}{Implicit version of the N-scheme}
\fit{w3xypfsfct2}{FCT-scheme}
\fit{bcgstab}{Part of the iterative SPARSKIT solver, used for the implicit scheme}

\end{flisti}

   
% fig:w3init
\input{fig_w3init}

\noindent
The source term calculation and integration is contained in several
modules. The module {\file w3srcemd.ftn} manages the general calculation and
integration. Additional modules contain the actual source term options.

\vspace{\baselineskip} \noindent
Source term integration module \hfill {\file w3srcemd.ftn}

\begin{flisti}
\fit{w3srce}{Integration of source terms.}
\end{flisti}

\pb \noindent
Flux (stress) module (Wu, 1980) \hfill {\file w3flx1md.ftn}

\begin{flisti}
\fit{w3flx1}{Calculation of stresses.}
\end{flisti}

\noindent
Flux (stress) module (Tolman and Chalikov) \hfill {\file w3flx2md.ftn}

\begin{flisti}
\fit{w3flx2}{Calculation of stresses.}
\end{flisti}

\noindent
Flux (stress) module (Tolman and Chalikov, capped) \hfill {\file w3flx3md.ftn}

\begin{flisti}
\fit{w3flx3}{Calculation of stresses.}
\end{flisti}

\noindent
Flux (stress) module (slot for user supplied routines) \hfill {\file
w3flxxmd.ftn}

\begin{flisti}
\fit{w3flxx}{Calculation of stresses.}
\fit{inflxx}{Initialization routine.}
\end{flisti}

\noindent
Linear input (Cavaleri and Malanotte Rizzoli) \hfill {\file w3sln1md.ftn}

\begin{flisti}
\fit{w3sln1}{Calculation $S_{lin}$.}
\end{flisti}

\noindent
Linear input (slot for user supplied routines) \hfill {\file w3sln1md.ftn}

\begin{flisti}
\fit{w3slnx}{Calculation $S_{lin}$.}
\fit{inslnx}{Corresponding initialization routine.}
\end{flisti}

\noindent
Input and dissipation module (dummy version) \hfill {\file w3src0md.ftn}

\begin{flisti}
\fit{w3spr0}{Calculation of mean wave parameters (single grid point).}
\end{flisti}

\noindent
Input and dissipation module (\wam-3) \hfill {\file w3src1md.ftn}

\begin{flisti}
\fit{w3spr1}{Calculation of mean wave parameters (single grid point).}
\fit{w3sin1}{Calculation of $S_{in}$.}
\fit{w3sds1}{Calculation of $S_{ds}$.}
\end{flisti}

\noindent
Input and dissipation module \citep{tol:JPO96} \hfill {\file w3src2md.ftn}

\begin{flisti}
\fit{w3spr2}{Calculation of mean wave parameters (single grid point).}
\fit{w3sin2}{Calculation of $S_{in}$.}
\fit{w3sds2}{Calculation of $S_{ds}$.}
\fit{inptab}{Generation of the interpolation table for $\beta$.}
\fit{w3beta}{Function to calculate $\beta$ (internal).}
\end{flisti}

\noindent
Input and dissipation module \citep[\wam-4 and ECWAM,][]{rep:Bea05} \hfill {\file w3src3md.ftn}

\begin{flisti}
\fit{w3spr3}{Calculation of mean wave parameters (single grid point).}
\fit{w3sin3}{Calculation of $S_{in}$.}
\fit{w3sds3}{Calculation of $S_{ds}$.}
\fit{tabu\_stress}{Tabulation of wind stress as a function of $U_{10}$ and $\tau_w$}
\fit{tabu\_tauhf}{Tabulation of the short waves-supported stress}
\fit{tabu\_tauhf2}{Tabulation of the short waves-supported stress with sheltering}
\fit{tabu\_swellft}{Tabulation of oscillatory friction factor}
\fit{calc\_ustar}{Computes friction velocity using stress table}
\end{flisti}

\noindent
Input and dissipation module \citep{art:Aea09;art:Aea10} \hfill {\file w3src4md.ftn}

\begin{flisti}
\fit{w3spr4}{Calculation of mean wave parameters (single grid point).}
\fit{w3sin4}{Calculation of $S_{in}$.}
\fit{w3sds4}{Calculation of $S_{ds}$.}
\fit{tabu\_stress}{Tabulation of wind stress as a function of $U_{10}$ and $\tau_w$}
\fit{tabu\_tauhf}{Tabulation of the short waves-supported stress}
\fit{tabu\_tauhf2}{Tabulation of the short waves-supported stress with sheltering}
\fit{tabu\_swellft}{Tabulation of oscillatory friction factor for negative part of $S_{in}$.}
\fit{calc\_ustar}{Computes friction velocity using stress table}
\end{flisti}

\noindent
Input and dissipation module (slot for user supplied routines) \hfill {\file
w3srcxmd.ftn}

\begin{flisti}
\fit{w3sinx}{Calculation of $S_{in}$.}
\fit{w3sdsx}{Calculation of $S_{ds}$.}
\end{flisti}

\noindent
Nonlinear interaction module (\dia) \hfill {\file w3snl1md.ftn}

\begin{flisti}
\fit{w3snl1}{Calculation of $S_{nl}$.}
\fit{insnl1}{Initialization for $S_{nl}$.}
\end{flisti}

\noindent
Nonlinear interaction module (\xnl) \hfill {\file w3snl2md.ftn}

\begin{flisti}
\fit{w3snl2}{Interface routine for $S_{nl}$.}
\fit{insnl2}{Initialization for $S_{nl}$.}
\end{flisti}
These routines provide the interface to the \xnl\ routines. The \xnl\ routines
are provided in the files {\file mod\_constants.f90}, {\file mod\_fileio.f90},
{\file mod\_xnl4v4.f90}, and {\file serv\_xnl4v4.f90}. For details on these
files, see \cite{rep:vVl02b}.

\vspace{\baselineskip} \pb
\noindent
Nonlinear interaction module (slot for user supplied routines) \hfill {\file
w3snlxmd.ftn}

\begin{flisti}
\fit{w3snlx}{Calculation of $S_{nl}$.}
\fit{insnlx}{Initialization for $S_{nl}$.}
\end{flisti}

\noindent
Bottom friction module (\js) \hfill {\file w3sbt1md.ftn}

\noindent
Bottom friction module  \citep[SHOWEX][]{art:Aea03}  \hfill {\file w3sbt4md.ftn}

\begin{flisti}
\fit{w3bt1}{Calculation of $S_{bot}$.}
\end{flisti}

\noindent
Bottom friction module (slot for user supplied routines) \hfill {\file
w3sbtxmd.ftn}

\begin{flisti}
\fit{w3sbt4}{Calculation of $S_{bot}$, and energy and momentum fluxes to the 
bottom boundary layer.}
\end{flisti}


\begin{flisti}
\fit{w3sbtx}{Calculation of $S_{bot}$.}
\fit{insbtx}{Initialization of $S_{bot}$.}
\end{flisti}

\noindent
Depth induced breaking module (Battjes-Janssen) \hfill {\file w3sdb1md.ftn}

\begin{flisti}
\fit{w3sdb1}{Calculation of $S_{db}$.}
\end{flisti}

\noindent
Depth induced breaking module (slot for user supplied routines) \hfill {\file
w3sdbxmd.ftn}

\begin{flisti}
\fit{w3sdbx}{Calculation of $S_{db}$.}
\fit{insdbx}{Initialization of $S_{db}$.}
\end{flisti}

\noindent
Triad interactions module (slot for user supplied routines) \hfill {\file
w3strxmd.ftn}

\begin{flisti}
\fit{w3strx}{Calculation of $S_{tr}$.}
\fit{instrx}{Initialization of $S_{tr}$.}
\end{flisti}

\noindent
Bottom scattering module \hfill {\file
w3sbs1md.ftn}

\begin{flisti}
\fit{w3sbs1}{Calculation of $S_{bs}$ and associated momentum flux to the bottom.}
\fit{insbs1}{Initialization of $S_{bs}$.}
\end{flisti}

\noindent
Shoreline reflection \hfill {\file w3ref1md.ftn}

\begin{flisti}
\fit{w3sbs1}{Calculation of $S_{bs}$ and associated momentum flux to the bottom.}
\fit{insbs1}{Initialization of $S_{bs}$.}
\end{flisti}


\noindent
Bottom scattering module (slot for user supplied routines) \hfill {\file
w3sbsxmd.ftn}

\begin{flisti}
\fit{w3sbsx}{Calculation of $S_{bs}$.}
\fit{insbsx}{Initialization of $S_{bs}$.}
\end{flisti}

\noindent
Module for unclassified source term (slot for user supplied routines) \hfill
{\file w3sxxxmd.ftn}

\begin{flisti}
\fit{w3sxxx}{Calculation of $S_{xx}$.}
\fit{insxxx}{Initialization of $S_{xx}$.}
\end{flisti}

\noindent
The input fields such as winds and currents are transferred to the model
through the parameter list of {\F w3wave}. The information is processed within
{\F w3wave} by the routines in the following module.

\vspace{\baselineskip} \noindent
Input update module \hfill {\file w3updtmd.ftn}

\begin{flisti}
\fit{w3ucur}{Interpolation in time of current fields.}
\fit{w3uwnd}{Interpolation in time of wind fields.}
\fit{w3uini}{Generate initial conditions from the initial
             wind field.}
\fit{w3ubpt}{Updating of boundary conditions in nested runs.}
\fit{w3uice}{Updating of the ice coverage.}
\fit{w3ulev}{Updating of water levels.}
\fit{w3utrn}{Updating grid box transparencies.}
\fit{w3ddxy}{Calculation of spatial derivatives of the water depth.}
\fit{w3dcxy}{Calculation of spatial derivatives of the currents.} 
\end{flisti}

\noindent
There are seven types of \ws\ data files (other than the preprocessed input
fields, which are part of the program shall rather than the actual wave
model). The corresponding routines are gathered in six modules.

\vspace{\baselineskip} \noindent
I/O module ({\file mod\_def.ww3}) \hfill {\file w3iogrmd.ftn}

\begin{flisti}
\fit{w3iogr}{Reading and writing of {\file mod\_def.ww3}.}
\end{flisti}

\noindent
I/O module ({\file out\_grd.ww3}) \hfill {\file w3iogomd.ftn}

\begin{flisti}
\fit{w3outg}{Calculation of gridded output parameters.}
\fit{w3iogo}{Reading and writing of {\file out\_grd.ww3}.}
\end{flisti}

\noindent
I/O module ({\file out\_pnt.ww3}) \hfill {\file w3iopomd.ftn}

\begin{flisti}
\fit{w3iopp}{Processing of requests for point output.}
\fit{w3iope}{Calculating point output data.}
\fit{w3iopo}{Reading and writing of {\file out\_pnt.ww3}.}
\end{flisti}

\noindent
I/O module ({\file track\_o.ww3}) \hfill {\file w3iotrmd.ftn}

\begin{flisti}
\fit{w3iotr}{Generate track output in {\file track\_o.ww3}.}
\end{flisti}

\noindent
I/O module ({\file restart.ww3}) \hfill {\file w3iorsmd.ftn}

\begin{flisti}
\fit{w3iors}{Reading and writing of {\file restart{\sl{n}}.ww3}.}
\end{flisti}

\noindent
I/O module ({\file nest.ww3}) \hfill {\file w3iobcmd.ftn}

\begin{flisti}
\fit{w3iobc}{Reading and writing of {\file nest{\sl{n}}.ww3}.}
\end{flisti}

\noindent
I/O module ({\file partition.ww3}) \hfill {\file w3iofsmd.ftn}

\begin{flisti}
\fit{w3iofs}{Writing of {\file partition.ww3}.}
\end{flisti}

% fig:w3wave
\input{fig_w3wave}

\noindent
To complete the basic wave model, several additional modules are needed. For
the actual contents of the service modules see the documentation in the source
code files.

\begin{flist}
\fit{constants.ftn}{Physical and mathematical constants and Kelvin functions.}
\begin{flisti}
\fit{kzeone}{Pre-calculation for Kelvin functions}
\fit{kerkei}{Calculation of Kelvin functions}
\end{flisti}


\fit{w3arrymd.ftn}{Array manipulation routines including
                   'print plot' routines.}
\fit{w3cspcmd.ftn}{Conversion of spectral discretization.}
\fit{w3dispmd.ftn}{Routines to solve the dispersion relation,
                   including interpolation tables.}
\fit{w3partmd.ftn}{Perform spectral partitioning for a single spectrum.}
\fit{w3servmd.ftn}{General service routines.}
\fit{w3timemd.ftn}{Time management routines.}
\fit{w3triamd.ftn}{Basic routines for triangle-based grids: reading, interpolation, 
definition of miscellaneous arrays.}
\end{flist}

\noindent
This completes the description of the basic wave model routines. The relation
between the initialization routine and other routines is illustrated in
Fig.~\ref{fig:w3init}. A similar relational diagram for the wave model routine
is presented in Fig.~\ref{fig:w3wave}.


% -------------------------------------------------------------
%\vsssub
\subsubsection{~Multi-grid modules} \label{sec:multi_mod}
\vsssub

The multi-grid wave model shel {\file ww3\_multi} provides a shell around the
basic wave model as described in the previous section. This shell manages the
side-by-side running of multiple wave model grids, and all communication
between the grids. To achieve this various additional modules have been
developed. At the core are the initialization, multi-grid model and
finalization routines.

%\vspace{\baselineskip} \noindent
\pb \noindent
Initialization of multi-grid model \hfill {\file wminitmd.ftn}

\begin{flisti}
\fit{wminit}{Multi-grid model initialization.}
\end{flisti}

\noindent
Running of multi-grid model \hfill {\file wmwavemd.ftn}

\begin{flisti}
\fit{wmwave}{Multi-grid model execution.}
\fit{wmprnt}{Printing to log file.}
\fit{wmbcst}{Non-blocking MPI broadcast.}
\fit{wmwout}{Idem.}
\end{flisti}

\noindent
Finalizing of multi-grid model \hfill {\file wmfinlmd.ftn}

\begin{flisti}
\fit{wmfinl}{Multi-grid model finalization.}
\end{flisti}

\noindent
These routines are designed to become part of a coupled model. For the
structure of in particular the actual wave model routine, reference is made to
\cite{tol:MMAB07b}. The resulting wave model driver {\file ww3\_multi}
consequently becomes extremely simple; it initializes the MPI environment,
and then calls the above three modules consecutively. 

The main multi-grid wave model routines require an expansion of the data
structure used by \ws. Furthermore, main activities are gathered in
subroutines in various modules.

\vspace{\baselineskip} \noindent
Data storage \hfill {\file wmmdatmd.ftn}

\begin{flisti}
\fit{wmndat}{Set number of grids to be considered.}
\fit{wmdimd, wmdimm}{}
\fit{      }{Set dimensions and allocate storage.}
\fit{wmsetm}{Set pointers to selected grid.}
\end{flisti}

\noindent
Determine grid relations \hfill {\file wmgridmd.ftn}

\begin{flisti}
\fit{wmglow}{Relations to lower ranked grids.}
\fit{wmghgh}{Relations to higher ranked grids.}
\fit{wmgeql}{Relations between equal ranked grids.}
\fit{wmrspc}{Determine need for spectral conversion between grids.}
\end{flisti}

\pb \noindent
Update model input \hfill {\file wmupdtmd.ftn}

\begin{flisti}
\fit{wmupdt}{General input update routine.}
\fit{wmupd1}{Update input from native files using {\file w3fldsmd.ftn} from
             \para\ref{sec:aux_mod}.} 
\fit{wmupd2}{Update input from pore-defined input grids.}
\fit{wmupdv}{Update vector fields.}
\fit{wmupds}{Update scalar fields.}
\end{flisti}

\noindent
Perform internal communications \hfill {\file wminiomd.ftn}

\begin{flisti}
\fit{wmiobs}{Stage internal boundary data.}
\fit{wmiobg}{Gather internal boundary data.}
\fit{wmiobf}{Finalize {\F wmiobs} (MPI only).}
\fit{wmiohs}{Stage internal high to low rank data.}
\fit{wmiohg}{Gather internal high to low rank data.}
\fit{wmiohf}{Finalize {\F wmiohs} (MPI only).}
\fit{wmioes}{Stage internal data between equal ranked grids.}
\fit{wmioeg}{Gather internal data between equal ranked grids.}
\fit{wmioef}{Finalize {\F wmioes} (MPI only).}
\end{flisti}

\noindent
Unify point output to single file \hfill {\file wmiopomd.ftn}

\begin{flisti}
\fit{wmiopp}{Initialization routine.}  
\fit{wmiopo}{Data gather and write routine (using {\F w3iopo} in {\file
             w3iopomd.ftn}).}
\end{flisti}

\noindent
To complete the multi-grid wave model, one additional service module is
needed. For the actual contents of the service module see the documentation
in the source code files.

\begin{flist}
\fit{wmunitmd.ftn}{Dynamic unit number assignment}
\end{flist}


% -------------------------------------------------------------
%\vsssub
\subsubsection{~Data assimilation module} \label{sec:data_ass}
\vsssub

\ww\ includes a data assimilation module that can work in conjunction with the
main wave model routine, and is integrated in the generic program shell. The
module is intended as an interface to a data assimilation package to be
provided by the user.

\vspace{\baselineskip} \noindent
Data assimilation module \hfill {\file w3wdasmd.ftn}

\begin{flisti}
\fit{w3wdas}{Data assimilation interface.}
\end{flisti}


% -------------------------------------------------------------
%\vsssub
\subsubsection{~Auxiliary programs} \label{sec:aux_mod}
\vsssub

\ww\ has several auxiliary pre- and post-processors, and two wave model shells
(see \para\ref{sec:auxprog}). These main programs and some additional routines
are stored in the following files. Generally, subroutines used only by the
programs are stored as internal subroutines with the main program. There is no
need for using the module structure in this case. The exception is an
additional module {\file w3fldsmd.ftn} which deals with the data flow of input
fields for the wave model between the field pre-processor and the stand-alone
model shell. The latter module does not have any explicit \ws\ dependencies,
and can therefore be integrated in any custom data pre-processor.

% fig:prepro
\input{fig_prep}

\vspace{\baselineskip} 
\noindent
Input data file management module \hfill {\file w3fldsmd.ftn}

\begin{flisti}
\fit{w3fldo}{Opening and checking of data files for {\F w3shel}.}
\fit{w3fldg}{Reading and writing of data files for {\F w3shel} (model input).}
\fit{w3fldd}{Reading and writing of data files for {\F w3shel} (data assimilation).}
\fit{w3fldp}{Prepare interpolation of input fields from arbitrary grids.}
\fit{w3fldh}{Management of homogeneous input fields in {\F w3shel}.}
\fit{w3fldm}{Process moving grid data in {\F w3shel}.}
\end{flisti}

% fig:shell
\input{fig_shel}

\noindent
Grid pre-processing program \hfill {\file ww3\_grid.ftn}

\begin{flisti}
\fit{w3grid}{The grid preprocessor.}
\fit{readnl}{Reading {\F namelist} input (internal).}
\end{flisti}

\noindent
Initial conditions program \hfill {\file ww3\_strt.ftn}

\begin{flisti}
\fit{w3strt}{The initial conditions program.}
\end{flisti}

\noindent
Boundary conditions program \hfill {\file ww3\_bound.ftn}

\begin{flisti}
\fit{w3bound}{The boundary conditions program.}
\end{flisti}


\noindent
Input field pre-processing program \hfill {\file ww3\_prep.ftn}

\noindent
Input field pre-processing program from NetCDF files \hfill {\file ww3\_prnc.ftn}

\begin{flisti}
\fit{w3prep}{Pre-processor for the input fields for the generic shell.}
\end{flisti}

\noindent
Generic wave model program \hfill {\file ww3\_shel.ftn}

\begin{flisti}
\fit{w3shel}{The generic program shell.}
\end{flisti}

\noindent
Generic wave model program \hfill {\file ww3\_multi.ftn}

\begin{flisti}
\fit{w3mlti}{The multi-grid program shell.}
\end{flisti}

\pb \noindent
Gridded data post-processing program \hfill {\file ww3\_outf.ftn}

\begin{flisti}
\fit{w3outf}{The post-processing program for gridded
                    fields of mean wave parameters.}
\fit{w3exgo}{Actual output routine (internal).}
\end{flisti}

\noindent
Point post-processing program \hfill {\file ww3\_outp.ftn}

\begin{flisti}
\fit{w3outp}{The post-processing program output at selected locations.}
\fit{w3expo}{Actual output routine (internal).}
\end{flisti}

\pb \noindent
Gridded data post-processing program using NetCDF \hfill {\file ww3\_ounf.ftn}

\begin{flisti}
\fit{w3ounf}{The post-processing program for gridded
                    fields of mean wave parameters, using NetCDF3 or NetCDF4 libraries for Fortran90.}
\fit{w3crnc}{Creation of NetCDF files, definition of dimensions and header data.}
\fit{w3exnc}{Actual output routine (internal).}
\end{flisti}

\noindent
Point post-processing program \hfill {\file ww3\_ounp.ftn}

\begin{flisti}
\fit{w3ounp}{The post-processing program output at selected locations using NetCDF.}
\fit{w3crnc}{Creation of NetCDF files, definition of dimensions and header data.}
\fit{w3exnc}{Actual output routine (internal).}
\end{flisti}


\noindent
Track output post-processing program \hfill {\file ww3\_trck.ftn}

\begin{flisti}
\fit{w3trck}{Converting unformatted direct access track
             output file to integer-packed formatted file.}
\end{flisti}

\noindent
Gridded data post-processing program (GRIB) \hfill {\file ww3\_grib.ftn}

\begin{flisti}
\fit{w3grib}{The post-processing program for generating GRIB files.}
\fit{w3exgb}{Actual output routine (internal).}
\end{flisti}

\noindent
Gridded data post-processing program (GrADS) \hfill {\file gx\_outf.ftn}

\begin{flisti}
\fit{gxoutf}{The post-processing program for converting gridded
             fields of mean wave parameters to input files for GrADS.}
\fit{gxexgo}{Actual output routine (internal).}
\end{flisti}

\noindent
Point post-processing program (GrADS) \hfill {\file gx\_outp.ftn}

\begin{flisti}
\fit{gxoutp}{The post-processing program for converting output
             at selected locations to input files for GrADS.}
\fit{gxexpo}{Actual output routine (internal).}
\end{flisti}

% fig:post
\input{fig_post}


% -------------------------------------------------------------
%\vssub
\subsection{~Optimization} \label{sec:optim}
\vssub

The source code of \ws\ is written in ANSI standard FORTRAN 90, and has been
compiled and run on a variety of platforms ranging from PC's to
supercomputers.

Optimization for vector computers has been performed by structuring the code
in long vector loops where possible. Optimization was originally performed for
the Cray YMP and C90. Note that some compiler directives for vectorization
have been used. Note also that the vector optimization has not been updated
since about 1997, and therefore needs to be revisited if the model is
implemented on a vector machine. Vectorization directives are activated by the
corresponding preprocessor switch ({\F c90}).

Parallelization for shared memory machines using threading has been
implemented using standard OpenMP directives. Such parallelization takes place
mainly in the loop calling the source term routine {\F w3srce} and the
different propagation routines. OpenMP directives are activated by the
corresponding preprocessor switches ({\F omp}{\it n}).

Parallelization for distributed memory machines is discussed in some detail in
section~\ref{sec:distr}.

Note that an important part of the optimization is the use of interpolation
tables for the solution of the dispersion relation and for the calculation of
the wind-wave interaction parameter).


% -------------------------------------------------------------
\vssub
\subsection{~Internal data storage} \label{sec:common}
\vssub

The remainder of this chapter will deal with the internal data storage used by
\ws. In \para\ref{sec:grids} the layout of a single wave model grid as used in
{\file ww3\_shel} is discussed. In \para\ref{sec:distr} the parallelization
approaches for a single grid are discussed. In \para\ref{sec:mgrids} the
simultaneous storage of multiple wave grids is discussed. Finally, the actual
wave model variables are described in \para\ref{sec:variables}. Note that the
code is fully documented, including the variables defining the data storage.


% -------------------------------------------------------------
\vsssub
\subsubsection{~Grids} \label{sec:grids}
\vsssub

% fig_grids_1
\input{fig_grd1}

For convenience and economy of programming, spatial and spectral grids are
considered separately. This approach is inspired by the splitting technique
described in chapter~\ref{chapt:num}. For spatial propagation, a simple
`rectangular' spatial grid is used, as is illustrated in
Fig.~\ref{fig:grids_1}. The grid can either be a Cartesian `$(x,y)$' grid, a
spherical grid (with regular steps on latitude and longitude), a curvilinear grid, 
or a triangle-based grid. In a spherical grid, the longitudes are denoted throughout the
program by the counter {\F ix}, and latitudes by the counter {\F iy}, and the
corresponding grid dimensions {\F (nx,ny)}. All spatial field arrays are
dynamically allocated within the code, corresponding work arrays are usually
automatic, to allow for thread-safe code. The closure of the grid in case of a
global applications is handled within the model, and does not require user
intervention. To simplify the calculation of derivatives of in particular the
current, the outer grid points ({\F ix=1,nx}, unless the grid is global) and
({\F iy=1,ny}) will be considered as land points, inactive points or active
boundary points. The minimum grid size therefore is {\F nx=3, ny=3}, except for 
triangle-based grids. In that latter case, all the nodes are listed as a long 
vector of dimension nx, while ny=1, allowing to keep the same code structure. Input
arrays are typically assumed to be of the form

\vspace{\baselineskip} \centerline{\F array(nx,ny) ,} \vspace{\baselineskip}

\noindent
and are read row by row (see also chapter~\ref{chapt:run}). Within the
program, however, they are typically stored with rotated indices

\vspace{\baselineskip} \centerline{\F array(ny,nx) .} \vspace{\baselineskip}

\noindent
This makes it easier to provide global closure, which typically requires
extension of the x axis. Furthermore, such two-dimensional array are usually
treated as one-dimensional arrays, to increase vector lengths. The array {\F
array}, its one-dimensional equivalent {\F varray} and {\F ixy} are defined as

\vspace{\baselineskip}
\centerline{\F array(my,mx) , varray(my*mx) ,}
\centerline{\F ixy = iy + (ix-1)*my .}
\vspace{\baselineskip}

\noindent
Note that this representation of the grid is used {\it internally} within the
model only.

% fig:grids_2
\input{fig_grd2}

The spectral grid for a given spatial grid point {\F (ix,iy)} is defined
similarly, using a directional counter {\F ith} and a wavenumber counter {\F
ik} (Fig.~\ref{fig:grids_2}). The size of the spectral grid is set using
dynamic allocation. As with the spatial grid, the internal description of the
spectrum {\F a} is defined as

\vspace{\baselineskip}
\centerline{\F a(nth,nk) ,}
\vspace{\baselineskip}

\noindent
and equivalent one-dimensional arrays are used throughout the program. Inside
the model, directions are always Cartesian, $\theta = 0^\circ$ corresponds to
propagation from east to west (positive $x$ or {\F ix} direction), and $\theta
= 90^\circ$ corresponds to propagation from south to north (positive $y$ or
{\F iy} direction). Output directions use other conventions, as is discussed
in chapter~\ref{chapt:run}.

The storage of the wave spectra accounts for the majority of the memory
required by the model, because the splitting technique used assures that any
part of the model operates on a small subset of the entire wave field. To
minimize the amount of memory needed, only spectra for actual sea points are
stored. Sea points are here defined as points where spectra are potentially
needed. This includes active boundary points, and sea points covered by
ice. For archiving purposes, a one-dimensional sea point grid is defined using
the counter {\F isea}. Spectra are then stored as

\vspace{\baselineskip}
\centerline{\F a(ith,ik,isea) .}
\vspace{\baselineskip}

\noindent
An example of the layout of this storage grid in relation to the full grid of
Fig.~\ref{fig:grids_1} is given in Fig.~\ref{fig:grids_3}. Obviously, the
relation between the storage grid and the full spatial grid requires some
bookkeeping. For this purpose, two `maps' {\F mapfs} and {\F mapsf} are
defined.

\vspace{\baselineskip}
\centerline{\F mapsf(isea,1) = ix ,}
\centerline{\F mapsf(isea,2) = iy ,}
\centerline{\F mapsf(isea,3) = ixy ,}
\centerline{\F mapfs(iy,ix) = vmapfs(ixy) = isea ,}
\vspace{\baselineskip}

% fig:grids_3
\input{fig_grd3}

\noindent
where {\F mapfs(iy,ix) = 0} for land points. Finally, status maps {\F
mapsta(iy,ix)} and {\F mapst2(iy,ix)} are maintained to identify sea, land,
active boundary and ice points. {\F mapsta} represents the main status
map for the grid;

\vspace{\baselineskip} \noindent
\strut \hspace{25mm} {\F mapsta(iy,ix) = 0} \hspace{10mm} for excluded points, \\
\strut \hspace{25mm} {\F mapsta(iy,ix) = 1} \hspace{10mm} for sea points, \\
\strut \hspace{25mm} {\F mapsta(iy,ix) = 2} \hspace{10mm} for active boundary points.

\vspace{\baselineskip} 
\noindent 
Sea points and active boundary point which are not considered in the wave
model due to the presence of ice are marked by their corresponding negative
status indicator (-1 or -2). {\F mapst2} contains secondary information. For
excluded points {\F mapsta)iy,ix) = 0}, this map distinguished between land
points {\F mapst2(iy,ix) = 0} and otherwise excluded points {\F mapst2(iy,ix)
= 1}. For sea points that are disabled {\F mapsta(iy,ix) < 0}, consecutive
bits in {\F mapst2} identify the reason for deactivation (bit value 1
indicating deactivation).

\begin{center} \begin{tabular}{cl}
 bit & identifies \\ \hline
  1  & Ice coverage     \\
  2  & Point dried out  \\
  3  & Land in moving grid or inferred in nesting \\
  4  & Masked in two-way nesting
\end{tabular} \end{center}

\noindent
Two additional considerations have been made. First, the two status maps can
be collapsed into a single map for storage. To assure that the storage is
backward compatible with the previous mode version, the two maps are combined
into a single map {\F maptmp}

\vspace{\baselineskip}
\centerline{\F maptmp = mapsta + 8 * mapst2}
\vspace{\baselineskip}

\noindent
considering that only the first few bits of {\F mapsta} contain data.
It is this map MAPTMP that is saved in NetCDF files.  The
original maps can be recovered as

\vspace{\baselineskip}
\centerline{\F mapsta = mod ( maptmp + 2 , 8 ) - 2}
\centerline{\F mapst2 = maptmp - mapsta}
\vspace{\baselineskip}

\noindent
Second, a single map is used in the graphics output program, to simplify the
plotting of the status of grid points. In the graphics files, the map is
defined as

\begin{center} \begin{tabular}{cl}
{map} & implies \\ \hline
  2 & Active boundary point \\
  1 & Active sea point      \\
  0 & Land point (including as identified in {\F MAPST2}. \\
 -1 & Point covered by ice, but wet. \\
 -2 & Dry point, not covered by ice. \\
 -3 & Dry point covered by ice. \\
 -4 & Point masked in the two-way nesting scheme. \\
 -5 & Other disabled point.
\end{tabular} \end{center}

\noindent
Similarly, a single map can be used to simplify processing in the grid
preparation program {\file ww3\_grid}. In this map a distinction is made
between points as follows:

\begin{center} \begin{tabular}{cl}
{map} & implies \\ \hline
  3 & Excluded points \\
  2 & Active boundary point \\
  1 & Active sea point      \\
  0 & Land point 
\end{tabular} \end{center}


% -------------------------------------------------------------
\vsssub
\subsubsection{~Distributed memory concepts.} \label{sec:distr}
\vsssub

The general grid structure described in the previous paragraph is used for
both shared and distributed memory versions of the model, with some minor
differences. For the distributed memory version of the model, not all data is
kept at each processor. Instead, each spectrum is kept at a single processor
only. The spectra on the storage grid are distributed over the available
processors with a constant stride. Because only part of the spectra are stored
locally on a given processor, a distinction needs to be made between the above
global sea point counter {\F isea}, and the local sea point counter {\F
jsea}. If the actual number of processors used in the computation is {\F
naproc}, and if {\F iaproc} is the processor number ranging form 1 to {\F
naproc}, these parameters are related in the following way

\vspace{\baselineskip}
\centerline{\F isea = iaproc + (jsea-1) naproc ,}
\centerline{\F jsea = 1 + (isea-1) / naproc ,}
\centerline{\F iaproc = 1 + mod(isea-1,naproc) .}
\vspace{\baselineskip}

In model version 3.10, a further refinement was introduced. The actual number
of processors {\F naproc} can be smaller than the total number of processors
used by the program ({\F ntproc}). Processors where {\F naproc} $<$ {\F
iaproc} $\le$ {\F ntproc} are reserved for output processing only.

With this data distribution, source terms and intra-spectral propagation can
be calculated at the each given processor without the need for communication
between processors. For spatial propagation, however, a data transpose is
required where the spectral components {\F(ith,ik)} for all spatial grid
points have to be gathered at a single processor. After propagation has been
performed, the modified data have to be scattered back to their `home'
processor. Individual spectral components are assigned to specific processors
in such a way that the number of partial propagation steps to be performed by
each processor is roughly identical. This makes a good load balance
possible. The actual algorithm can be found in section 4.d of the subroutine
{\F w3init} ({\file w3initmd.ftn}).

The data transpose for the gather operation is implemented in two steps using
the Message Passing Interface (MPI) standard \citep[e.g.][]{bk:GLS97}. First,
values for each spatial grid point for a given spectral bin {\F(ith,ik)} are
gathered in a single target processor in a one-dimensional array {\F
store(isea)}, which then is converted to the full two-dimensional field of
spectral components. After propagation has been performed, the transpose for
the scatter operation reverses this process, using the same one-dimensional
array {\F store}. Whereas the algorithm for distributing spatial propagation
over individual processors assures a global (per time step) load balance, it
does not assure that communication is synchronized, because not each
calculation at each processor will take the same effort. To avoid that this
results in a load imbalance, non-blocking communication has been
used. Furthermore, the one-dimensional array {\F store(isea)} is replaced by
{\F store(isea,ibuf)}, where the added dimension of the array supplies an
actively managed buffer space (see {\F w3gath} and {\F w3scat} in {\file
w3wavemd.ftn}). These buffers allow that spare clock cycles as may occur
during communication can be used for calculation, and that hiding of
communication behind calculation will occur if the hardware is capable of
doing this. To avoid problems with incompatibilities between FORTRAN and MPI,
separate gather and scatter data arrays are used.  The buffered data
transposes are graphically depicted in Fig.~\ref{fig:transpose}. More details
can be found in \cite{tol:PACO02}

% fig:transpose
\input{fig_transpose}

In principle only the storage array {\F a(ith,ik,jsea)} is influenced by the
data distribution. Input fields, maps and output fields of mean wave
parameters in principle are retained at full resolution at each grid
point. Full maps are available at each processor at each phase of the
calculation. Input and output fields generally contain pertinent data at the
stride {\F naproc} only.

Distributed memory also requires modifications to the I/O. Input files are
read completely by each separate processor. The type of file output is
determined by the I/O type indicator {\F iostyp}

\begin{center} \begin{tabular}{cl}
{\F iostyp} & implies \\ \hline
  0 & Restart file written from each individual process. \\
  1 & Each file written from assigned process. \\
  2 & Each file written from a single dedicated output process. \\
  3 & Dedicated output processes for each output type.
\end{tabular} \end{center}

\noindent
Note that the restart file is a direct access file, so that each processor can
efficiently gather only the locally stored spectra, without the need of
reading through the entire file. The restart file is either written by each
individual process directly, or all data is funneled through a dedicated
processor. The first method requires a parallel file system, the second method
is generally applicable. 

The present algorithm for data distribution has been chosen for several
reasons. First, it results in an automatic and efficient load balancing with
respect to the (dynamic) integration of source terms, the exclusion of ice
covered grid points, and of intra-spectral propagation. Secondly, the
communication by definition becomes independent of the numerical propagation
scheme, unlike for the more conventional domain decomposition. In the latter
case, only a so-called `halo' of boundary data needs to be converted to
neighboring `blocks' of grid points. The size of the halo depends on the
propagation scheme selected. The main disadvantage of the present data
distribution scheme is that the amount of data to be communicated each time
step is much larger than for a more conventional domain decomposition,
particularly when relatively small numbers of processors are used. On an IBM
RS6000 SP, on which the distributed memory version of \ws\ was tested, the
relatively large amount of communication did not constitute a significant part
of the overall time of computation, and the model shows excellent scaling
behavior for up to O(100) processors \citep{tol:PACO02}.


% -------------------------------------------------------------
\vsssub
\subsubsection{~Multiple grids} \label{sec:mgrids}
\vsssub

So far, only a single wave model grid has been considered.  To make it
possible to run several model grids in a single program, a data structure
needs to be devised in which all different model grids and internal work
arrays for all models are retained simultaneously, with a simple mechanism to
choose the actual wave model grid to work on. In order to achieve this, some
FORTRAN 90 features \citep[e.g.,][]{bk:MR99} are used in the following way:

\begin{list}{}{\rightmargin 8mm \leftmargin 10mm \labelsep 2mm}

\item [1)] Define one or more data structures in the model code that contain
           the model setup and relevant work arrays, using a {\F type}
           declaration.

\item [2)] Construct arrays of these data structures, with each element of the
           array defining a separate model grid.

\item [3)] Redefine the basic parameters describing the model such as the
           number of grid points {\F nx} and {\F ny} as pointers, and point
           these to the proper element of the proper data structures to
           generate instantaneous aliases.

\end{list}

\input{fig_struc1}

\noindent
In this way it is possible to define a multi-model data structure, while
keeping the layout of all original variables describing the model unchanged
inside the model subroutines.  Such a structure and its usage are illustrated
in Figs.~\ref{fig:struc_1} and \ref{fig:struc_2} with an example from the
actual source code. Note that the pointer arrays like {\F zb} inside the
structures are assigned memory as

\vspace{\baselineskip}
\centerline{\F allocate grids(imod)\%zb(nsea)}
\vspace{\baselineskip}

\noindent
After this statement, the alias pointer {\F zb} again needs to be pointed to
the proper element of the structure for this alias to properly point to the
newly allocated space. For this reason, the subroutine {\F w3dimx}, which
allocates the arrays in this structure, includes at the end a call to the
subroutine {\F w3setx}, which in turn sets all pointer aliases for the
selected grid. The same is true for other subroutines setting array sizes in
other structures.

\input{fig_struc2}


% -------------------------------------------------------------
\vsssub
\subsection{~Variables in modules} \label{sec:variables}
\vsssub

Below, most {\F public} and {\F private} variables in modules are described
briefly (full documentation can also be found in the source code). The file
name of the module is given at the right margin of the start of each list. The
second column of each list identifies the type of the variable. {\F i}, {\F
r}, {\F l} and {\F c} represent integer, real, logical and character, {\F a}
identifies an array, and{ \F p} identifies a {\F parameter} declaration. All
variables are public, unless marked with \opt. First, parameter settings in
various modules are discussed. After that, the contents of the main storage
modules is discussed.

% -------------------------------------------------------------
\vsssub
\subsubsection{~Parameter settings in modules}
\vsssub

Several modules has internally used parameter settings. Here only parameter
settings that are generally usable or impact model output are presented.

\vspace{\baselineskip} \noindent
Physical and mathematical constants : \hfill {\file constants.ftn}
\begin{vlist}
\vit{grav  }{rp}{Acceleration of gravity $g$.
                \hfill (m s$^{-2}$)}
\vit{dwat  }{rp}{Density of water. \hfill(kg m$^{-3}$)}
\vit{dair  }{rp}{Density of air. \hfill(kg m$^{-3}$)}
\vit{pi    }{rp}{$\pi$.}
\vit{tpi   }{rp}{$2\pi$.}
\vit{hpi   }{rp}{$0.5\pi$.}
\vit{tpiinv}{rp}{$(2\pi)^{-1}$.}
\vit{hpiinv}{rp}{$(0.5\pi)^{-1}$.}
\vit{rade  }{rp}{Conversion factor from radians to degrees.}
\vit{dera  }{rp}{Conversion factor from degrees to radians.}
\vit{radius}{rp}{Radius of the earth. \hfill (m)}
\vit{g2pi3i}{rp}{$g^{-2} (2\pi)^{-3}$.}
\vit{g1pi1i}{rp}{$g^{-1}(2\pi)^{-1}$.}
\end{vlist}

\noindent
Wave model initialization module : \hfill {\file w3initmd.ftn}
\begin{vlist}
\vit{critos}{rp}{Critical fraction of resources used for output only
                     (triggers warning output).}
\vit{wwver }{cp}{Version number of the main program.}
\end{vlist}

\noindent
I/O module ({\file mod\_def.ww3}) : \hfill {\file w3iogrmd.ftn}
\begin{vlist}
\vit{vergrd}{cp\opt}{Version number of file {\file mod\_def.ww3}.}
\vit{idstr }{cp\opt}{ID string for file.}
\end{vlist}

\noindent
I/O module ({\file out\_grd.ww3}) : \hfill {\file w3iogomd.ftn}
\begin{vlist}
\vit{verogr}{cp\opt}{Version number of file {\file out\_grd.ww3}.}
\vit{idstr }{cp\opt}{ID string for file.}
\end{vlist}

\noindent
I/O module ({\file out\_pnt.ww3}) : \hfill {\file w3iopomd.ftn}
\begin{vlist}
\vit{veropt}{cp\opt}{Version number of file {\file out\_pnt.ww3}.}
\vit{idstr }{cp\opt}{ID string for file.}
\end{vlist}

\noindent
I/O module ({\file track\_o.ww3}) : \hfill {\file w3iotrmd.ftn}
\begin{vlist}
\vit{vertrk}{cp\opt}{Version number of file {\file track\_o.ww3}.}
\vit{idstri}{cp\opt}{ID string for file {\file track\_i.ww3}.}
\end{vlist}

\noindent
I/O module ({\file restart.ww3}) : \hfill {\file w3iorsmd.ftn}
\begin{vlist}
\vit{verini}{cp\opt}{Version number of file {\file restart.ww3}.}
\vit{idstr }{cp\opt}{ID string for file.}
\end{vlist}

\noindent
I/O module ({\file nest.ww3}) : \hfill {\file w3iobcmd.ftn}
\begin{vlist}
\vit{verbpt}{cp\opt}{Version number of file {\file nest.ww3}.}
\vit{idstr }{cp\opt}{ID string for file.}
\end{vlist}

\noindent
I/O module ({\file partition.ww3}) : \hfill {\file w3iosfmd.ftn}
\begin{vlist}
\vit{vertrt}{cp\opt}{Version number of file {\file partition.ww3}.}
\vit{idstr }{cp\opt}{ID string for file.}
\end{vlist}

\noindent
Multi-grid model input update : \hfill {\file wmupdtmd.ftn}
\begin{vlist}
\vit{swpmax}{ip}{Maximum number of extrapolation sweeps allowed to make maps
                 match in conversion from input from input grid to wave model
                 grid.}
\end{vlist}

\vspace{\baselineskip} \noindent
The service modules contain private variables only, with the exception of the
interpolation tables for the solution of the dispersion relation

\vspace{\baselineskip} \noindent
Solving the dispersion relation : \hfill {\file w3dispmd.ftn}
\begin{vlist}
\vit{nar1d }{ip}{Dimension of interpolation tables.}
\vit{dfac  }{rp}{Maximum nondimensional water depth $kd$.}
\vit{ecg1  }{ra}{Table for calculating  group velocities from
                 the frequency and the depth.}
\vit{ewn1  }{ra}{Id. wavenumbers.}
\vit{n1max }{i }{Largest index in tables.}
\vit{dsie  }{r }{Nondimensional frequency increment.}
\end{vlist}

\noindent
Automatic unit number assignment : \hfill {\file wmunitmd.ftn}
\begin{vlist}
\vit{unitlw}{ip}{Lowest unit number to be considered.}
\vit{unithg}{ip}{Highest unit number to be considered.}
\vit{inplow, inphgh}{}{}
\vit{      }{ip}{Range of input file unit numbers.}
\vit{outlow, outhgh}{}{}
\vit{      }{ip}{Range of output file unit numbers.}
\vit{scrlow, scrhgh}{}{}
\vit{      }{ip}{Range of scratch file unit numbers.}
\end{vlist}

\noindent
Note that the main programs only contain locally defined variables, which need
not be documented here in detail.


\vspace{8mm}
%--------------------------------------------------------------%
\subsubsection{Data in {\F w3gdatmd}.} \label{sub:gdatmd}

\noindent
The module {\F w3gdatmd} in the file {\file w3gdatmd.ftn} contains the data
describing a set of models. First several variables and parameters embedded in
the module are defined:


\begin{vlist}
\vit{ngrids}{i }{Number of models for which space is available.}
\vit{nauxgr}{i }{Auxiliary grids (model input, unified point output).}
\vit{igrid }{i }{Number of model/grid presently selected.}
\vit{isgrd }{i }{Number of spectral model grid presently selected.}
\vit{ipars }{i }{Number of physical model parameter settings presently 
                 selected.}
\vit{flagll}{lp}{Flag for spherical grid (otherwise Cartesian).}
\vit{grid  }{t }{Data structure containing information of spatial grids.}
\vit{grids }{ta}{Array if type {\F grid} and size {\F ngrids}.}
\vit{sgrd  }{t }{Data structure containing information of spectral grids.}
\vit{sgrds }{ta}{Array if type {\F sgrd} and size {\F ngrids}.}
\vit{mpar  }{t }{Data structure containing all other model parameters in
                 sub structures (see below).}
\vit{mpars }{ta}{Array if type {\F mpar} and size {\F ngrids}.}
\end{vlist}

\noindent
For each element of the type {\F grid}, direct aliases are defined with the
same name, as illustrated in Figs.~\ref{fig:struc_1} and \ref{fig:struc_2}.
These variables are:

\begin{vlist}
\vit{nx,ny }{i }{discrete grid dimensions, {\F nx, ny} $\geq 3$.}
\vit{nsea  }{i }{Number of sea points in grid.}
\vit{nseal }{i }{Id. locally stored on present process.}
\vit{trflag}{i }{Type of transparencies used.}
\vit{mapsta}{ia}{Grid status map.}
\vit{mapst2}{ia}{Secondary grid status map.}
\vit{mapsf }{ia}{Storage grid map.}
\vit{mapfs }{ia}{Id.}
\vit{sx,sy }{r }{Spatial grid increments. \hfill ($\degree$ or m)}
\vit{x0,y0 }{r }{Lower left point of spatial grid. \hfill ($\degree$ or m)}
\vit{dtcfl }{r }{Maximum \cfl\ number for spatial propagation.}
\vit{dtcfli}{r }{Id. for intra-spectral propagation.}
\vit{dtmax }{r }{Maximum overall time step.}
\vit{dtmin }{r }{Minimum source term integration time step.}
\vit{dmin  }{r }{Minimum water depth. \hfill (m)}
\vit{ctmax }{r }{Maximum \cfl\ number for depth refraction.}
\vit{fice0/n}{r }{Ice concentration cut-off. \hfill (-)}
\vit{pfmove}{r }{Power factor in GSE alleviation correction for moving grid.}
\vit{zb    }{ra}{Bottom depths on storage grid. \hfill (m)}
\vit{clat(i)}{ra}{(Inverse) cosine of latitude.}
\vit{clats }{ra}{Id.}
\vit{cthg0 }{ra}{Latitude factor in great circle propagation speed.}
\vit{trnx/y}{ra}{Grid box transparencies.\hfill (--)}
\vit{ginit }{l }{Flag for initialization of model/grid.}
\vit{global}{l }{Flag for global grid.}
\vit{fldry }{l }{Flag for 'dry run' (no calculations).}
\vit{flc{\it xx}}{l }{Flags for propagation in all spaces.}
\vit{flsou }{l }{Flag for source term integration.}
\vit{flast }{la}{Flags for source term computation per grid point.}
\vit{gname }{c }{Grid name.}
\vit{filext}{c }{File extension for raw files for this model/grid.}
\end{vlist}

\noindent
Similarly, the structure {\F sgrd} contains the following variables and/or
aliases: 

\begin{vlist}
\vit{nk    }{i }{Number of discrete spectral wavenumbers, {\F nk} $\geq 3$.}
\vit{nk2   }{i }{Extended wavenumber range.} 
\vit{nth   }{i }{Number of discrete spectral directions, {\F nth} $\geq 4$.}
\vit{nspec }{i }{Number of spectral bins.}
\vit{mapwn }{ia}{Map with discrete wavenumber for the one dimensional
                 description of the spectrum.}
\vit{mapth }{ia}{Id. for discrete directions.}
\vit{dth   }{r }{Spectral directional increment. \hfill (rad)} 
\vit{xfr   }{r }{Factor defining discrete frequency increment.}
\vit{fr1   }{r }{Lowest discrete frequency. \hfill (Hz)}
\vit{fte   }{r }{Factor in tail integration of total energy.}
\vit{ftf   }{r }{Id. mean frequency.}
\vit{ftwn  }{r }{Id. mean wavenumber.}
\vit{fttr  }{r }{Id. mean period.}
\vit{ftwl  }{R }{Id. mean wave length.}
\vit{facti{\it n}}{r }{Auxiliary to calculate discrete frequency from
                 continuous frequency.}
\vit{fachfa}{r }{Factor defining parametric tail for the action
                 spectrum $N(k,\theta)$.}
\vit{fachfe}{r }{Id. for the energy spectrum $F(f)$.}
\vit{th    }{ra}{Spectral directions. \hfill (rad)}
\vit{esin  }{ra}{$\sin(\theta)$ for discrete spectral directions.}
\vit{ecos  }{ra}{Id. $\cos(\theta)$.}
\vit{es2   }{ra}{$\sin^2(\theta)$ for entire spectrum.}
\vit{esc   }{ra}{Id. $\sin(\theta)\: \cos(\theta)$.}
\vit{ec2   }{ra}{Id. $\cos^2(\theta)$.}
\vit{sig   }{ra}{Frequencies for discrete wavenumbers. \hfill (rad s$^{-1}$)}
\vit{sig2  }{ra}{Id. for entire discrete spectrum. }
\vit{dsip  }{ra}{Frequency band widths for each wavenumber as used in
                 propagation. \hfill (rad s$^{-1}$)}
\vit{dsii  }{ra}{Id. for spectral integration.}
\vit{dden  }{ra}{Composite band with and conversion to energy for each
                 wavenumber ({\F dden = dth * dsii * sig}). \\
                 \strut \hfill (rad s$^{-1}$)}
\vit{dden2 }{ra}{Id. for entire spectrum.}
\vit{sinit }{l }{Flag for initialization of spectral grid.}
\end{vlist}

\noindent
The structure {\F mpar} contains addition structures and a single aliased
variable:

\begin{vlist}
\vit{pinit }{l }{Flag for initialization of this structure.}
\vit{npars }{t }{Structure with numerical parameters for source term
                 integration (structure {\F npar}).}
\vit{props }{t }{Structure with parameters for propagation schemes
                 (structure {\F prop}).}
\vit{sflps }{t }{Structure with parameters for flux computation (structure
                 {\F sflp}).}
\vit{slnps }{t }{Structure with parameters linear wind input source
                 term (structure {\F slnp}).}
\vit{srcps }{t }{Structure with parameters for input and dissipation source
                 term (structure {\F scrp}).}
\vit{snlps }{t }{Structure with parameters for nonlinear interaction source
                 term (structure {\F snlp}).}
\vit{sbtps }{t }{Structure with parameters for bottom friction source
                 term (structure {\F sbtp}).}
\vit{sdbps }{t }{Structure with parameters for depth-induced breaking
                 term (structure {\F sdbp}).}
\vit{strps }{t }{Structure with parameters for triad interaction source
                 term (structure {\F strp}).}
\vit{sbsps }{t }{Structure with parameters for bottom scattering source
                 term (structure {\F sbsp}).}
\vit{sxxps }{t }{Structure with parameters for arbitrary additional source
                 term (structure {\F sxxp}).}
\end{vlist}

\noindent
The structure {\F npar} contains the following alias pointers:

\begin{vlist}
\vit{facp  }{r }{Composite constant for parametric cut-off.} % in
				% Eq.~(\ref{eq:st_d_5}).}
\vit{xrel  }{r }{$X_r$ in dynamic integration.} %Eq.~(\ref{eq:st_d_6}).}
\vit{xflt  }{r }{$X_f$ in dynamic integration.} % Eq.~(\ref{eq:st_d_7}).}
\vit{fxfm  }{r }{First constant in tail.} % Eq.~(\ref{eq:tail_WAM3}).}
\vit{fxpm  }{r }{Second constant in tail.} % Eq.~(\ref{eq:tail_WAM3}).}
\vit{xft   }{r }{Constant for $f_{2}$ in tail.} % Eq.~(\ref{eq:TC_f}).}
\vit{xfc   }{r }{Constant for $f_{hf}$ in tail.} %Eq.~(\ref{eq:TC_f}).}
\vit{facsd }{r }{Seeding constant $X_{\rm seed}$.} %  in Eq.~(\ref{eq:seed}).}
\vit{fhmax }{r }{Maximum $H_s/d$ ratio in shallow water limiter.}
\end{vlist}

\noindent
The structure {\F prop} contains the following alias pointers. All pointer
are activated by the switches on the right.

\begin{vlist}
\vit{dtme  }{r }{Swell age in disp. corr.      \hfill ({\F !/pr2})}
\vit{clatmn}{r }{Id. minimum cosine of lat.    \hfill ({\F !/pr2})}
\vit{wdcg  }{r }{Factors in width of av. Cg.   \hfill ({\F !/pr3})}
\vit{wdth  }{r }{Factors in width of av. Th.   \hfill ({\F !/pr3})}
%\vit{qtfact}{r }{Factors for size of AOI.      \hfill ({\F !/pr4})}
%\vit{rnfact}{r }{Factor normal dispersion.     \hfill ({\F !/pr4})}
%\vit{rsfact}{R }{Factor tangential dispersion. \hfill ({\F !/pr4})}
\end{vlist}

\noindent
The structure {\F sflp} contains the following alias pointer, presented as
above.

\begin{vlist}
\vit{nittin}{i }{Number of iterations for drag calculation. \\ \strut
                                  \hfill ({\F !/flx2}, {\F !/flx3})}
\vit{cinxsi}{r }{Constant in parametric description of drag. \\ \strut
                                  \hfill ({\F !/flx2}, {\F !/flx3})}
\vit{cap\_id}{i}{Type of cap applied to $C_d$.    \hfill ({\F !/flx3})}
\vit{cd\_max}{r}{Maximum value for $C_d$.         \hfill ({\F !/flx3})}
\end{vlist}

\noindent
The structure {\F slnp} contains the following alias pointer, presented as
above.

\begin{vlist}
\vit{snlc1 }{r }{Proportionality and other constants. \hfill ({\F !/ln1})}
\vit{fspm  }{r }{Factor for $f_{PM}$ in filter.       \hfill ({\F !/ln1})}
\vit{fshf  }{r }{Factor for $f_h$ in filter.          \hfill ({\F !/ln1})}
\end{vlist}

\noindent
The structure {\F srcp} contains the following alias pointers, with the
associated switches again displayed on the right.

\begin{vlist}
\vit{sinc1 }{r }{Combined constant for input.      \hfill ({\F !/st1})}
\vit{sdsc1 }{r }{Combined constant for dissipation.\hfill ({\F !/st1})}
\vit{zwind }{r }{Height at which the wind is defined.
                                               \hfill (m) ({\F !/st2})}
\vit{fswell}{r }{Reduction factor of negative input for swell.
                                                   \hfill ({\F !/st2})}
\vit{shstab, ofstab, ccng, ccps, ffng, ffps}{}{}
\vit{      }{r }{Factors in effective wind speed.  \hfill ({\F !/st2})}
\vit{cdsa{\it n}}{r }{Constants in high-freq. dissipation.
                                                   \hfill ({\F !/st2})}
\vit{sdsaln}{r }{Factor for nondimensional 1-D spectrum.
                                                   \hfill ({\F !/st2})}
\vit{cdsbn }{r }{Constants in parameterization of $\phi$.
                                                   \hfill ({\F !/st2})}
\vit{fpimin}{r }{Minimum value for $f_{p,i}$.      \hfill ({\F !/st2})}
\vit{xfh   }{r }{Constant for turbulent length scale.
                                                   \hfill ({\F !/st2})}
\vit{xfn   }{r }{Constants in combining low and high \\ frequency dissipation.
                                                   \hfill ({\F !/st2})}
\vit{zwnd }{r }{Height at which the wind is defined.
                                               \hfill (m) ({\F !/st3})}
\vit{aalpha}{r }{Minimum value of Charnock coefficient.
                                                   \hfill ({\F !/st3})}
\vit{bbeta}{r }{Wind-wave growth $\beta_{\mathrm{max}}$ parameter.
                                                   \hfill ({\F !/st3})}
\vit{zzalp}{r }{Wave age correction $z_\alpha$ in wind input.
                                                   \hfill ({\F !/st3})}
\vit{ttauwshelter }{}{}
\vit{    }{r }{Sheltering coefficient for input to short waves.
                                                   \hfill ({\F !/st3})}
\vit{sswellfpar }{}{}
\vit{    }{i }{Choice of negative input parameterization.
                                                   \hfill ({\F !/st3})}
\vit{ssdsc1}{r }{Constant for WAM4-part of dissipation.
                                                   \hfill ({\F !/st3})}
\vit{ddelta1}{r }{Weight of $k$ part in WAM4 dissipation.
                                                   \hfill ({\F !/st3})}
\vit{ddelta2}{r }{Weight of $k^2$ part in WAM4 dissipation.
                                                   \hfill ({\F !/st3})}
\vit{wwnmeanp}{r }{Mean wavenumber power for $S_{\mathrm{ds}}$.
                                                   \hfill ({\F !/st3})}
\vit{wwnmeanptail}{r }{Mean wavenumber power for the tail.
                                                   \hfill ({\F !/st3})}
\vit{sstxftwn,sstxftf,sstxftftail }{}{}
\vit{    }{r }{Tail coefficients for mean wavenumber.
                                                   \hfill ({\F !/st3})}
\vit{sswellf}{r }{Reduction factor of negative input for swell.
                                                   \hfill ({\F !/st4})}
\vit{sswellf2}{r }{Extra parameter for negative input.
                                                   \hfill ({\F !/st4})}
\vit{ssdsc2}{r }{Constant for dissipation.
                                                   \hfill ({\F !/st4})}
\vit{ssdsc3}{r }{Modification parameter for saturation power.
                                                   \hfill ({\F !/st4})}
\vit{ssdsc4}{r }{Hard relative threshold for saturation.
                                                   \hfill ({\F !/st4})}
\vit{ssdsc5}{r }{Constant for wave-turbulence term.
                                                   \hfill ({\F !/st4})}
\vit{ssdsbr}{r }{Saturation threshold for wave breaking.
                                                   \hfill ({\F !/st4})}
\vit{ssdsp}{r }{Base value of power of saturation.
                                                   \hfill ({\F !/st4})}
\vit{ssdsdth}{r }{Directional window for saturation.
                                                   \hfill ({\F !/st4})}
\end{vlist}

\noindent
The structure {\F snlp} contains the following alias pointers, presented as
above.

\begin{vlist}
\vit{snlc1 }{r }{Scaled proportionality constant.       \hfill ({\F !/nl1})}
\vit{lam   }{r }{Factor defining quadruplet.            \hfill ({\F !/nl1})}
\vit{kdcon }{r }{Conversion factor for relative depth.  \hfill ({\F !/nl1})}
\vit{kdmn  }{r }{Minimum relative depth.                \hfill ({\F !/nl1})}
\vit{snlsn }{r }{Constants in shallow water factor.     \hfill ({\F !/nl1})}
\vit{iqtpe }{i }{Type of depth treatment.               \hfill ({\F !/nl2})}
\vit{ndpths}{i }{Number of depth for which integration space \\
                 needs to be computed.                  \hfill ({\F !/nl2})}
\vit{nltail}{r }{Tail factor for parametric tail.       \hfill ({\F !/nl2})}
\vit{dpthnl}{ra}{Depths corresponding to {\F ndpths}.   \hfill ({\F !/nl2})}
\end{vlist}

\noindent
The structure {\F sbtp} contains the following alias pointer, presented as
above.

\begin{vlist}
\vit{sbtc1 }{r }{Proportionality constant.        \hfill ({\F !/bt1})}
\end{vlist}

\noindent
The structure {\F sdbp} contains the following alias pointer, presented as
above.

\begin{vlist}
\vit{sdbc1 }{r }{Proportionality constant.        \hfill ({\F !/db1})}
\vit{sdbc2 }{r }{$H_{\max}/d$ ratio.              \hfill ({\F !/db1})}
\vit{fdonly}{l }{Flag for chocking depth only, otherwise use \\
                 Miche criterion.                 \hfill ({\F !/db1})}
\end{vlist}

\noindent
The structure {\F strp} contains the following alias pointer, presented as
above.

\begin{vlist}
\vit{dummy }{r }{Placeholder only.             \hfill ({\F !/tr0-x})}
\end{vlist}

\noindent
The structure {\F sbsp} contains the following alias pointer, presented as
above.

\begin{vlist}
\vit{dummy }{r }{Placeholder only.             \hfill ({\F !/bs0-x})}
\end{vlist}

\noindent
The structure {\F sxxp} contains the following alias pointer, presented as
above.

\begin{vlist}
\vit{dummy }{r }{Placeholder only.             \hfill ({\F !/xx0-x})}
\end{vlist}


\vspace{8mm}
%--------------------------------------------------------------%
\subsubsection{Data in {\F w3wdatmd}.} \label{sub:wdatmd}

The module {\F w3wdatmd} in the file {\file w3wdatmd.ftn} contains the dynamic
data of the model, that is, spectra and other fields describing the
instantaneous wave field. First several variables and parameters embedded in
the module are defined:

\begin{vlist}
\vit{nwdata}{i }{Number of models in array dim.}
\vit{iwdata}{i }{Selected model, initialized at -1.}
\vit{wdata }{t }{Basic data structure.}
\vit{wdatas}{ta}{Array of data structures.}
\end{vlist}

\noindent
For each element of the type {\F wdata}, direct aliases are defined with the
same name, as in {\F w3gdatmd}.  These variables are:

\begin{vlist}
\vit{time  }{ia}{Valid time for spectra.}
\vit{tlev  }{ia}{Valid time for water levels.}
\vit{tice  }{ia}{Valid time for ice.}
\vit{va    }{ra}{Storage array for spectra.}
\vit{wlv   }{ra}{Water levels.}
\vit{ice   }{ra}{Ice coverage.}
\vit{berg  }{ra}{Iceberg damping coefficient.}
\vit{ust   }{ra}{Friction velocities (absolute value).}
\vit{ustdir}{ra}{Friction velocities (direction).}
\vit{asf   }{ra}{Stability correction factor.}
\vit{fpis  }{ra}{Input peak frequencies.}
\vit{dinit }{l }{Flag for array initialization.}
\vit{fl\_all}{l}{Flag for array initialization to include {\F va}.}
\end{vlist}


\vspace{8mm}
%--------------------------------------------------------------%
\subsubsection{Data in {\F w3adatmd}.} \label{sub:adatmd}

The module {\F w3adatmd} in the file {\file w3adatmd.ftn} contains data that
are used inside the wave model only. Embedded in the module are the following
parameters:

\begin{vlist}
\vit{nadata}{i }{Number of models in array dim.}
\vit{iadata}{i }{Selected model for output, init. at -1.}
\vit{mpibuf}{IP}{Number of buffer arrays for 'hidden' MPI communications
                (no hiding for {\F mpibuf = 1}).}
\vit{wadat }{t }{Basic data structure.}
\vit{wadats}{ta}{Array of data structures.}
\end{vlist}

\noindent
For each element of the type {\F wadat}, alias pointers are defined as in the
module {\F w3adatmd}. Within the type, several groups of variables are
present. The first are the internal grid definition of the model:

\begin{vlist}
\vit{cg    }{ra}{Group velocities for all wave model sea points and 
                 frequencies.}
\vit{wn    }{ra}{Idem, wavenumbers.}
\end{vlist}

\noindent
The second group of parameters consists auxiliary arrays needed to process
model input:

\begin{vlist}
\vit{ca0-i  }{ra}{Absolute current velocity (initial and inc.) in \\
                  {\F w3ucur}. \hfill (m/s)}
\vit{cd0-i  }{ra}{Current direction (initial and increment) in \\
                  {\F w3ucur}. \hfill (rad)}
\vit{ua0-i  }{ra}{Absolute wind speeds (init. and incr.) in 
                  {\F w3uwnd} \hfill (m/s)}
\vit{ud0-i  }{ra}{Wind direction (initial and incr.) in
                  {\F w3uwnd} \hfill (rad)}
\vit{as0-i  }{ra}{Stability par. (initial and incr.) in
                  {\F w3uwnd} \hfill (degr)}
\vit{atrnx-y}{ra}{Actual transparency info.}
\end{vlist}

\noindent
The third group of parameters consists of internal gridded fields of
parameters:

\begin{vlist}
\vit{dw   }{ra}{Water depths.}
\vit{ua   }{ra}{Absolute wind speeds.}
\vit{ud   }{ra}{Absolute wind direction.}
\vit{u10  }{ra}{Wind speed used.}
\vit{u10d }{ra}{Wind direction used.}
\vit{as   }{ra}{Stability parameter.}
\vit{cx/y }{ra}{Current components.}
\vit{emn  }{ra}{Mean energy.}
\vit{fmn  }{ra}{Mean frequency.}
\vit{wnm  }{ra}{Mean wavenumber.}
\vit{amx  }{ra}{Spectral maximum.}
\vit{cds  }{ra}{Drag coefficient.}
\vit{z0s  }{ra}{Roughness parameter.}
\vit{hs   }{ra}{Wave height.}
\vit{wlm  }{ra}{Mean wave length.}
\vit{tmn  }{ra}{Mean wave period.}
\vit{thm  }{ra}{Mean wave direction.}
\vit{ths  }{ra}{Mean directional spread.}
\vit{fp0  }{ra}{Peak frequency.}
\vit{thp0 }{ra}{Peak direction.}
\vit{fp1  }{ra}{Wind sea peak frequency.}
\vit{thp1 }{ra}{Wind sea peak direction.}
\vit{dtdyn}{ra}{Mean dynamic time step (raw).}
\vit{fcut }{ra}{Cut-off frequency for tail.}
\vit{aba  }{ra}{Near bottom rms wave excursion amplitude.}
\vit{abd  }{ra}{Corresponding direction.}
\vit{uba  }{ra}{Near bottom rms wave velocity.}
\vit{ubd  }{ra}{Corresponding direction.}
\vit{s{\it xx}}{ra}{Radiation stress components.}
\vit{phs  }{ra}{Wave height of partition of spectrum.}
\vit{ptp  }{ra}{Peak period of partition of spectrum.}
\vit{plp  }{ra}{Peak wave length of partition of spectrum.}
\vit{pth  }{ra}{Direction of partition of spectrum.}
\vit{psi  }{ra}{Directional spread of partition of spectrum.}
\vit{pws  }{ra}{Wind sea fraction of partition of spectrum.}
\vit{pwst }{ra}{Wind sea fraction of total spectrum.}
\vit{pnr  }{ra}{Number of wave fields in partitioning.}
\vit{ddd{\it x} }{ra}{Spatial derivatives of the depth.}
\vit{dc{\it x}d{\it x}}{ra}{Spatial derivatives of the current.}
%\vit{drat }{ra}{Ratio or air and water densities.}
%\vit{tauo/y}{ra}{Momentum flux from waves to ocean.}
%\vit{tauw/y}{ra}{Momentum flux from atmosphere to waves.}
%\vit{phat}{ra}{Wave-modified mean pressure (responsible for set-up).}
%\vit{z0w}{ra}{Under-water roughness length.}
%\vit{phiaw}{ra}{Atmosphere to waves energy flux.}
%\vit{phioc}{ra}{Waves to ocean energy flux.}
%\vit{tusx/y}{ra}{Depth-integrated wave Stokes transport.}
%\vit{ussx/y}{ra}{Surface Stokes drift.}
%\vit{mssx/y}{ra}{Mean square slope components.}
%\vit{usero}{ra}{Slots for user-supplied output parameters.}
\end{vlist}

\noindent
The fourth group of parameters consists of map data for the first
order propagation scheme ({\F !/pr1}).

\begin{vlist}
\vit{is0-2 }{ia}{Spectral propagation maps.}
\vit{facvx-y}{ra}{Spatial propagation factor map.}
\end{vlist}

\noindent
The fifth group of parameters consists of map data for the third
order propagation scheme ({\F !/pr2-4}).

\begin{vlist}
\vit{nmx-y{\it{n}}}{i }{Counters for {\F mapx2}, see {\F w3map3}.}
\vit{nmxy  }{i }{Dimension of {\F mapxy}.}
\vit{nact1-2}{i }{Dimension of {\F mapaxy}.}
\vit{ncent }{i }{Dimension of {\F mapaxy}.}
\vit{mapx2 }{ia}{Map for prop. in 'x' (longitude) dir.}
\vit{mapy2 }{ia}{Idem in y' (latitude) direction.}
\vit{mapxy }{ia}{}
\vit{mapaxy}{ia}{List of active points used in {\F w3qck1}.}
\vit{mapcxy}{ia}{List of central points used in avg.}
\vit{mapth2}{ia}{Like {\F mapx2} for refraction (rotated and
                 shifted, see {\F w3ktp3}).
                 Like {\F mapaxy}.}
\vit{mapwn2}{ia}{Like {\F mapx2} for wavenumber shift.}
\vit{maptrn}{la}{Map to block out GSE mitigation in proper grid
                 points.}
\end{vlist}

\noindent 
The sixth group of parameters consists variables used by the parameterizations
for the nonlinear interactions :

\begin{vlist}
\vit{nfr        }{i }{Number of frequencies (\F{ nfr = nk } ).
                                                       \hfill ({\F !/nl1})}
\vit{nfrhgh     }{i }{Auxiliary frequency counter.     \hfill ({\F !/nl1})}
\vit{nfrchg     }{i }{Id.                              \hfill ({\F !/nl1})}
\vit{nspecx-y   }{i }{Auxiliary spectral counter.      \hfill ({\F !/nl1})}
\vit{ip\it{nn}  }{ia}{Spectral address for $S_{nl}$.   \hfill ({\F !/nl1})}
\vit{im\it{nn}  }{ia}{Id.                              \hfill ({\F !/nl1})}
\vit{ic\it{nn}  }{ia}{Id.                              \hfill ({\F !/nl1})}
\vit{dal\it{n}  }{r }{Lambda dependent weight factors. \hfill ({\F !/nl1})}
\vit{awg\it{n}  }{r }{Interpolation weights for Snl.   \hfill ({\F !/nl1})}
\vit{swg\it{n}  }{r }{Interpolation weights for diag. term.
                                                       \hfill ({\F !/nl1})}
\vit{af11       }{ra}{Scaling array ($f^{11}$).        \hfill ({\F !/nl1})}
\vit{nlinit     }{l }{Flag for initialization.         \hfill ({\F !/nl1})}
\end{vlist}

\noindent
The seventh group of parameters consists MPP and MPI variables:

\begin{vlist}
\vit{iappro}{ia}{Processor numbers for propagation calc. for each
                 spectral component.}
\vit{mpi\_comm\_wave, mpi\_comm\_wcmp}{}{}
\vit{      }{i }{mpi communicator for wave model.     \hfill ({\F !/mpi})}
\vit{ww3\_field\_vec, ww3\_spec\_vec}{}{}
\vit{      }{i }{MPI derived vector types.            \hfill ({\F !/mpi})}
\vit{nrqsg1}{i }{Number of handles in {\F irqsg1}.    \hfill ({\F !/mpi})}
\vit{nrqsg2}{i }{Number of handles in {\F irqsg2}.    \hfill ({\F !/mpi})}
\vit{ibfloc}{i }{Present active buffer number.        \hfill ({\F !/mpi})}
\vit{isploc}{i }{Corresponding local spectral bin number \\
                 {\F (1,nsploc,1)}.                   \hfill ({\F !/mpi})}
\vit{nsploc}{i }{Total number of spectral bins for which prop. \\ is
                 performed on present CPU.            \hfill ({\F !/mpi})}
\vit{bstat }{ia}{Status of buffer (size {\F mpibuf}): \hfill ({\F !/mpi})}
\vit{      }{  }{$\:\:$ 0: Inactive.}
\vit{      }{  }{$\:\:$ 1: {\F a} $\to$ {\F store} (active or finished).}
\vit{      }{  }{$\:\:$ 2: {\F store} $\to$ {\F a} (active or finished).}
\vit{bispl }{ia}{Local spectral bin number for buffer
                 (size {\F mpibuf}).                  \hfill ({\F !/mpi})}
\vit{irqsg1}{ia}{MPI request handles for scatters and gathers \\ to {\F va}
                (persistent).                         \hfill ({\F !/mpi})}
\vit{irqsg2}{ia}{MPI request handles for gathers and scatters \\ to
                 {\F STORE} (persistent).             \hfill ({\F !/mpi})}
\vit{gstore, sstore}{}{}
\vit{      }{ra}{Communication buffer {\F (nsea,mpibuf)}.
                                                      \hfill ({\F !/mpi})}
\vit{sppnt }{ra}{Communication buffer {\F (nth,nk,4)}.}
\end{vlist}

\noindent
The final group of parameters consist of all other internal auxiliary
parameters that need to be saved between model runs:

\begin{vlist}
\vit{itime }{i }{Discrete time step counter.}
\vit{ipass }{i }{Pass counter for log file.}
\vit{idlast}{i }{Last day ID for log file.}
\vit{nsealm}{i }{Maximum number of local sea points.}
\vit{alpha }{ra}{Phillips' alpha.}
\vit{flcold}{l }{Flag for 'cold start' of model.}
\vit{fliwnd}{l }{Flag for initialization of model based on wind.}
\vit{ainit }{l }{Flag for array initialization.}
\vit{fl\_all}{l}{Flag for all or partial array initialization.}
\end{vlist}


\vspace{8mm}
%--------------------------------------------------------------%
\subsubsection{Data in {\F w3odatmd}.} \label{sub:odatmd}


The module {\F w3odatmd} in the file {\file w3odatmd.ftn} contains the data
describing model output. First several variables and parameters embedded in
the module are defined:

\begin{vlist}
\vit{noutp }{i }{Number of models for which space is available.}
\vit{ioutp }{i }{Number of model/grid presently selected.}
\vit{iostyp}{i }{Flag for type of output server approach.}
\vit{nogrd }{ip}{Number of output field typed defined.}
\vit{noswll}{ip}{Number of swell fields from partitioning to be stored
                in fields.}
\vit{noextr}{ip}{Number of slots for user-defined output fields.}
\vit{idout }{ca}{ID strings for output fields.}
\vit{fnmpre}{ca}{File name preamble.}
\vit{undef }{r }{Value for undefined parameters in gridded output fields.}
\vit{unipts}{l }{Flag for unified point output (multi-grid model).}
\vit{upproc}{l }{Flag for separate processor for unified point
                 output (multi-grid model).}
\vit{output}{t }{Data structure containing output information.}
\vit{outpts }{ta}{Array of type {\F output} and size {\F noutp}.}
\end{vlist}

\noindent
For each element of the type {\F output}, alias pointers are defined as in
the module {\F w3gdatmd}. These variables are:

\begin{vlist}
\vit{ndso  }{i }{General output unit number (log file).}
\vit{ndse  }{i }{Error output unit number.}
\vit{ndst  }{i }{Test output unit number.}
\vit{screen}{i }{Unit for 'direct' output.}
\vit{ntproc}{i }{Number of processors (total).}
\vit{naproc}{i }{Number of processors (computation only).}
\vit{iaproc}{i }{Actual processor number (starting at 1),}
\vit{naplog}{i }{Proc. dealing with log output.}
\vit{napout}{i }{Proc. dealing with standard output.}
\vit{naperr}{i }{Proc. dealing with error output.}
\vit{napfld}{i }{Proc. dealing with raw field output.}
\vit{nappnt}{i }{Proc. dealing with raw point output.}
\vit{naptrk}{i }{Proc. dealing with track output.}
\vit{naprst}{i }{Proc. dealing with restart output.}
\vit{napbpt}{i }{Proc. dealing with boundary output.}
\vit{napprt}{i }{Proc. dealing with partitioning output.}
\vit{tofrst}{ia}{Times for first output.}
\vit{tonext}{ia}{Times for next output.}
\vit{tolast}{ia}{Times for last output.}
\vit{tbpi0 }{ia}{Time of first set of input boundary spectra.}
\vit{tbpin }{ia}{Idem second set.}
\vit{nds   }{ia}{Array with data set numbers.}
\vit{dtout }{ra}{Output intervals.}
\vit{flout }{la}{Output flags.}
\vit{out1  }{t }{Structure of type {\F OTYPE1} with data for output
                 type 1 (fields output).}
\vit{out2  }{t }{Idem {\F Otype2}, output type 2 (point output).}
\vit{out3  }{t }{Idem {\F otype3}, output type 3 (track output).}
\vit{out4  }{t }{Idem {\F otype4}, output type 4 (boundary data output).}
\vit{out5  }{t }{Idem {\F otype5}, output type 5 (restart files).}
\vit{out6  }{t }{Idem {\F otype6}, output type 6 (partitioning output).}
\end{vlist}

\noindent
For each element of the type {\F otype1}, alias pointers are defined as:

\begin{vlist}
\vit{ipass1}{i }{Pass counter in IO routine for file management.}
\vit{nrqgo }{i }{Number of handles in {\F irqgo}.      \hfill ({\F !/mpi})}
\vit{irqgo }{ia}{MPI request handles for field output. \hfill ({\F !/mpi})}
\vit{flogrd}{la}{Array with flags for output fields.}
\vit{write1}{l }{Flag for reading or writing data.}
\end{vlist}

\noindent
For each element of the type {\F otype2}, alias pointers are defined as:

\begin{vlist}
\vit{ipass2}{i }{Pass counter in IO routine for file management.}
\vit{nopts }{i }{Number of output points.}
\vit{nrqpo(2)}{i }{Number of MPI handles {\F irqpo}{\it{n}}.
                                                       \hfill ({\F !/mpi})}
\vit{iptint}{ia}{Id. interpolation counters.}
\vit{il    }{ia}{Number of land points in interpolation box for output point.}
\vit{iw    }{ia}{Id. water.}
\vit{ii    }{ia}{Id. ice.}
\vit{irqpo1/2}{ia}{Array with MPI handles.             \hfill ({\F !/mpi})}
\vit{ptloc }{ra}{Name of output locations.}
\vit{ptifac}{ra}{Id. weights.}
\vit{dpo   }{ra}{Interpolated depths.}
\vit{wao   }{ra}{Interpolated wind speeds.}
\vit{wdo   }{ra}{Interpolated wind directions.}
\vit{aso   }{ra}{Interpolated air-sea temp. diff.}
\vit{cao   }{ra}{Interpolated current speeds.}
\vit{cdo   }{ra}{Interpolated current directions.}
\vit{spco  }{ra}{Output spectra.}
\vit{ptnme }{ca}{Output locations.}
\vit{grdid }{ca}{Originating grid ID.}
\vit{o2init}{l }{Flag for array initialization.}
\vit{o2irqi}{l }{Flag for array initialization.}
\end{vlist}

\noindent
For each element of the type {\F otype3}, alias pointers are defined as:

\begin{vlist}
\vit{ipass3}{i }{Pass counter in IO routine for file management.}
\vit{it0pnt}{i }{Base tag number of MPI communication.}
\vit{it0trk}{i }{Base tag number of MPI communication.}
\vit{it0prt}{i }{Base tag number of MPI communication.}
\vit{nrqtr }{i }{Number of handles in {\F irqtr}.      \hfill ({\F !/mpi})}
\vit{irqtr }{ia}{Array with MPI handles.               \hfill ({\F !/mpi})}
\vit{o3init}{l }{Flag for array initialization.}
\vit{stop  }{l }{Flag for end of output.}
\vit{mask{\it{n}}}{la}{Mask arrays for internal use.}
\end{vlist}

\noindent
For each element of the type {\F otype4}, alias pointers are defined as:

\begin{vlist}
\vit{ifile4}{i }{File number for output files.}
\vit{nblkrs}{i }{Number of blocks in communication of spectra.
                                                       \hfill ({\F !/mpi})}
\vit{rsblks}{i }{Corresponding block size.             \hfill ({\F !/mpi})}
\vit{nrqrs }{i }{Number of MPI handles.                \hfill ({\F !/mpi})}
\vit{irqrs }{ia}{Array with MPI handles.               \hfill ({\F !/mpi})}
\vit{irqrss}{ia}{Array with MPI handles.               \hfill ({\F !/mpi})}
\vit{vaaux }{ia}{Aux. spectra storage.                 \hfill ({\F !/mpi})}
\end{vlist}

\noindent
For each element of the type {\F otype5}, alias pointers are defined as:

\begin{vlist}
\vit{nbi(2)  }{i }{Number of input bound. points.}
\vit{nfbpo   }{i }{Number of files for output bound. data.}
\vit{nrqbp(2)}{i }{Number of MPI handles.              \hfill ({\F !/mpi})}
\vit{nbo(2)  }{ia}{Number of output boundary points. per file.}
\vit{ndsl    }{ia}{Array with unit numbers.}
\vit{ipbpi   }{ia}{Interpolation data for input boundary points.}
\vit{isbpi   }{ia}{Sea point counters for input boundary points.}
\vit{irqbp1/2}{ia}{Array with MPI handles.             \hfill ({\F !/mpi})}
\vit{x/ybpi  }{ra}{Location of input boundary points.}
\vit{rdbpi   }{ra}{Interpolation factors for input boundary points.}
\vit{abpi0/n }{ra}{Storage of spectra from which to interpolate boundary data.}
\vit{bbpi0/n }{ra}{Id., secondary storage.}
\vit{abpos   }{ra}{Temporarily storage for output boundary data. }
\vit{}{}{\strut}
\vit{ipbpo, isbpo, x/ybpo, rdbpo}{}{}
\vit{        }{--}{Id. for output boundary points.}
\vit{o5ini{\it n}}{l}{Flags for array initializations.}
\vit{flbpi   }{l }{Flag for input of boundary data.}
\vit{flbpo   }{l }{Flag for output of boundary data.}
\vit{filer   }{l }{Read flag for file management.}
\vit{filew   }{l }{Write flag for file management.}
\vit{filed   }{l }{Dump flag for file management (multi-grid model).}
\vit{spconv  }{l }{Dump flag for file management (multi-grid model).}
\end{vlist}

\noindent
For each element of the type {\F otype6}, alias pointers are defined as:

\begin{vlist}
\vit{ipass6 }{i }{Pass counter for file management.}
\vit{ihmax  }{i }{Number of discrete spectral levels.}
\vit{ix0/n/s}{i }{First-last-step {\F ix} counters.}
\vit{iy0/n/s}{i }{Idem {\F iy} counters.}
\vit{hspmin }{r }{Minimum significant height per part.}
\vit{wsmult }{r }{Multiplier for wind sea boundary.}
\vit{wscut  }{r }{Cut-off wind factor for wind seas.}
\vit{icprt  }{ia}{Counters for partitions.}
\vit{dtprt  }{ra}{Data from partitions.}
\vit{flcomb }{l }{Flag for combining wind seas.}
\vit{flform }{l }{Flag for (un)formatted output.}
\vit{o6init }{l }{Flag for array initializations.}
\end{vlist}


\vspace{8mm}
%--------------------------------------------------------------%
\subsubsection{Data in {\F w3idatmd}.} \label{sub:idatmd}

The module {\F w3idatmd} in the file {\file w3idatmd.ftn} contains the
input data for the wave model.  First several variables and parameters
embedded in the module are defined:

\begin{vlist}
\vit{nidata}{i }{Number of models for which space is available.}
\vit{iidata}{i }{Number of model/grid presently selected.}
\vit{input }{t }{Data structure containing output information.}
\vit{inputs }{ta}{Array of type {\F input} and size {\F nidata}.}
\end{vlist}

\noindent
For each element of the type {\F input}, alias pointers are defined as in
the module {\F w3gdatmd}. These variables are:

\begin{vlist}
\vit{tln   }{ia}{Time for water level field.}
\vit{tc0/n }{ia}{Times for current fields.}
\vit{tw0/n }{ia}{Times for wind fields.}
\vit{tin   }{ia}{Time for ice field.}
\vit{t{\it n}n}{ia}{Time for data types 1-3.}
\vit{tdn   }{ia}{Time for next data.}
\vit{tg0/n }{ia}{Times for grid motion data.}
\vit{tfn   }{ia}{Array consolidating most above times.}
\vit{ga0/n }{r }{Norm of grid speed vector. \hfill{(ms$^{-1}$)}}
\vit{gd0/n }{r }{Direction of grid speed vector. \hfill{(?)}}
\vit{wx0/n, wy0/n }{ }{ }
\vit{      }{ra}{Cartesian wind components. \hfill{(ms$^{-1}$)}}
\vit{dt0/n }{ra}{Air-sea temperature differences. \hfill{($\degree$C)}}
\vit{cx0/n, cy0/n }{ }{ }
\vit{      }{ra}{Cartesian current components \hfill{(ms$^{-1}$)}.}
\vit{wlev  }{ra}{Water level field. \hfill{(m)}}
\vit{icei  }{ra}{Ice concentrations. \hfill{(-)}}
\vit{iinit }{l }{Flag for array initialization.}
\vit{fllev }{l }{Flag for water level input.}
\vit{flcur }{l }{Flag for current input.}
\vit{flwind}{l }{Flag for wind input.}
\vit{flice }{l }{Flag for ice input.}
\vit{flags }{la}{Array consolidating the above four flags, as well as four
                 additional data flags.}
\end{vlist}


\vspace{8mm}
%--------------------------------------------------------------%
\subsubsection{Data in {\F wmmdatmd}.} \label{sub:mdatmd}

The module {\F wmmdatmd} in the file {\file wmmdatmd.ftn} contains the
input data for the wave model.  First several variables and parameters
embedded in the module are defined:

\begin{vlist}
\vit{nmdata}{i }{Number of models in array dim.}
\vit{imdata}{i }{Selected model in data structure.}
\vit{mdsi  }{i }{Unit number for input file.}
\vit{mdso  }{i }{Unit number for output (log file).}
\vit{mdss  }{i }{Unit number for output (screen).}
\vit{mdst  }{i }{Unit number for test output.}
\vit{mdse  }{i }{Unit number for error output.}
\vit{      }{ }{These outputs correspond to similar unit numbers as
                defined per grid, but are used for multi-grid routines
                only.}
\vit{mdsp  }{i }{Unit number for profiling.}
\vit{mdsup }{i }{Unit number for unified point output.}
\vit{mdsf  }{ia}{Unit numbers for input files.}
\vit{nmproc}{i }{Number of processors (for total multi- grid model).}
\vit{improc}{i }{Corresponding actual processor number.}
\vit{nmplog, nmpscr, nmptst, nmperr, nmpupt}{}{}
\vit{      }{i }{Processors in {\F nmproc} designated for the above
                 output units numbers.}
\vit{stime }{ia}{Model run starting time.}
\vit{etime }{ia}{Model run ending time.}
\vit{tsync }{ia}{Synchronization time for grids.}
\vit{tmax  }{ia}{Maximum next time per grid.}
\vit{toutp }{ia}{Next output time for grids.}
\vit{tdata }{ia}{Time for which data is available.}
\vit{nrgrd }{i }{Number of grids.}
\vit{nrinp }{i }{Number of input grids.}
\vit{nrgrp }{i }{Number of groups.}
\vit{nmvmax}{i }{Number of moving grid data.}
\vit{grank }{ia}{Rank number for grid.}
\vit{grgrp }{ia}{Group number for grid.}
\vit{ingrp }{ia}{Grids in group, element 0 is number.}
\vit{grdhgh, grdeql, grdlow}{}{}
\vit{      }{ia}{Dependent grids with higher, same or lower rank number,
                 element 0 is number.}
\vit{allprc}{ia}{Map of processors in {\F mpi\_comm\_mwave} for all
                 individual grids.}
\vit{modmap}{ia}{Map which model is running where in {\F mpi\_comm\_mwave}
                 each group.}
\vit{grstat}{ia}{Grid computation status indicator.}
\vit{dtres }{ra}{Residual of time step.}
\vit{nbi2g }{ia}{Map cross-referencing how many spectra echo grid provides
                 to boundary cond. for other grids.}
\vit{respec}{la}{Map for need to convert spectra between grids.}
\vit{bcdump}{la}{Flag for dumping internal bound. data.}
\vit{inpmap}{ia}{Map for external input grids.}
\vit{idinp }{ca}{Input field identifiers.}
\vit{clkt0, clkinc, clkmax}{}{}
\vit{       }{i }{Global wall clock parameters,}

\vit{flgbdi}{l }{Flag for initialization of boundary distance maps.}
\vit{flghgn}{l }{Flags for using mask for computations and output for
                 areas of grid overlap.}
\vit{iflsti}{la}{Flags for last ice per grid.}
\vit{iflstl}{la}{Flags for last level per grid.}

\vit{mpi\_comm\_mwave}{}{}
\vit{      }{i }{MPI communicator.                    \hfill ({\F !/mpi})}
\vit{mtagn }{i }{"Zero" tag number for MPI.           \hfill ({\F !/mpi})}
\vit{nbista}{ia}{Status for gathering input boundary data.
                                                      \hfill ({\F !/mpi})}
\vit{hghsta}{ia}{Status for gathering high resolution data.
                                                      \hfill ({\F !/mpi})}
\vit{eqlsta}{ia}{Status for gath. data for equally ranked grids.
                                                      \hfill ({\F !/mpi})}
\vit{mdata }{t}{Data structure for grid dependent data.}
\vit{mdatas}{ta}{Array of data structures.}
\vit{bpst  }{t }{Data structure for staging boundary data.}
\vit{bpstge}{ta}{Array of data structures.}
\vit{hgst  }{t }{Data structure for staging 2-way nesting data.}
\vit{hgstge}{ta}{Array of data structures.}
\vit{eqst  }{t }{Data structure for staging equal grid reconciliation 
                 data.}
\vit{eqstge}{ta}{Array of data structures.}
\end{vlist}

\noindent
For each element of the type {\F mdata}, alias pointers are defined as in
the module {\F w3gdatmd}. These variables are:

\begin{vlist}
\vit{nbi2s }{ia}{Source information of boundary input data (grid number
                 and sea counter).}
\vit{mapbdi}{ra}{Map with distances to boundary.}
\vit{mapodi}{ra}{idem, open edges of grids.}
\vit{nrupts}{i }{Number of unified output points.}
\vit{uptmap}{ia}{Mapping of unified points to grids.}
\vit{mapmsk}{ia}{Mask corresponding to {\F flghg}{\it n} above.}
\vit{minit, mskini, fldat{\it n}}{}{}
\vit{      }{l }{Flags for array initializations.}
\vit{fllsti}{l }{Flag for last ice per grid.}
\vit{fllstl}{l }{Flag for last level per grid.}
\vit{nmv   }{i }{Number of moving grid data.}
\vit{tmv   }{ia}{Moving grid times.}
\vit{amv   }{ra}{Moving grid velocities.}
\vit{dmv   }{ra}{Moving grid directions.}
\vit{rcld  }{ia}{Record length for data assimilation.}
\vit{ndt   }{ia}{Number of data for data assimilation.}
\vit{datan }{ra}{Assimilation data.}
\vit{mpi\_comm\_grd, mpi\_comm\_bct}{}{}
\vit{      }{i }{Communicators for grid and broadcast. \hfill ({\F !/mpi})}
\vit{croot }{I }{"root" for {\F mpi\_comm\_grd} in {\F mpi\_comm\_mwave}.}
\vit{      }{  }{\strut                                \hfill ({\F !/mpi})}
\vit{fbcast}{l }{Flag for need of broadcasting data to processors that
                 are not in the communicator.          \hfill ({\F !/mpi})}
\vit{nrqbpg}{i }{Number of request handles.            \hfill ({\F !/mpi})}
\vit{irqbpg}{ia}{Request handles.                      \hfill ({\F !/mpi})}
\vit{nrqhgg}{i }{Number of request handles.            \hfill ({\F !/mpi})}
\vit{irqhgg}{ia}{Request handles.                      \hfill ({\F !/mpi})}
\vit{nrqeqg}{i }{Number of request handles.            \hfill ({\F !/mpi})}
\vit{irqeqg}{ia}{Request handles.                      \hfill ({\F !/mpi})}
\end{vlist}

\noindent
For each element of the type {\F bpst}, alias pointers are defined as in
the module {\F w3gdatmd}. These variables are:

\begin{vlist}
\vit{nrqbps}{i }{Number of request handles.            \hfill ({\F !/mpi})}
\vit{irqbps}{ia}{Request handles.                      \hfill ({\F !/mpi})}
\vit{vtime }{ia}{Valid time of data.}
\vit{stime }{ia}{Buffer for time for sending.          \hfill ({\F !/mpi})}
\vit{sbpi  }{ra}{Spectral data storage.}
\vit{tstore}{ra}{Spectral data buffer.                 \hfill ({\F !/mpi})}
\vit{init  }{l }{Flag for array allocation.}
\end{vlist}

\noindent
For each element of the type {\F hgst}, alias pointers are defined as in
the module {\F w3gdatmd}. These variables are:

\begin{vlist}
\vit{nrqhgs}{i }{Number of request handles.            \hfill ({\F !/mpi})}
\vit{irqhgs}{ia}{Request handles.                      \hfill ({\F !/mpi})}
\vit{nrqout}{i }{Number of local spectra.              \hfill ({\F !/mpi})}
\vit{outdat}{ia}{Corresponding data.                   \hfill ({\F !/mpi})}
\vit{ntot, nrec, nrc1, nsnd, nsn1, nsmx}{}{}
\vit{      }{i }{Counters for total data, send and received data with and
                 without masking.}
\vit{vtime }{ia}{Valid time of data.}
\vit{ljsea }{ia}{Local sea point counters.}
\vit{nravg }{ia}{Number of points in averaging.}
\vit{impsrc}{ia}{Source processor for data.}
\vit{itag  }{ia}{Communication tag.}
\vit{isend }{ia}{Composite of all data needed for send.}
\vit{wght  }{ra}{Weights in averaging.}
\vit{shgh  }{ra}{Staging area for spectra.}
\vit{tstore}{ra}{Staging area for spectra to be send out.
                                                       \hfill ({\F !/mpi})}
\vit{init  }{l }{Flag for array allocation.}
\end{vlist}

\noindent
For each element of the type {\F eqst}, alias pointers are defined as in
the module {\F w3gdatmd}. These variables are:

\begin{vlist}
\vit{nrqeqs}{i }{Number of request handles.            \hfill ({\F !/mpi})}
\vit{irqeqs}{ia}{Request handles.                      \hfill ({\F !/mpi})}
\vit{nrqout}{i }{Number of local spectra.              \hfill ({\F !/mpi})}
\vit{outdat}{ia}{Corresponding data.                   \hfill ({\F !/mpi})}
\vit{ntot, nrec, nsnd, navmax}{}{}
\vit{      }{i }{Counters for total data, send and received data.}
\vit{vtime }{ia}{Valid time of data.}
\vit{i/jsea}{ia}{Sea point counters.}
\vit{navg  }{ia}{Number of spectra in averaging.}
\vit{rip   }{ia}{Processor (receiving).}
\vit{rtg   }{ia}{Tag number (receiving).}
\vit{sis,sjs}{ia}{Sea point counter (sending).}
\vit{si1/2 }{ia}{Storage array counters (sending).}
\vit{sip   }{ia}{Processor (sending).}
\vit{stg   }{ia}{Tag (sending).}
\vit{seql  }{ra}{Staging array.}
\vit{wght  }{ra}{Weight between grids.}
\vit{wavg  }{ra}{Weight within grid.}
\vit{tstore}{ra}{Staging area for spectra to be send  out.
                                                       \hfill ({\F !/mpi})}
\vit{init  }{l }{Flag for array allocation.}
\end{vlist}

\bpage
