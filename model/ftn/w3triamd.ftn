MODULE W3TRIAMD
!/ ------------------------------------------------------------------- 
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |       F. Ardhuin and A. Roland    |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          25-Aug-2011|
!/                  +-----------------------------------+
!/
!/    15-Mar-2007 : Origination.                        ( version 3.13 )
!/    25-Aug-2011 : Modification of boundary treatment  ( version 4.04 )
!/
!
!  1. Purpose :
!
!      Reads triangle and unstructured grid information
!
!  2. Method :
!
!     Look for namelist with name NAME in unit NDS and read if found.
!
!  3. Parameters :
!
!
!  4. Subroutines used :
!
!      Name               Type  Module   Description
!     ------------------------------------------------------------------------------------
!      READTRI            Subr. Internal Read unstructured grid data from .grd .tri formatted files.
!      READMSH            Subr.   Id.    Read unstructured grid data from MSH format
!      COUNT              Subr. Internal Count connection.
!      SPATIAL_GRID       Subr.   Id.    Calculate surfaces.
!      NVECTRI            Subr.   Id.    Define cell normals and angles and edge length
!      COORDMAX           Subr.   Id.    Calculate  useful grid elements
!      AREA_SI            Subr.   Id.    Define Connections
!     ------------------------------------------------------------------------------------
!
!
!  5. Called by :
!
!     Program in which it is contained.
!
!  6. Error messages :
!
!  7. Remarks :
!     The only point index which is needed is IX and NX stands for the total number of grid point.
!     IY and NY are not needed anymore, they are set to 1 in the unstructured case
!     Some noticeable arrays are:
!                     XYB    : give the 2D coordinates of all grid points
!                     TRIGP  : give the vertices of each triangle
!  8. Structure :
!
!  9. Switches :
!       !/PR3   : Enables unstructured meshes (temporary, will be replace by Unstructured switch)
!       !/LLG   : Spherical longitude-latitude grid
!       !/XYG   : Cartesian grid
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
 PUBLIC
!      USE CONSTANTS
!      USE W3GDATMD, ONLY: W3NMOD, W3SETG
!      USE W3ODATMD, ONLY: W3NO<UT, W3SETO, W3DMO5
!      USE W3IOGRMD, ONLY: W3IOGR
!     USE W3SERVMD, ONLY: ITRACE, NEXTLN, EXTCDE
!!/S      USE W3SERVMD, ONLY: STRACE
!      USE W3ARRYMD, ONLY: INA2R, INA2I
!!/T      USE W3ARRYMD, ONLY: PRTBLK
!      USE W3DISPMD, ONLY: DISTAB
!      USE W3GDATMD
!      USE W3ODATMD, ONLY: NDSE, NDST, NDSO
!      USE W3ODATMD, ONLY: NBI, NBI2, NFBPO, NBO, NBO2, FLBPI, FLBPO,  &
!                         IPBPO, ISBPO, XBPO, YBPO, RDBPO, FNMPRE
!--------------------------------------------------------------------- 
! 
!C
        integer :: node_num
        integer :: dim_num
        integer :: triangle_order
        integer :: triangle_num
        integer :: bound_edge_num
        integer :: bound_num
!C        
        logical,save, allocatable :: edge_boundary(:)
        logical,save, allocatable :: node_boundary(:)
        integer,save, allocatable :: edge_nums(:)
        integer,save, allocatable :: boundary_node_index(:)
!C        
        integer,save, allocatable :: triangle_node(:,:)
        integer,save, allocatable :: edge(:,:)
        integer,save, allocatable :: edge_index(:,:)

        real (kind = 8), save, allocatable :: node_xy(:,:)
        real (kind = 8), save, allocatable :: edge_angle(:,:)
  
CONTAINS
!/ -------------------------------------------------------------------/
SUBROUTINE READMSH(NDS,FNAME,REFSLOPE) 
!/ ------------------------------------------------------------------- 
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           F. Ardhuin              |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          05-Dec-2011|
!/                  +-----------------------------------+
!/
!/    15-Feb-2008 : Origination.                        ( version 3.13 )
!/    25-Aug-2011 : Change of method for IOBPD          ( version 4.04 )
!/    05-Dec-2011 : Adding shoreline slope in tags      ( version 4.04 )
!/
!
!  1. Purpose :
!
!      Reads triangle and unstructured grid information from GMSH files
!      Calls the subroutines needed to compute grid connectivity
!
!  2. Method :
!
!     Look for namelist with name NAME in unit NDS and read if found.
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       NDS     Int.   I   Data set number used for search.
!       NAME    C*4    I   Name of namelist.
!       STATUS  C*20   O   Status at end of routine,
!                            '(default values)  ' if no namelist found.
!                            '(user def. values)' if namelist read.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name               Type  Module   Description
!     ------------------------------------------------------------------------------------
!      COUNT              Subr. Internal Count connection.
!      SPATIAL_GRID       Subr.   Id.    Calculate surfaces.
!      NVECTRI            Subr.   Id.    Define cell normals and angles and edge length
!      COORDMAX           Subr.   Id.    Calculate  useful grid elements
!      AREA_SI            Subr.   Id.    Define Connections
!     ----------------------------------------------------------------
!
!
!
!  5. Called by :
!
!     Program in which it is contained.
!
!  6. Error messages :
!
!  7. Remarks :
!     The only point index which is needed is IX and NX stands for the total number of grid point.
!     IY and NY are not needed anymore, they are set to 1 in the unstructured case
!     Some noticeable arrays are:
!                     XYB    : give the 2D coordinates of all grid points
!                     TRIGP  : give the vertices of each triangle
!     GMSH file gives too much information that is not necessarily required so data processing is needed (data sort and nesting).
!  8. Structure :
!
!  9. Switches :
!       !/PR3   : Enables unstructured meshes (temporary, will be replace by Unstructured switch)
!       !/LLG   : Spherical longitude-latitude grid
!       !/XYG   : Cartesian grid
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
      USE W3ODATMD, ONLY: NDSE, NDST, NDSO
      USE W3GDATMD
      USE W3SERVMD, ONLY: ITRACE, NEXTLN, EXTCDE
!
      IMPLICIT NONE
!/
!/ Parameter list
!/
      INTEGER, INTENT(IN)                :: NDS
      REAL,    INTENT(IN)                :: REFSLOPE
      CHARACTER(60), INTENT(IN)          :: FNAME
!/
!/ local parameters 
!/      
      INTEGER                            :: i,j,k, NODES, NELTS, ID, KID
      INTEGER                            :: ID1, ID2, KID1
      INTEGER                            :: I1, I2, I3
      INTEGER(KIND=4)                    :: Ind,eltype,ntag, INode
      CHARACTER                          :: COMSTR*1, SPACE*1 = ' ', CELS*64
      REAL, ALLOCATABLE                  :: TAGS(:)
      CHARACTER(LEN=64), ALLOCATABLE     :: ELS(:)
      CHARACTER(LEN=120)                 :: LINE
      CHARACTER(LEN=50)                  :: CHTMP
      CHARACTER(LEN=10)                  :: A, B, C
      INTEGER,ALLOCATABLE                :: NELS(:), TRIGPTMP1(:,:), TRIGPTMP2(:,:)
      INTEGER,ALLOCATABLE                :: IFOUND(:), VERTEX(:)
      DOUBLE PRECISION, ALLOCATABLE      :: XYBTMP1(:,:),XYBTMP2(:,:)
!/REF1      REAL,ALLOCATABLE                   :: REFSLOPEMAP(:)
      REAL                               :: z

      OPEN(NDS,FILE = FNAME,STATUS='old')
      READ (NDS,'(A)') COMSTR
      IF (COMSTR.EQ.' ') COMSTR = '$'
      CALL NEXTLN(COMSTR, NDS, NDSE)
      READ(NDS,*) i,j,k
      CALL NEXTLN(COMSTR, NDS, NDSE)

!
! read number of nodes and nodes from Gmsh files
!
      READ(NDS,*) NODES
      ALLOCATE(XYBTMP1(NODES,3))
      DO I= 1, NODES
        READ(NDS,*) j, XYBTMP1(I,1), XYBTMP1(I,2), XYBTMP1(I,3)
        END DO
! Initialization of coastal reflections
!/REF1     ALLOCATE(REFSLOPEMAP(NODES)) 
!/REF1     REFSLOPEMAP(:)=.001
!
! read number of elements and elements from Gmsh files
!
     CALL NEXTLN(COMSTR, NDS, NDSE)
      READ(NDS,*) NELTS
      ALLOCATE(TRIGPTMP1(NELTS, 3))
      J = 0 
      DO I= 1, NELTS
        READ(NDS,'(A100)') LINE
        READ(LINE,*) Ind,eltype,ntag
        ALLOCATE(TAGS(ntag))
        SELECT CASE (eltype) 
!
! eltype = 15 : boundary points
!
        CASE(15)
          READ(LINE,*) Ind,eltype,ntag,TAGS,INODE
          IF (ntag.EQ.3) THEN
!/REF1            REFSLOPEMAP(Inode)=REFSLOPE*TAGS(3)
            END IF
!
! eltype = 2 : triangles
!
        CASE (2)
          READ(LINE,*)  Ind,eltype,ntag,tags,I1, I2, I3
          J = J+ 1
          TRIGPTMP1(J,1)=I1
          TRIGPTMP1(J,2)=I2
          TRIGPTMP1(J,3)=I3
          END SELECT

        DEALLOCATE(TAGS)
        END DO
!
! organizes the grid data structure 
!
      NTRI = J 
  
      ALLOCATE(IFOUND(NODES))
 
      IFOUND = 0
!
! Verifies that the nodes are used in at least one triangle
! 
      DO K = 1, NTRI
        I1 = TRIGPTMP1(K,1)
        I2 = TRIGPTMP1(K,2)
        I3 = TRIGPTMP1(K,3)
    
        IFOUND(I1)= IFOUND(I1) + 1
        IFOUND(I2)= IFOUND(I2) + 1
        IFOUND(I3)= IFOUND(I3) + 1
        END DO
 
      J = 0
 
      ALLOCATE(TRIGPTMP2(NTRI,3),VERTEX(NODES),XYBTMP2(NODES,3)) 
      VERTEX(:)=0
      XYBTMP2 = 0

      DO I = 1, NODES
        IF( IFOUND(I) .GT. 0) THEN
          J = J+1
          XYBTMP2(J,:) = XYBTMP1(I,:) 
          VERTEX(I) = J
          END IF
        END DO
!
! Number of nodes after clean up 
! 
      NX = J  
!
      DO I = 1, NTRI
        I1 = TRIGPTMP1(I,1)
        I2 = TRIGPTMP1(I,2)
        I3 = TRIGPTMP1(I,3)
        TRIGPTMP2(I,1)= VERTEX(I1)
        TRIGPTMP2(I,2)= VERTEX(I2)
        TRIGPTMP2(I,3)= VERTEX(I3)
        END DO   
!
      DEALLOCATE( XYBTMP1, IFOUND,TRIGPTMP1)
      DEALLOCATE(VERTEX)
!
!count points connections to allocate array in W3DIMUG 
!
      CALL COUNT(TRIGPTMP2)
      CALL W3DIMUG ( 1, NTRI, NX, COUNTOT, NNZ, NDSE, NDST ) 
!/REF1      UG_REFLC(:)=REFSLOPEMAP(1:NX)
!
! fills arrays
!
      DO I = 1, NX
        XYB(I,1) = XYBTMP2(I,1) 
        XYB(I,2) = XYBTMP2(I,2) 
        XYB(I,3)= XYBTMP2(I,3)
        END DO
! XGRD AND YGRD ... these are allocated by W3DIMX  
      DO I=1, NTRI
        TRIGP(I,:) = TRIGPTMP2(I,:)
        END DO   
!   
     DEALLOCATE(TRIGPTMP2,XYBTMP2)   
!
! call the various routines which define the point spotting strategy
!
     CALL SPATIAL_GRID    
     CALL NVECTRI
     CALL COORDMAX
!AR: Check for Multigrid
     CALL AREA_SI(1)
!     WRITE (NDSO,969) NX, NY, SX,DXYMAX,     &
!                      X0, MAXX,                  &
!                      Y0, MAXY
!
! Formats
!
!
!/LLG  969 FORMAT (/'  The spatial unstructured cartesian grid : '/                    &
!/LLG               ' -----------------------------------------------------'/ &
!/LLG               '       Discrete dimensions          :',I10,I3/     &
!/LLG               '       Increments min & max   (deg) :',2E14.6/     &
!/LLG               '       longitudes min &  max  (deg) :',2F12.4/     &
!/LLG               '       latitudes  min &  max  (deg) :',2F12.4)

!/XYG  969 FORMAT (/'  The spatial unstructured cartesian grid : '/                    &
!/XYG               ' -----------------------------------------------------'/ &
!/XYG               '       Discrete dimensions         :',I7,I10/     &
!/XYG               '       Increments min & max   (km) :',2E14.6/     &
!/XYG               '       X min & X max          (km) :',2F12.4/     &
!/XYG               '       Y min & Y max          (km) :',2F12.4)
      CLOSE(NDS)
      END SUBROUTINE
!/--------------------------------------------------------------------/


!/----------------------------------------------------------------------
      SUBROUTINE SPATIAL_GRID
!/ ------------------------------------------------------------------- 
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |      A. Roland  and F. Ardhuin    |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          31-Aug-2011|
!/                  +-----------------------------------+
!/
!/    15-May-2007 : Origination: adjustment from the WWM code       ( version 3.13 )
!/    31-Aug-2011 : Simplfies the cross products                    ( version 4.05 )
!/
!
!  1. Purpose :
!
!      Calculates triangle areas and reorders the triangles to have them 
!      oriented counterclockwise 
!
!  2. Method :
!
!     The triangle surface calculation is based on cross product.
!
!  3. Parameters :
!
!  4. Subroutines used :
!
!  5. Called by :
!
!       Name      Type  Module   Description
!     ----------------------------------------------------------------
!      READTRI    Subr. Internal  Unstructured mesh definition.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!     
!     This part of code is adapted from the WWM wave model develop at the Darmstadt University
!     (Aaron Roland)
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /   
         USE W3GDATMD  
         IMPLICIT NONE
!	 
!local parameters	 
! 
         REAL              :: TL1, TL2, TL3, TMPTRIGP
         INTEGER           :: I1, I2, I3
         INTEGER           :: K
!/S        INTEGER                      ::  IENT = 0          
!/ ------------------------------------------------------------------- /   
!/S      CALL STRACE (IENT, 'SPATIAL_GRID')   

                DO K = 1, NTRI
               
                   I1 = TRIGP(K,1)
                   I2 = TRIGP(K,2)
                   I3 = TRIGP(K,3)
!
! cross product of edge-vector  (orientated anticlockwise)
!                                   
                   TRIA(K) = REAL( (XYB(I2,2)-XYB(I1,2))      &     !  (Y2-Y1)
                                  *(XYB(I1,1)-XYB(I3,1))      &     ! *(X1-X3)
                                  +(XYB(I3,2)-XYB(I1,2))      &     !  (Y3-Y1)*(X2-X1)
                                  *(XYB(I2,1)-XYB(I1,1))      )*0.5
!
! test on negative triangle area, which means that the orientiation is not as assumed to be anticw. 
! therefore we swap the nodes !!! 
!      
                  IF (TRIA(K) < 0.0) THEN
         TMPTRIGP = TRIGP(K,2)
         TRIGP(K,2) = TRIGP(K,3)
         TRIGP(K,3) = TMPTRIGP
         I2 = TRIGP(K,2)
         I3 = TRIGP(K,3)
         TRIA(K) = -1.0*TRIA(K)
         END IF    
       TRIA03(K)=TRIA(K)*1./3. 
       END DO
     END SUBROUTINE
!/--------------------------------------------------------------------/
!
!/--------------------------------------------------------------------/
     SUBROUTINE DIFFERENCE
!/ ------------------------------------------------------------------- 
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           A. Roland               |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          15-May-2007|
!/                  +-----------------------------------+
!/
!/    15-Nov-2007 : Origination.                        ( version 3.13 )
!/
!
!  1. Purpose :
!
!      Calculate interpolation coefficient used gradient computation.
!
!  2. Method :
!
!     The interpolation coefficient are inspired by cross product.
!     The estimation uses Gauss' formula: the area integral of the gradient
!       is equal to the flux through the boundary. This formula is applied 
!       on individual triangles. 
!     The gradient at each grid node is then the angle-weighted sum of the 
!       gradients in each triangle. 
!       
!
!  3. Parameters :
!
!  4. Subroutines used :
!
!  5. Called by :
!
!       Name      Type  Module   Description
!     ----------------------------------------------------------------
!      READTRI    Subr. Internal Unstructured mesh definition.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!     
!     This part of code is adapted from the WWM wave model develop at the Darmstadt University
!     (Aaron Roland)
!     The gradients to be calculated are for depth and currents.
!     The three arrays  DW, CX and CY are allocated from 0 to NSEA and assuming that 
!     DW(0)=0.,CX(0)=0.,CY(0)=0. (MAPFS(1,IX) = 0 for the contour and land points) to abide by the 
!     structure of the array which are used through the code. So gradients could be irregular near 
!     the border. The interpolation coefficient reckoned in this subroutine consider this artificial 
!     discontinuity of value (between point on the border and point close to the border) and then
!     restore true gradients. 
!
!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /       
       USE W3GDATMD 

       IMPLICIT NONE

!
!local parameter 
!
         INTEGER           :: I1, I2, I3
         REAL              :: X1(3), X2(3), X3(3)
         INTEGER           :: K
         REAL              :: FACT
!/S        INTEGER                      ::  IENT = 0 
!/ ------------------------------------------------------------------- /       

!/S      CALL STRACE (IENT, 'DIFFERENCE')

   DO K = 1, NTRI 
     I1 = TRIGP(K,1)
     I2 = TRIGP(K,2)
     I3 = TRIGP(K,3)
!
! counters which stands for occurence of a vertex in the whole triangle list, i.e the number of its
! connected triangle
!		   
     X1(:) = XYB(I1,:)
     X2(:) = XYB(I2,:)
     X3(:) = XYB(I3,:)
!
! test to see if vertices are on the contour. if it is so, its coordinates are nullyfied
! this is perform to get better gradients at grid points near the contour.
!		  
     IF ((MAPSTA(1,I1).EQ.0).OR.(MAPSTA(1,I2).EQ.0)) THEN
       X1(:) = 0. 
       X2(:) = 0.
       END IF    
      IF ((MAPSTA(1,I1).EQ.0).OR.(MAPSTA(1,I3).EQ.0)) THEN
        X1(:) = 0. 
        X3(:) = 0.
        END IF
      IF ((MAPSTA(1,I3).EQ.0).OR.(MAPSTA(1,I2).EQ.0)) THEN
        X2(:) = 0. 
        X3(:) = 0.
        END IF

      FACT = 1./(2*TRIA(K))
!
! interpolation coefficient: these are the components of the normals to the 
! triangle sides, multiplied by the side length and divided by 2 times the 
! triangle area
!		   		   
      CROSSDIFF(1,K) = REAL(X2(2) - X3(2)) * FACT
      CROSSDIFF(2,K) = REAL(X3(2) - X1(2)) * FACT
      CROSSDIFF(3,K) = REAL(X1(2) - X2(2)) * FACT
      CROSSDIFF(4,K) = REAL(X3(1) - X2(1)) * FACT
      CROSSDIFF(5,K) = REAL(X1(1) - X3(1)) * FACT
      CROSSDIFF(6,K) = REAL(X2(1) - X1(1)) * FACT

      END DO
END SUBROUTINE

!/--------------------------------------------------------------------

    SUBROUTINE NVECTRI
!/ ------------------------------------------------------------------- 
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           A. Roland              |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          15-May-2008|
!/                  +-----------------------------------+
!/
!/    15-May-2007 : Origination: adjustment from the WWM code       ( version 3.13 )
!/
!
!  1. Purpose :
!
!      Calculate cell tools: inward normal, angles and length of edges.
!
!  2. Method :
!      To get inward pointing normals, triangle are glanced through anti-clockwisely
!     
!
!  3. Parameters :
!
!  4. Subroutines used :
!
!  5. Called by :
!
!       Name      Type  Module   Description
!     ----------------------------------------------------------------
!      READTRI    Subr. Internal  Unstructured mesh definition.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!     
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /       
    USE W3GDATMD
    USE CONSTANTS

         IMPLICIT NONE
	 
!
!local parameter 
!	 
	 
         INTEGER :: IP, IE
         INTEGER :: I1, I2, I3, I11, I22, I33
         REAL    :: P1(2), P2(2), P3(2)
         REAL    :: R1(2), R2(2), R3(2)
         REAL    :: N1(2), N2(2), N3(2)
	 REAL    :: TMP(3)
	 REAL    :: TMPINV(3)
!/S        INTEGER                      ::  IENT = 0 	 
!/ ------------------------------------------------------------------- /   
!/S      CALL STRACE (IENT, 'NVECTRI')   

    
         DO IE = 1, NTRI
!
! vertices
!
            I1 = TRIGP(IE,1)
            I2 = TRIGP(IE,2)
            I3 = TRIGP(IE,3)
                           
            P1(1) = XYB(I1,1)
            P1(2) = XYB(I1,2)
            P2(1) = XYB(I2,1)
            P2(2) = XYB(I2,2)
            P3(1) = XYB(I3,1)
            P3(2) = XYB(I3,2)
!
! I1 -> I2, I2 -> I3, I3 -> I1 (anticlockwise orientation is preserved)
!                    
            R1 = P3-P2
            R2 = P1-P3
            R3 = P2-P1
        
            N1(1) = (-R1(2))
            N1(2) = ( R1(1))
            N2(1) = (-R2(2))
            N2(2) = ( R2(1))
            N3(1) = (-R3(2))
            N3(2) = ( R3(1))  
!
! edges length
!            
            LEN(IE,1) = SQRT(R1(1)**2.+R1(2)**2.)
            LEN(IE,2) = SQRT(R2(1)**2.+R2(2)**2.)
            LEN(IE,3) = SQRT(R3(1)**2.+R3(2)**2.)   
!
! inward normal used for propagation (not normalized)
!            
            IEN(IE,1) = N1(1)
            IEN(IE,2) = N1(2)
            IEN(IE,3) = N2(1)
            IEN(IE,4) = N2(2)
            IEN(IE,5) = N3(1)
            IEN(IE,6) = N3(2)
    
            TMP(1)  = DOT_PRODUCT(R3,-R2)
            TMP(2)  = DOT_PRODUCT(R1,-R3)
            TMP(3)  = DOT_PRODUCT(R2,-R1)

            TMPINV(1) = 1./ (LEN(IE,2) * LEN(IE,3))
            TMPINV(2) = 1./ (LEN(IE,1) * LEN(IE,3))
            TMPINV(3) = 1./ (LEN(IE,2) * LEN(IE,1))

            TMP(1)  = DOT_PRODUCT(R3,-R2) * TMPINV(1)
            TMP(2)  = DOT_PRODUCT(R1,-R3) * TMPINV(2)
            TMP(3)  = DOT_PRODUCT(R2,-R1) * TMPINV(3)
!
!  angles used in gradients computation 
!     
            ANGLE0(IE,1) = ACOS(TMP(1))
            ANGLE0(IE,2) = ACOS(TMP(2))
            ANGLE0(IE,3) = ACOS(TMP(3))
            !WRITE(997,*) 'IE, ANGLE:',IE,ANGLE0(IE,1:3)*RADE
            !TRIA03(IE)=TRIA(IE)*1./3.
         END DO
 
     END SUBROUTINE
!/---------------------------------------------------------------------------

!/------------------------------------------------------------------------

      SUBROUTINE COUNT(TRIGPTEMP)      
     
!/ ------------------------------------------------------------------- 
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           F. Ardhuin              |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          15-May-2008|
!/                  +-----------------------------------+
!/
!/    15-May-2007 : Origination.                        ( version 3.13 )
!/
!      
!  1. Purpose :
!
!      Calculate global and maximum number of connection for array allocations .
!
!  2. Method :
!     
!  3. Parameters :
!     Parameter list
!     ----------------------------------------------------------------
!       NTRI         Int.   I   Total number of triangle.
!       TRIGPTEMP    Int    I   Temporary array of triangle vertices
!       COUNTRI      Int    O   Maximum number of connected triangle 
!                               for a given points
!       COUNTOT      Int    O   Global number of triangle connection 
!                               for the whole grid.   	
!     ----------------------------------------------------------------
!  4. Subroutines used :
!
!  5. Called by :
!
!       Name      Type  Module   Description
!     ----------------------------------------------------------------
!      READTRI    Subr. Internal  Unstructured mesh definition.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!     
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /  
        USE W3GDATMD

        IMPLICIT NONE

     
!/ parameter list

   INTEGER,INTENT(IN) :: TRIGPTEMP(:,:)
!/ ------------------------------------------------------------------- /   
!/ local parameter

   INTEGER               :: CONN(NX)
   INTEGER               :: COUNTER, IP, IE, I, J, N(3)
!/S        INTEGER                      ::  IENT = 0    
!/------------------------------------------------------------------------

!/S      CALL STRACE (IENT, 'COUNT')

COUNTRI=0
COUNTOT=0
CONN(:)= 0

!
!calculate the number of connected triangles for a given point.
!

DO IE = 1,NTRI
   N(:) = 0.
   N(1) = TRIGPTEMP(IE,1)
   N(2) = TRIGPTEMP(IE,2)
   N(3) = TRIGPTEMP(IE,3)
   CONN(N(1)) = CONN(N(1)) + 1
   CONN(N(2)) = CONN(N(2)) + 1
   CONN(N(3)) = CONN(N(3)) + 1
ENDDO
 
 COUNTRI = MAXVAL(CONN)
! 
! calculate the global number of connections available through the mesh
!
J=0
 DO  IP=1,NX
   DO I=1,CONN(IP)
      J=J+1
   ENDDO
 ENDDO
 COUNTOT=J  

END SUBROUTINE

!/----------------------------------------------------------------------------  
      SUBROUTINE COORDMAX
!/ ------------------------------------------------------------------- 
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           F. Ardhuin              |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          15-May-2008|
!/                  +-----------------------------------+
!/
!/    15-May-2007 : Origination.                        ( version 3.13 )
!/
!  1. Purpose :
!
!      Calculate first point and last point coordinates, and minimum and maximum edge length.
!
!  2. Method :
!     
!  3. Parameters :
!
!  4. Subroutines used :
!
!  5. Called by :
!
!       Name      Type  Module   Description
!     ----------------------------------------------------------------
!      READTRI    Subr. Internal  Unstructured mesh definition.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!     
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- / 
          USE W3GDATMD
          IMPLICIT NONE
!/S        INTEGER                      ::  IENT = 0  
            
  
!/S      CALL STRACE (IENT, 'COORDMAX') 
!     
! maximum of coordinates s
!
    MAXX = MAXVAL(XYB(:,1))
    MAXY = MAXVAL(XYB(:,2))
! 
! minimum of coordinates 
!
    X0 = MINVAL(XYB(:,1))
    Y0 = MINVAL(XYB(:,2))
! 
!maximum and minimum length of edges
!
    DXYMAX = MAXVAL(LEN(:,:))
    SX = MINVAL(LEN(:,:))
    SY = SX
! 
 END SUBROUTINE
!-------------------------------------------------------------------------

  SUBROUTINE AREA_SI(IMOD)
!/ ------------------------------------------------------------------- 
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           A. Roland               |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          23-Aug-2011|
!/                  +-----------------------------------+
!/
!/    15-May-2007 : Origination: adjustment from the WWM code       ( version 3.13 )
!/    23-Aug-2011 : Removes double entries in VNEIGH                ( version 4.04 )
!/  
!
!  1. Purpose :
!
!      Define optimized connection arrays (points and triangles) for spatial propagation schemes.
!
!  2. Method :
!     
!  3. Parameters :
!
!  4. Subroutines used :
!
!  5. Called by :
!
!       Name      Type  Module   Description
!     ----------------------------------------------------------------
!      READTRI    Subr. Internal  Unstructured mesh definition.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!      
!     The storage is optimize especially considering the iterative solver used.
!     The schemes used are vertex-centered, a point has to be considered within its
!     median dual cell. For a given point, the surface of the dual cell is one third
!     of the sum of the surface of connected triangles. 
!     This routine is from WWM developped in Darmstadt(Aaron Roland) 
!     
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /      

        USE W3GDATMD

         IMPLICIT NONE
!/ input 

         INTEGER, INTENT(IN) :: IMOD 

!/ local parameters   

         INTEGER :: COUNTER,ifound,alreadyfound
         INTEGER :: I, J, K
         INTEGER :: IP, IE, POS, POS_I, POS_J, POS_K, IP_I, IP_J, IP_K
         INTEGER :: I1, I2, I3, IP2
         INTEGER :: TMP(NX), CELLVERTEX(NX,COUNTRI,2)
         INTEGER :: COUNT_MAX
         INTEGER, ALLOCATABLE :: PTABLE(:,:)
!/S        INTEGER                      ::  IENT = 0  	
!/ ------------------------------------------------------------------- /      

!/S      CALL STRACE (IENT, 'AREA_SI')
         
         SI(:) = 0.
!
! calculate the number of triangle connected to a point and reckon the surface of a dual cell
! Ask Aron: Should be uptated with water levels ???         
!
         DO IP = 1, NX
           COUNTER = 0
           DO IE = 1, NTRI  
             IF (IP == TRIGP(IE,1) .OR. IP == TRIGP(IE,2) .OR. IP== TRIGP(IE,3)) THEN
               COUNTER = COUNTER + 1
               CCON(IP) = COUNTER
               SI(IP) = SI(IP) +  1./3. * TRIA(IE) 
               END IF
             END DO
           END DO 
              
         CELLVERTEX(:,:,:) = 0
         VNEIGH(:,:) = 0
!
          DO IP = 1, NX
            COUNTER = 0
            ifound = 0
 !
 ! first step of the storage, for a given vertex, the triangle it belongs to and the vertex position
 ! are stored  
 !
            DO IE = 1, NTRI
              IF (IP == TRIGP(IE,1)) THEN
                COUNTER = COUNTER + 1
                CELLVERTEX(IP,COUNTER,1) = IE
                CELLVERTEX(IP,COUNTER,2) = 1
                DO IP2=2,3
                  alreadyfound = 0
                  DO I=1,ifound
                    IF (VNEIGH(IP,I).EQ.TRIGP(IE,IP2)) alreadyfound=alreadyfound+1
                    END DO
                  IF (alreadyfound.EQ.0) THEN 
                    ifound=ifound+1
                    VNEIGH(IP,ifound)=TRIGP(IE,IP2)
                    END IF
                  END DO
               END IF
              
             IF (IP == TRIGP(IE,2)) THEN
               COUNTER = COUNTER + 1
               CELLVERTEX(IP,COUNTER,1) = IE
               CELLVERTEX(IP,COUNTER,2) = 2
                DO IP2=3,4
                  alreadyfound = 0
                  DO I=1,ifound
                    IF (VNEIGH(IP,I).EQ.TRIGP(IE,MOD(IP2-1,3)+1)) alreadyfound=alreadyfound+1
                    END DO
                  IF (alreadyfound.EQ.0) THEN 
                    ifound=ifound+1
                    VNEIGH(IP,ifound)=TRIGP(IE,MOD(IP2-1,3)+1)
                    END IF
                  END DO
                END IF
              
             IF (IP == TRIGP(IE,3)) THEN
               COUNTER = COUNTER + 1
               CELLVERTEX(IP,COUNTER,1) = IE
               CELLVERTEX(IP,COUNTER,2) = 3
                DO IP2=1,2
                  alreadyfound = 0
                  DO I=1,ifound
                    IF (VNEIGH(IP,I).EQ.TRIGP(IE,IP2)) alreadyfound=alreadyfound+1
                    END DO
                  IF (alreadyfound.EQ.0) THEN 
                    ifound=ifound+1
                    VNEIGH(IP,ifound)=TRIGP(IE,IP2)
                    END IF
                  END DO
                END IF
             END DO
!
! COUNTCON is a counter on connected points. In comparison with the number of connected triangle
! CCON, it will enable to spot whether a point belong to the contour
!         
           COUNTCON(IP)=ifound
          
           do I=2,ifound
              do J=1,i-1
              if (VNEIGH(IP,J).EQ. VNEIGH(IP,I)) THEN 
                 COUNTCON(IP)=COUNTCON(IP)-1
                 WRITE(993,*) 'ERROR:',IP,I,J,VNEIGH(IP,J),VNEIGH(IP,I)
                 END IF
              enddo
           enddo
          
         END DO
          
         J = 0
!
! Second step in storage, the initial 3D array CELLVERTEX, is transformed in a 1D array
! the global index is J . From now, all the computation step based on these arrays must
! abide by the conservation of the 2 loop algorithm (points + connected triangles)
! AR: I will change this now to pointers in order to omit fix loop structure for the LTS stuff ...
!	   
         INDEX_CELL(1)=1
         DO IP = 1, NX
           DO I = 1, CCON(IP)
             J = J + 1
             IE_CELL(J)  = CELLVERTEX(IP,I,1)
             POS_CELL(J) = CELLVERTEX(IP,I,2) 
           END DO
           INDEX_CELL(IP+1)=J+1
         END DO

         J = 0
         DO IP = 1, NX 
           DO I = 1, CCON(IP)
             J = J + 1
           END DO
         END DO

         COUNT_MAX = J

           ALLOCATE(PTABLE(COUNT_MAX,7))

           J = 0
           PTABLE(:,:) = 0.
           DO IP = 1, NX 
             DO I = 1, CCON(IP)
               J = J + 1
               IE    = IE_CELL(J)
               POS   = POS_CELL(J)
               I1 = TRIGP(IE,1)
               I2 = TRIGP(IE,2)
               I3 = TRIGP(IE,3)
               IF (POS == 1) THEN
                 POS_J = 2
                 POS_K = 3
               ELSE IF (POS == 2) THEN
                 POS_J = 3
                 POS_K = 1
               ELSE
                 POS_J = 1
                 POS_K = 2
               END IF
               IP_I = IP
               IP_J = TRIGP(IE,POS_J)
               IP_K = TRIGP(IE,POS_K)
               PTABLE(J,1) = IP_I
               PTABLE(J,2) = IP_J
               PTABLE(J,3) = IP_K
               PTABLE(J,4) = POS
               PTABLE(J,5) = POS_J
               PTABLE(J,6) = POS_K
               PTABLE(J,7) = IE
             END DO
           END DO

!           WRITE(*,'("+TRACE......",A)') 'SET UP SPARSE MATRIX POINTER ... COUNT NONZERO ENTRY'

           J = 0
           K = 0
           DO IP = 1, NX 
             TMP(:) = 0
             DO I = 1, CCON(IP)
               J = J + 1
               IP_J  = PTABLE(J,2)
               IP_K  = PTABLE(J,3)
               POS   = PTABLE(J,4)
               TMP(IP)   = 1
               TMP(IP_J) = 1
               TMP(IP_K) = 1
            END DO
            K = K + SUM(TMP)
          END DO

          NNZ => GRIDS(IMOD)%NNZ

          NNZ = K

!          WRITE(*,'("+TRACE......",A)') 'SET UP SPARSE MATRIX POINTER ... SETUP POINTER'

          ALLOCATE (GRIDS(IMOD)%JAA(NNZ))
          ALLOCATE (GRIDS(IMOD)%IAA(NX+1))
          ALLOCATE (GRIDS(IMOD)%POSI(3,COUNT_MAX))
          JAA   => GRIDS(IMOD)%JAA
          IAA   => GRIDS(IMOD)%IAA
          POSI  => GRIDS(IMOD)%POSI

           J = 0
           K = 0
           IAA(1) = 1
           JAA    = 0
           DO IP = 1, NX ! Run through all rows 
             TMP(:)=0
             DO I = 1, CCON(IP)         ! Check how many entries there are ...
               J = J + 1                ! this is the same J index as in IE_CELL
               IP_J  = PTABLE(J,2)
               IP_K  = PTABLE(J,3)
               TMP(IP)   = 1
               TMP(IP_J) = 1
               TMP(IP_K) = 1
             END DO
             DO I = 1, NX               ! Run through all columns 
               IF (TMP(I) .GT. 0) THEN  ! this is true only for the connected points
                 K = K + 1              
                 JAA(K) = I
               END IF
             END DO
             IAA(IP + 1) = K + 1    
           END DO

           POSI = 0
           J = 0
           DO IP = 1, NX  
             DO I = 1, CCON(IP)
               J = J + 1
               IP_J  = PTABLE(J,2)
               IP_K  = PTABLE(J,3)
               DO K = IAA(IP), IAA(IP+1) - 1
                 IF (IP   == JAA(K)) POSI(1,J)  = K
                 IF (IP_J == JAA(K)) POSI(2,J)  = K
                 IF (IP_K == JAA(K)) POSI(3,J)  = K
                 IF (K == 0) THEN
                  WRITE(*,*) 'ERROR IN AREA_SI K .EQ. 0'
                  STOP
                 END IF
               END DO
            END DO
          END DO

          DEALLOCATE(PTABLE)

       END SUBROUTINE   
       
!/ ------------------------------------------------------------------- /  

     SUBROUTINE INTERPOLATION(IPT, XPT, YPT, FACT, itout, alphaa, beta)

!/ ------------------------------------------------------------------- 
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           F. Ardhuin              |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          15-May-2008|
!/                  +-----------------------------------+
!/
!/    15-Oct-2007 : Origination.                        ( version 3.13 )
!/
!  1. Purpose :
!
!      Calculate interpolation coefficient for fields on the unstructured grid.
!
!  2. Method :
!      
!     Using barycentric coordinates. Each coefficient depends on the mass of its related point in the interpolation.
!
!  3. Parameters :
!
!  4. Subroutines used :
!
!  5. Called by :
!
!       Name      Type  Module   Description
!     ----------------------------------------------------------------
!      W3IOPP    Subr. Internal  Preprocessing of point output.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!     
!      This subroutine is adjusted from CREST code (Fabrice Ardhuin)
!      For a given output point, the algorithm enable to glance through all the triangles 
!      to find the one the point belong to, and then make interpolation.
!
!  8. Structure :
!
!  9. Switches :
!
!       !/LLG   Spherical grid.
!       !/XYG   Carthesian grid.
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /       
 
           USE W3GDATMD, ONLY : TRIGP, NTRI, XYB, MAPSTA
           USE W3SERVMD, ONLY: EXTCDE
!/S          USE W3SERVMD, ONLY: STRACE
          USE W3ODATMD, ONLY: NDSE       
      IMPLICIT NONE
 
!/ ------------------------------------------------------------------- /       
 ! Parameter list
 
           INTEGER, INTENT(IN)            :: IPT
           REAL   , INTENT(IN)            :: XPT(:), YPT(:),FACT
           INTEGER, INTENT(OUT)           :: itout
           REAL   , INTENT(OUT)           :: alphaa, beta
 !/ ------------------------------------------------------------------- /                 
 !local parameters
 
           DOUBLE PRECISION             :: x1, x2, x3, xg, x
           DOUBLE PRECISION             :: y1, y2, y3, yg, y
           DOUBLE PRECISION             :: xx1, xx2, xx3, xx
           DOUBLE PRECISION             :: yy1, yy2, yy3, yy
           DOUBLE PRECISION             :: d1, d2, d3
           DOUBLE PRECISION             :: dM1, dM2, dM3
           DOUBLE PRECISION             :: scale1, scale2, scale3
           DOUBLE PRECISION             :: sg1, sg2, sg3
           DOUBLE PRECISION             :: s1, s2, s3
           DOUBLE PRECISION             :: delta 
           INTEGER                      :: ITRI, I, J, K
!/S        INTEGER                      ::  IENT = 0
!/S      CALL STRACE (IENT, 'INTERPOLATION')

!
         itout = 0 
!
! coordinates of the output point 	    
!
            x=DBLE(XPT(IPT)) 
            y=DBLE(YPT(IPT))
            DO ITRI= 1, NTRI
! coordinates of the first vertex A	    
              x1=XYB(TRIGP(ITRI,1),1) 
              y1=XYB(TRIGP(ITRI,1),2)
! coordinates of the 2nd vertex B 
              x2=XYB(TRIGP(ITRI,2),1)          
              y2=XYB(TRIGP(ITRI,2),2)
!coordinates of the 3rd vertex C	    
              x3=XYB(TRIGP(ITRI,3),1)          
              y3=XYB(TRIGP(ITRI,3),2)
! coordinates of center of gravity G     
              xg=(x1+x2+x3)/3.                
              yg=(y1+y2+y3)/3.
!length of edges	    
              d1=sqrt((y2-y3)**2+(x2-x3)**2)
              d2=sqrt((y3-y1)**2+(x3-x1)**2)
              d3=sqrt((y2-y1)**2+(x2-x1)**2)
!evaluate length between the vertices and the output point	    
              dM1=sqrt((y-y1)**2+(x-x1)**2)
              dM2=sqrt((y-y2)**2+(x-x2)**2)
              dM3=sqrt((y-y3)**2+(x-x3)**2)
!	    
              IF (dM1 > dM2) THEN 
!vector product of AB and AG
                sg1=(yg-y1)*(x2-x1)-(xg-x1)*(y2-y1)
!vector product of AB and AM   
                s1=(y-y1)*(x2-x1)-(x-x1)*(y2-y1)       
                scale1=d3*dM1
              ELSE
!vector product of BA and BG	    
                sg1=(yg-y2)*(x1-x2)-(xg-x2)*(y1-y2)  
!vector product of BA and BM	         
                s1=(y-y2)*(x1-x2)-(x-x2)*(y1-y2)       
                scale1=d3*dM2
                END IF
              IF (dM2 > dM3) THEN 
!vector product of BC and BG	    
                sg2=(yg-y2)*(x3-x2)-(xg-x2)*(y3-y2)    
!vector product of BC and BM     
                s2=(y-y2)*(x3-x2)-(x-x2)*(y3-y2)       
                scale2=d1*dM2
              ELSE
!vector product of CB and CG        
                sg2=(yg-y3)*(x2-x3)-(xg-x3)*(y2-y3)    
!vector product of CB and CM     
                s2=(y-y3)*(x2-x3)-(x-x3)*(y2-y3)       
                scale2=d1*dM3
                END IF
              IF (dM3 > dM1) THEN 
!vector product of CA and CG	    
                sg3=(yg-y3)*(x1-x3)-(xg-x3)*(y1-y3)    
!vector product of CA and CM	       
                s3=(y-y3)*(x1-x3)-(x-x3)*(y1-y3)       
                scale3=d2*dM3
              ELSE
!vector product of AC and AG	    
                sg3=(yg-y1)*(x3-x1)-(xg-x1)*(y3-y1)    
!vector product of AC and AM	       
                s3=(y-y1)*(x3-x1)-(x-x1)*(y3-y1)       
                scale3=d2*dM1
                END IF
            
! test if the point is within the triangle	    
            IF ((s1*sg1.GE.0).AND.(s2*sg2.GE.0).AND.(s3*sg3.GE.0)) itout=ITRI
            ENDDO
!PRINT*,ITOUT 
!PRINT*, TRIGP(ITOUT,1), MAPSTA(1,TRIGP(ITOUT,1))
!PRINT*, TRIGP(ITOUT,2), MAPSTA(1,TRIGP(ITOUT,2))
!PRINT*, TRIGP(ITOUT,3), MAPSTA(1,TRIGP(ITOUT,3))
! Second step: calculate interpolation coefficient from the vertices.
      IF(ITOUT .EQ. 0)  THEN 
         WRITE(NDSE, 800 )   XPT, YPT
  CALL EXTCDE( 1 )
  ELSE  
            xx1=XYB(TRIGP(itout,1),1)*FACT
            yy1=XYB(TRIGP(itout,1),2)*FACT
            xx2=XYB(TRIGP(itout,2),1)*FACT
            yy2=XYB(TRIGP(itout,2),2)*FACT
            xx3=XYB(TRIGP(itout,3),1)*FACT
            yy3=XYB(TRIGP(itout,3),2)*FACT
            xx=x*FACT
     yy=y*FACT
     
      delta=((xx1-xx3)*(yy3-yy2)-(xx3-xx2)*(yy1-yy3))
    
      IF (delta.EQ.0) THEN 
          WRITE (NDSE,900) 
          CALL EXTCDE ( 2 )
      ELSE
         alphaa = ((xx-xx3)*(yy3-yy2)+(yy3-yy)*(xx3-xx2))/delta
         beta  = ((xx3-xx)*(yy3-yy1)-(xx3-xx1)*(yy3-yy))/delta
      ENDIF
     ENDIF
!
! Formats
!
  800 FORMAT (/' *** WAVEWATCH III ERROR IN INTERPOLATION :'/                &
               '     NO TRIANGLE FOUND FOR OUTPUT POINT    '/                &
               '     CHECK THE OUTPUT POINT COORDINATES :  ',2F12.6)
  900 FORMAT (/' *** WAVEWATCH III ERROR IN INTERPOLATION :'/                &
               '     FLAT TRIANGLE FOUND ')
      RETURN

END SUBROUTINE
!/ ------------------------------------------------------------------- / 
      SUBROUTINE UG_GRADIENTS (PARAM, DIFFX, DIFFY)
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           F. Ardhuin              |
!/                  |                        FORTRAN 90 |
!/                  | Last update :          08-Nov-2011|
!/                  +-----------------------------------+
!/
!/    15-Nov-2007 : Origination.                        ( version 3.13 )
!/    31-Oct-2010 : Merging of 4.03 with 3.14-Ifremer   ( version 4.04 )
!/    08-Nov-2011 : Correction for zero grad. on contour( version 4.04 )
!/      
!
!  1. purpose: calculate gradients at a point via its connection.
!  2. Method : using 3D plan definition and angular redistribution
!      
!    
!
!  3. Parameters :
!     PARAM : depth or current field (indices 0 to NSEA) 
!     DIFFX :  x gradient            (indices 1 to NX)
!     DIFFY :  y gradient            (indices 1 to NX)
!
!  4. Subroutines used :
!
!  5. Called by :
!
!       Name      Type  Module   Description
!     ----------------------------------------------------------------
!      W3WAVE    Subr.          Actual wind wave routine
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!     
!      This subroutine is adjusted from WWM code (Aaron Roland)

!
!  8. Structure :
!
!  9. Switches :
!
! 10. Source code :     
      USE CONSTANTS
      USE W3GDATMD, ONLY : CROSSDIFF, TRIGP, NTRI, NX, NSEA, MAPFS, CLATIS, &
                           MAPSTA, ANGLE, FLAGLL,  IOBP
      IMPLICIT NONE     
      
      
      REAL, INTENT(IN)     :: PARAM(0:NSEA)
      REAL, INTENT(OUT)    :: DIFFX(:,:), DIFFY(:,:)
 
! local parameters      
      
      INTEGER              :: VERTICES(3)
      INTEGER              :: COUNTER(NX)
      REAL                 :: TMP1(3), TMP2(3)
      INTEGER              :: I, IX
      REAL                 :: VAR(3), FACT, LAT(3)
      REAL                 :: DIFFXTMP, DIFFYTMP
      
       
!initialisation step      
      COUNTER(:) = 0.
      DIFFX(:,:) = 0.              
      DIFFY(:,:) = 0. 
!
     IF (FLAGLL) THEN 
       FACT=1./(DERA*RADIUS)
     ELSE
       FACT=1.
       END IF
     DO I = 1, NTRI
       VERTICES(1) = TRIGP(I,1)
       VERTICES(2) = TRIGP(I,2)
       VERTICES(3) = TRIGP(I,3)
!
!   CLATIS is 1/COS(latitute) 
! 
       LAT(1)=CLATIS(MAPFS(1,VERTICES(1)))
       LAT(2)=CLATIS(MAPFS(1,VERTICES(2)))
       LAT(3)=CLATIS(MAPFS(1,VERTICES(2)))
      

       VAR(1) = PARAM(MAPFS(1,VERTICES(1)))* FACT*LAT(1)
       VAR(2) = PARAM(MAPFS(1,VERTICES(2)))* FACT*LAT(2)
       VAR(3) = PARAM(MAPFS(1,VERTICES(3)))* FACT*LAT(3)
     
       TMP1(:)  = CROSSDIFF(1:3, I)
       TMP2(:)  = CROSSDIFF(4:6, I)

       DIFFXTMP = DOT_PRODUCT(VAR(:),TMP1(:))
       DIFFYTMP = DOT_PRODUCT(VAR(:),TMP2(:))

! calculate global gradients via all the connection contributions.
       DIFFX(1,VERTICES(:)) = DIFFX(1,VERTICES(:)) + DIFFXTMP * ANGLE(I,:)
       DIFFY(1,VERTICES(:)) = DIFFY(1,VERTICES(:)) + DIFFYTMP * ANGLE(I,:) 
       END DO

! restore 0 on the contour 
       DO IX = 1,NX
         IF (IOBP(IX).EQ. 0 ) THEN
           DIFFX(1,IX)  =  0.     
           DIFFY(1,IX)  =  0.
           END IF
         END DO 
!
    END SUBROUTINE UG_GRADIENTS
!/ ------------------------------------------------------------------- /    
    SUBROUTINE W3NESTUG(DISTMIN,FLOK)
    USE W3ODATMD, ONLY: NBI, NDSE, ISBPI, XBPI, YBPI
    USE W3GDATMD, ONLY: NX, XYB, XGRD, YGRD, MAPSTA, MAPFS, MAPSF


    REAL, INTENT(IN)         :: DISTMIN
    LOGICAL, INTENT(INOUT)         :: FLOK

    INTEGER                   :: I, J, JMEMO, IS, IX,  N, IX1(NBI)
    REAL                      :: DIST, DIST0
!
    N = 0 
!
!1. look for input boundary point index
! warning: if land points are included as boundary points to abide by the nest
! file, their status should be -2.
!
    IX1 = 0
    ISBPI = 1
    DO IX = 1, NX
      IF (ABS(MAPSTA (1,IX)) .EQ. 2) THEN
        N = N + 1 
        IX1(N) = IX
!/T        WRITE(NDSE ,*)'ADDING BOUNDARY POINT:',N,IX
        END IF
      END DO
!
!2. Matches the model grid points (where MAPSTA = 2) with the points in nest.ww3
!   For this, we use the nearest point in the nest file.
!
    DO I = 1, NBI 
!FA: This will not work with FLAGLL=.F.  (XY grid)
      DIST0 = 360**2
      IS=1
      DO J = 1, N
        DIST=(XBPI(I)-XYB(IX1(J),1))**2+(YBPI(I)-XYB(IX1(J),2))**2
        IF (DIST.LT.DIST0) THEN 
          IS = MAPFS(1,IX1(J))
          DIST0=DIST
          JMEMO=J
          END IF
        END DO
      DIST0=SQRT(DIST0)
      IF (DIST0.LE.DISTMIN) THEN          
        ISBPI(I)=IS
!/T        WRITE(NDSE ,'(A,I6,A,I7,A,I6)') 'MATCHED BOUNDARY POINT:',I,'GRID POINT:', &
!/T                                         MAPSF(IS,1),'INDEX IN nest.ww3:', JMEMO
     ELSE
        FLOK=.TRUE.
        END IF
      END DO  
    IF ( N .NE. NBI) THEN 
      WRITE(NDSE ,900) N, NBI
      DO J=1,N
        WRITE(6,*) 'THIS POINT HAS MAPSTA=2:',ISBPI(J)  
        END DO
      ISBPI(N+1:NBI)=ISBPI(1)
      END IF
      
900 FORMAT (/' *** WAVEWATCH III ERROR IN W3IOBC : '/                &
             '     NUMBER OF MAPSTA=2 DIFFERS FROM NUMBER IN nest.ww3    '/                &
             '     CHECK nest.ww3 AND ww3_grid.inp ',2I8/)
END SUBROUTINE

!/ ------------------------------------------------------------------- /
   SUBROUTINE SETUGIOBP ( )    
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |        Fabrice Ardhuin            |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         23-Aug-2011 |
!/                  +-----------------------------------+
!/
!/    23-Aug-2011 : Origination.                        ( version 4.04 )
!/
!  1. Purpose :
!
!     Redefines the values of the boundary points and angle pointers
!     based on the MAPSTA array
!
!  2. Method :
!
!     
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!     ----------------------------------------------------------------
!
!     Local variables.
!     ----------------------------------------------------------------
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!

!  5. Called by :
!
!       WW3_GRID
!       W3UPTD??   forcing field update
!
!  6. Error messages :
!
!       None.
!
!  7. Remarks :
!
!  8. Structure :
!
!
!  9. Switches :
!
!       !/S     Enable subroutine tracing.
!
!
! 10. Source code :     
!/ ------------------------------------------------------------------- /
!/
!
      USE CONSTANTS
!
!
      USE W3GDATMD, ONLY: NX, NY, NSEA, MAPSF, MAPFS, DTCFL,          &
                          NK, NTH, DTH, XFR, MAPSTA, COUNTRI,         &
                          ECOS, ESIN, SIG,  PFMOVE,IEN, COUNTOT,      &
                          NTRI, TRIGP, CCON , TRIA03, VNEIGH,         &
                          IE_CELL, POS_CELL, IOBP,IOBPD, XYB, TH,     &
                          ANGLE0, ANGLE, REFPARS, REFLC, REFLD

      USE W3ODATMD, ONLY: TBPI0, TBPIN, FLBPI
      USE W3ADATMD, ONLY: CG, CX, CY, ATRNX, ATRNY, ITIME, CFLXYMAX
      USE W3IDATMD, ONLY: FLCUR
!      USE W3ODATMD, ONLY: NDSE, NDST, FLBPI, NBI, TBPI0, TBPIN,       &
!                          ISBPI, BBPI0, BBPIN
!/S      USE W3SERVMD, ONLY: STRACE
      
      IMPLICIT NONE
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      LOGICAL                 :: REDO_ANGLE
      INTEGER                 :: ITH, IK, ISEA, IXY, IBI, FOUND    
      INTEGER                 :: IX, IY, I, J, IP, IP0, IP2, IPB, IE
      REAL                    :: CCOS, CSIN, CCURX, CCURY, THTEST 
      REAL (KIND = 8)         :: DIRMIN, DIRMAX, SHIFT, TEMPO, DIRCOAST, &
                                 DIRCOAST1, DIRCOAST2, SUMCOS1, SUMCOS2, DIRDIFF
      INTEGER                 :: SEANEIGHP(NX,15,2)
      REAL                    :: C(NX,2)
      REAL                    :: RD1, RD2
      REAL (KIND = 8)         :: X1, X2, X3, Y1, Y2, Y3
      INTEGER                 :: SEACCON(NX), SEANEIGH(NX), SEA_CELL(COUNTOT)
      INTEGER                 ::  COUNT_MAX
      INTEGER                 :: K, K2, I1, I2, I3
      INTEGER                 :: TRILAND(NTRI)
      REAL                    :: ANGLETOT(NX), ANGLETOTINV(NX)

!/
!/ Automatic work arrays
!/
      REAL                    :: VLCFLX((NX+1)*NY), VLCFLY(NX*NY)
      REAL                    ::  AQ(NX)                        
      ! AQ(1-NY:NY*(NX+2)) 
      REAL                    :: AC(NX)
!/ ------------------------------------------------------------------- /				     
!
! 1.  Preparations --------------------------------------------------- *
! 1.a Set constants
!      
      
!/S      CALL STRACE (IENT, 'SETUGIOBP')      
!
! Counts the number of wet neighbor nodes
!
        SEANEIGH(1:NX)=0
        SEA_CELL(:)=0
        J = 0
        DO IX = 1, NX
          DO I = 1, 2*COUNTRI
            IF (VNEIGH(IX,I).NE.0) THEN 
              IF (MAPSTA(1,VNEIGH(IX,I)).GT.0) SEANEIGH(IX)=SEANEIGH(IX)+1  ! Loop over all connected points
              !WRITE(995,*) 'TEST BOUNDARY 1:',IX,VNEIGH(IX,I),SEANEIGH(IX),CCON(IX)
              END IF 
            END DO         
          END DO
!
! Counts the number of wet neighbor triangles
!
        SEACCON(1:NX)=0
        SEANEIGHP(:,:,:)=0
        J = 0
        DO IX = 1, NX
          DO I = 1, CCON(IX)                  ! Loop over all connected Elements
             J = J + 1
             IE    = IE_CELL(J)                ! Connected Element Number
             IF (MAPSTA(1,TRIGP(IE,1)).GT.0.AND. &
                 MAPSTA(1,TRIGP(IE,2)).GT.0.AND. &
                 MAPSTA(1,TRIGP(IE,3)).GT.0) THEN 
               SEACCON(IX)=SEACCON(IX)+1
               SEA_CELL(J)=1
               END IF
!
! Used for refraction ... 
!
             DO K2=1,3      
               FOUND=0         
               DO K=1,SEANEIGHP(IX,1,1)
                  IF (SEANEIGHP(IX,K+1,1).EQ.TRIGP(IE,K2)) THEN 
                    SEANEIGHP(IX,K+1,2)=SEANEIGHP(IX,K+1,2)+1
                    FOUND=1
                    END IF
                  END DO
                IF (FOUND.EQ.0) THEN
                  SEANEIGHP(IX,1,1)=SEANEIGHP(IX,1,1)+1
                  K=SEANEIGHP(IX,1,1)
             !    IF (K.GT.13) WRITE(6,*) 'SEANEIGHP :',IX,K,K2,TRIGP(IE,K2)
                  SEANEIGHP(IX,K+1,1)=TRIGP(IE,K2)
                  SEANEIGHP(IX,K+1,2)=1
                  END IF
                END DO
             END DO         
          END DO
! 

        IOBP(:)=1
        IOBPD(:,:)=1
!
! Searches for boundary points
! 
!/REF1            REFLC(1,:)= 0.
!/REF1            REFLD(:,:)= 0
!
        DO IX = 1, NX
          IF (MAPSTA(1,IX).LE.0) THEN 
            IOBP(IX)=0
            IOBPD(:,IX)=0
            END IF
          IF (SEACCON(IX) .LT. SEANEIGH(IX).AND.MAPSTA(1,IX).NE.2) THEN 
            IOBP(IX)=0
!/REF1            REFLC(1,MAPFS(1,IX))= REFPARS(1)
          !  WRITE(995,*) '@@@@ TRUE BOUNDARY:',IX,IOBP(IX),MAPSTA(1,IX),SEACCON(IX),SEANEIGH(IX),CCON(IX)
          !ELSE
          !  WRITE(995,*) '       NO BOUNDARY:',IX,IOBP(IX),MAPSTA(1,IX),SEACCON(IX),SEANEIGH(IX),CCON(IX)
            END IF    
          END DO     
!
! Now looks for excluded angles
!
        J = 0
        DO IX = 1, NX
          DIRCOAST1=-999.
          DIRCOAST2=-999.
          IF (IOBP(IX).EQ.0) IOBPD(:,IX)=0
          DO I = 1, CCON(IX)                  ! Loop over all connected Elements
            J = J + 1
            IF ((IOBP(IX).EQ.0).AND.(SEA_CELL(J).EQ.1)) THEN 
              IE    = IE_CELL(J)                ! Connected Element Number
              IP0 = POS_CELL(J)
              IP=MOD(IP0,3)+1
              IPB=MOD(IP0+1,3)+1
!
!  We are now dealing with an excluded point that is a neighbor of a boundary point
!
              X1=DBLE(XYB(TRIGP(IE,IP0),1))
              Y1=DBLE(XYB(TRIGP(IE,IP0),2))
              X2=DBLE(XYB(TRIGP(IE,IP ),1))
              Y2=DBLE(XYB(TRIGP(IE,IP ),2))
              X3=DBLE(XYB(TRIGP(IE,IPB),1))
              Y3=DBLE(XYB(TRIGP(IE,IPB),2))
 
              CALL line_angle( x2, y2, x1, y1, DIRMIN )
              CALL line_angle( x3, y3, x1, y1, DIRMAX )
                IF (DIRMAX.LT.DIRMIN) CALL d_swap(DIRMIN,DIRMAX)
                SHIFT=0
                IF (ABS(DIRMAX-DIRMIN).GT.PI) THEN 
                  TEMPO=DIRMAX
                  DIRMAX=DIRMIN+DBLE(PI)
                  DIRMIN=TEMPO-DBLE(PI)
                  SHIFT=PI
                  END IF
                DO ITH=1, NTH
                  THTEST=MOD(TH(ITH)+SHIFT,DBLE(TPI))
                  IF ((THTEST.GE.DIRMIN) .AND.   &
                     (THTEST.LE.DIRMAX)) THEN
                    IOBPD(ITH,IX) = 1
                    !WRITE(995,*) 'IOBPD OUT:',IX,IE,ITH,IOBP(IX),TH(ITH)*RADE,DIRMIN*RADE,DIRMAX*RADE
                    END IF
                  END DO 
                END IF
              END DO       !  I = 1, CCON(IX) 
            END DO

!/REF1 ! 
!/REF1 ! Finds the shoreline direction 
!/REF1 !
!/REF1          DO IX = 1, NX
!/REF1            FOUND=0
!/REF1            DO K=1,SEANEIGHP(IX,1,1)
!/REF1              IF (SEANEIGHP(IX,K+1,2).EQ.1) THEN 
!/REF1                IF (FOUND.EQ.0) THEN 
!/REF1                  IP=SEANEIGHP(IX,K+1,1)
!/REF1                  FOUND=FOUND+1
!/REF1                ELSE 
!/REF1                  IPB=SEANEIGHP(IX,K+1,1)
!/REF1                  END IF
!/REF1                END IF
!/REF1              END DO
!/REF1            IF (FOUND.GT.2) WRITE(6,*) 'WARNING: POINT ',IX,'HAS MORE THAN 2 CONNECTED SHORELINE SEGMENTS.'
!/REF1            X1=DBLE(XYB(IX,1))
!/REF1            Y1=DBLE(XYB(IX,2))
!/REF1            X2=DBLE(XYB(IP,1))
!/REF1            Y2=DBLE(XYB(IP,2))
!/REF1            X3=DBLE(XYB(IPB,1))
!/REF1            Y3=DBLE(XYB(IPB,2))
 
!/REF1            CALL line_angle( x2, y2, x1, y1, DIRCOAST1 )
!/REF1            CALL line_angle( x3, y3, x1, y1, DIRCOAST2 )
!
!/REF1             SUMCOS1=0. 
!/REF1             SUMCOS2=0. 
!/REF1             DIRCOAST=0.5*(DIRCOAST1+DIRCOAST2)

!/REF1             DO ITH=1, NTH
!/REF1               IF (IOBPD(ITH,IX).EQ.0) THEN 
!/REF1                 SUMCOS1=SUMCOS1+COS(DIRCOAST-TH(ITH))
!/REF1                 SUMCOS2=SUMCOS2+COS(DIRCOAST+PI-TH(ITH))
!/REF1        !        WRITE(995,*) 'DIR COAST:',IX,ITH,SUMCOS1, SUMCOS2, DIRCOAST
!/REF1                 END IF
!/REF1               END DO
!/REF1 ! Keep the direction DIRCOAST if SUMCOS1 > SUMCOS2, otherwise adds PI
!/REF1             IF (SUMCOS1.GT.SUMCOS2) DIRCOAST=DIRCOAST+PI
!/REF1 ! NOTE: because the reflection was first implemented on regular grids, shoreline dirs. were discretized
!/REF1 ! NOTE: Now, this is a pity not to use the full resolution of directions for triangle-based meshes
!/REF1               REFLD(1,MAPFS(1,IX)) = 1+MOD(NINT(DIRCOAST/DTH),NTH)
!/REF1               DIRDIFF=ABS(DIRCOAST1-DIRCOAST)
!/REF1               IF (DIRDIFF.GT.PI) DIRDIFF=ABS(DIRDIFF-TPI)
!/REF1               REFLD(2,MAPFS(1,IX)) = 4-MAX(2,NINT(DIRDIFF/(0.25*PI)))
!/REF1               !These X and Y lengths of boundary are not used now... 
!/REF1               !UG_BOUNDL(1,IX) = ABS(X3-X2)*0.5* DERA * RADIUS
!/REF1               !UG_BOUNDL(2,IX) = ABS(Y3-Y2)*0.5* DERA * RADIUS
!/REF1               !WRITE(995,'(A,3I8,4F6.1,2I4,2F10.1)') 'DIR COAST:',IX,IP,IPB,DIRCOAST*RADE,DIRCOAST1*RADE,  &
!/REF1               !         DIRCOAST2*RADE, DIRDIFF*RADE, REFLD(1:2,MAPFS(1,IX))  !, UG_BOUNDL(1:2,IX)
!/REF1          END DO
!
! Recomputes the angles used in the gradients estimation 
!
!REDO_ANGLE = 1
!      IF (REDO_ANGLE) THEN 
!
! MAP FOR LAND POINTS    
! 
       TRILAND(:) = 0
       K = 0
       DO IE = 1, NTRI
         I1 = TRIGP(IE,1)
         I2 = TRIGP(IE,2)
         I3 = TRIGP(IE,3)
!
!! MAP FOR TRIANGLE STATUS: 
!     TRILAND=0     ->sea triangle
!     TRILAND=1 , 2 -> contour
!     TRILAND=3     -> land

     
          IF ((MAPSTA(1,I1).LE.0))  TRILAND(IE) = TRILAND(IE) + 1
          IF ((MAPSTA(1,I2).LE.0))  TRILAND(IE) = TRILAND(IE) + 1
          IF ((MAPSTA(1,I3).LE.0))  TRILAND(IE) = TRILAND(IE) + 1
          END DO
!
! Now calculate the angle of action of a vertex (see gradients in w3updtmd.ftn)
! If a triangle is connected to the contour, the angle of each vertex is not
! taken into account when interpolating gradients.
!
        ANGLETOT(:) = 0. ! TPI
        DO IE = 1, NTRI 
          TRILAND(IE)=MIN(TRILAND(IE),1)
          I1 = TRIGP(IE,1)
          I2 = TRIGP(IE,2)
          I3 = TRIGP(IE,3) 
          IF (TRILAND(IE) .EQ. 0) THEN  
            ANGLETOT(I1) = ANGLETOT(I1) + ANGLE0(IE,1)
            ANGLETOT(I2) = ANGLETOT(I2) + ANGLE0(IE,2)
            ANGLETOT(I3) = ANGLETOT(I3) + ANGLE0(IE,3)
            END IF
          END DO

      DO IP = 1, NX
        IF (ANGLETOT(IP) .NE. 0)  THEN 
           ANGLETOTINV(IP) = 1./ANGLETOT(IP)
        ELSE 
          ANGLETOTINV(IP) = 0.
          END IF
        END DO
!
      DO IE = 1, NTRI
        I1 = TRIGP(IE,1)
        I2 = TRIGP(IE,2)
        I3 = TRIGP(IE,3) 
!
! Angles for land triangles are set to zero
!
        ANGLE(IE,1) = ANGLE0(IE,1)*ANGLETOTINV(I1)*(1-TRILAND(IE))
        ANGLE(IE,2) = ANGLE0(IE,2)*ANGLETOTINV(I2)*(1-TRILAND(IE))
        ANGLE(IE,3) = ANGLE0(IE,3)*ANGLETOTINV(I3)*(1-TRILAND(IE))
        !WRITE(998,*) 'IE, ANGLE:',IE,I1,I2,I3,ANGLE(IE,1:3),ANGLETOT(I1)*RADE,TRILAND(IE)

        END DO

!       END IF

      CALL DIFFERENCE

      RETURN    
 END SUBROUTINE     


!/ ------------------------------------------------------------------- /      
        SUBROUTINE W3IOPENS ( A )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           H. L. Tolman            |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         15-MAy-2008 |
!/                  +-----------------------------------+
!/
!/    15-May-2008 : Origination from W3IOPE.                      ( version 3.14 )
!/    15-May-2008 : Adding non-structured related interpolation.  ( version 3.14 )
!/
!  1. Purpose :
!
!     Extract point output data from the unstructured grid and store
!      in output COMMONs, with the same principle as W3IOPE
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       A       R.A.   I   Action spectra on storage grid.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!     See module documentation.
!
!  5. Called by :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      W3WAVE    Subr. W3WAVEMD Actual wave model routine.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!       None.
!
!  7. Remarks :
!
!     - To allow for dynamic ice edges, interpolation factors are
!       calculated for every time step separately.
!     - Wind current and depth data are interpolated ignoring ice,
!       spectrum is interpolated removing ice points.
!     - Spectra are left in par list to allow for change of shape of
!       arrays.
!     - IMOD is not passed to this routine. Since it is used only
!       in W3WAVE, it is assumed that the pointer are set
!       appropriately outside this routine.
!
!  8. Structure :
!
!     See source code.
!
!  9. Switches :
!
!     !/SHRD  Switch for shared / distributed memory architecture.
!     !/DIST  Id.
!     !/MPI   Switch for message passing method.
!
!     !/S     Enable subroutine tracing.
!     !/T     Test output.
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
      USE CONSTANTS
      USE W3GDATMD, ONLY: NK, NTH, SIG, NX, NY, NSEA, NSEAL,          &
                          MAPSTA, MAPFS,TRIGP
      USE W3ADATMD, ONLY: CG, DW, UA, UD, AS, CX, CY, SP => SPPNT
      USE W3ODATMD, ONLY: NDST, NOPTS, IPTINT, PTIFAC, IL, IW, II,    &
                          DPO, WAO, WDO, ASO, CAO, CDO, SPCO
!/MPI      USE W3ODATMD, ONLY: IRQPO2
      USE W3SERVMD, ONLY: EXTCDE
!/S      USE W3SERVMD, ONLY: STRACE
!/T      USE W3ARRYMD, ONLY: PRT2DS
!
      IMPLICIT NONE
!
!/MPI      INCLUDE "mpif.h"
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      REAL, INTENT(IN)        :: A(NTH,NK,0:NSEAL)
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      INTEGER                 :: I, IX1, IY1, IX(4), IY(4), J, IS(4), &
                                 IM(4), IK, ITH, ISP
      INTEGER                 :: itout                          
!/MPI      INTEGER                 :: IOFF, IERR_MPI
!/MPI      INTEGER                 :: STAT(MPI_STATUS_SIZE,4*NOPTS)
!/S      INTEGER, SAVE           :: IENT = 0
      REAL                    :: RD(4), RDS, RDI, FACRD,    &
                                 WNDX, WNDY, CURX, CURY, FAC1(NK),    &
                                 FAC2(NK), FAC3(NK)
      REAL                    :: alphaa, beta                                
!/T      REAL                    :: SPTEST(NK,NTH)
!/
!/ ------------------------------------------------------------------- /
!/
!/S      CALL STRACE (IENT, 'W3IOPENS')
!
      CX(0)  = 0.
      CY(0)  = 0.
      IS(:)  = 0
      IM(:)  = 0
!
! Loop over spectra -------------------------------------------------- *
!
      DO I=1, NOPTS
!
!/T        WRITE (NDST,9000) I
!
! Unpack interpolation data
!
!AR: For the interpolation stuff again here we use ERIC's 3d array structure but we keep the 2nd index to 1
   itout  =  IPTINT(1,1,I)
   alphaa =  PTIFAC(1,I)
   beta   =  PTIFAC(2,I)
   
   
    IX(1)  =  TRIGP(itout,1)
    IX(2)  =  TRIGP(itout,2)
    IX(3)  =  TRIGP(itout,3)
    IX(4)  =  TRIGP(itout,1)

    IY(:)  =  1

!   
! Interpolation factors assuming sea points only
!
    RD(1)  =  alphaa
    RD(2)  =  beta
    RD(3)  =  1-alphaa-beta
    RD(4)  =  0.
   
!
! Correct for land and ice and get sea point counters
!
        IL(I)  = 0
        IW(I)  = 0
        II(I)  = 0
        RDS    = 0.
        RDI    = 0.
!
        DO J=1, 3
          IS(J)  = MAPFS (IY(J),IX(J))
          IM(J)  = MAPSTA(IY(J),IX(J))
          IF ( IM(J).GT.0 ) THEN
              IW(I)  = IW(I) + 1
              RDS    = RDS + RD(J)
            ELSE
              IF ( IM(J).LT.0 ) THEN
                  II(I)  = II(I) + 1
                  RDI    = RDI + RD(J)
                ELSE
                  IL(I)  = IL(I) + 1
                  RD(J)  = 0.
                END IF
            END IF
          END DO
!
! Depth, wind and current, ignore ice
!
        IF ( RDS+RDI .GT. 1.E-7 ) THEN
            FACRD  = 1. / (RDS+RDI)
            RD     = RD * FACRD
          END IF
  
!
!/T        WRITE (NDST,9002) (IS(J),J=1,4), (IM(J),J=1,4), (RD(J),J=1,4)
!
! Interpolate depth wind and current
!
        DPO(I) = RD(1)*DW(IS(1)) + RD(2)*DW(IS(2)) +                  &
                 RD(3)*DW(IS(3)) 
    
!
        WNDX   = RD(1) * UA(IS(1)) * COS(UD(IS(1))) +                 &
                 RD(2) * UA(IS(2)) * COS(UD(IS(2))) +                 &
                 RD(3) * UA(IS(3)) * COS(UD(IS(3)))                  
                 
        WNDY   = RD(1) * UA(IS(1)) * SIN(UD(IS(1))) +                 &
                 RD(2) * UA(IS(2)) * SIN(UD(IS(2))) +                 &
                 RD(3) * UA(IS(3)) * SIN(UD(IS(3))) 
!
        WAO(I) = SQRT ( WNDX**2 + WNDY**2 )
        IF ( WAO(I).GT.1.E-7 ) THEN
            WDO(I) = ATAN2(WNDY,WNDX)
          ELSE
            WDO(I) = 0.
          END IF
!
        ASO(I) = RD(1)*AS(IS(1)) + RD(2)*AS(IS(2)) +                  &
                 RD(3)*AS(IS(3)) 
!
        CURX   = RD(1)*CX(IS(1)) + RD(2)*CX(IS(2)) +                  &
                 RD(3)*CX(IS(3)) 
        CURY   = RD(1)*CY(IS(1)) + RD(2)*CY(IS(2)) +                  &
                 RD(3)*CY(IS(3)) 
!
        CAO(I) = SQRT ( CURX**2 + CURY**2 )
        IF ( CAO(I).GT.1.E-7 ) THEN
            CDO(I) = ATAN2(CURY,CURX)
          ELSE
            CDO(I) = 0.
          END IF
!
! Interp. weights for spectra, no ice points (spectra by def. zero)
!
        IF ( RDS .GT. 1.E-7 ) THEN
            FACRD  = (RDS+RDI) / RDS
            RD     = RD * FACRD
          END IF
!
!/T        WRITE (NDST,9003) (RD(J),J=1,3)
!
! Extract spectra, shared memory version
!        (done in separate step for MPP compatibility)
!
!/SHRD        DO J=1, 3
!/SHRD          DO IK=1, NK
!/SHRD            DO ITH=1, NTH
!/SHRD              SP(ITH,IK,J) = A(ITH,IK,IS(J))
!/SHRD              END DO
!/SHRD            END DO
!/SHRD          END DO
!
! Extract spectra, distributed memory version(s)

!/MPI        IOFF   = 1 + 4*(I-1)
!/MPI        CALL MPI_STARTALL ( 4, IRQPO2(IOFF), IERR_MPI )
!/MPI        CALL MPI_WAITALL  ( 4, IRQPO2(IOFF), STAT, IERR_MPI )
!
! Interpolate spectrum
!
        DO IK=1, NK
          FAC1(IK) = TPI * SIG(IK) / CG(IK,IS(1))
          FAC2(IK) = TPI * SIG(IK) / CG(IK,IS(2))
          FAC3(IK) = TPI * SIG(IK) / CG(IK,IS(3))

          END DO
!
        DO IK=1,NK
          DO ITH=1,NTH
            ISP    = ITH + (IK-1)*NTH
            SPCO(ISP,I) = RD(1) * SP(ITH,IK,1) * FAC1(IK)             &
                        + RD(2) * SP(ITH,IK,2) * FAC2(IK)             &
                        + RD(3) * SP(ITH,IK,3) * FAC3(IK)          
            END DO
          END DO
        END DO
!
      RETURN
!
! Formats
!
!/T 9000 FORMAT (' TEST W3IOPE : POINT NR.:',I3)
!/T 9001 FORMAT (' TEST W3IOPE :',2I4,2F6.3,'   (',I3,')')
!/T 9002 FORMAT (' TEST W3IOPE :',4I7,2X,4I2,2X,4F5.2)
!/T 9003 FORMAT (' TEST W3IOPE :',40X,4F5.2)
!/T 9004 FORMAT (' TEST W3IOPE :',F8.1,2(F7.2,F7.1))
!/
!/ End of W3IOPENS ----------------------------------------------------- /
!/
      END SUBROUTINE W3IOPENS
!------------------------------------------------------------------------!
!                           TRIANGLE MOD                                 !
!------------------------------------------------------------------------!
      subroutine triangulation_mesh_boundary()

        use W3GDATMD, only : nx, ntri, trigp, xyb, iobp

        implicit none
        integer :: index_op
        integer :: i, ii, i1, i2, i3
        integer :: j, j1, j2
        real (kind = 8) :: polygon_area        
        real (kind = 8) :: domain_area
!C
        dim_num = 2
        node_num = nx
        triangle_num = ntri
        triangle_order = 3

        allocate( node_xy(1:dim_num, node_num) )
        allocate( triangle_node(triangle_order,triangle_num) )

        node_xy(1,:) = xyb(:,1)
        node_xy(2,:) = xyb(:,2)
        do i = 1, ntri
          triangle_node(:,i) = trigp(i,:)
        end do 
!C
        allocate( node_boundary(node_num) )
        allocate( edge(3,3*triangle_num) )
        allocate( edge_boundary(3*triangle_num) )
!C
        call triangulation_order3_boundary_node ( node_num, triangle_num, triangle_node, node_boundary, edge, edge_boundary )
!C
        bound_edge_num = 0

        do i = 1, 3*triangle_num
          if (edge_boundary(i)) bound_edge_num = bound_edge_num + 1
        end do        
!C
        allocate( edge_nums(bound_edge_num) )
        allocate( edge_index(2,bound_edge_num) )
        allocate( edge_angle(2,bound_edge_num) )
        allocate( boundary_node_index(bound_edge_num) )          
!C            
        edge_nums(:) = 0
        edge_index(:,:) = 0
!C          
        call triangulation_order3_boundary_edge ( triangle_num, edge, edge_boundary, bound_edge_num, &
     &                                            bound_num, edge_nums, edge_index )    
!C
        domain_area = 0.0
        index_op = 1
        ii = 0
!C    
        do i = 1, bound_num ! start loop over polygons ... 
!C
            polygon_area = 0.0

            if (i == 1) then
              j1 = 1
              j2 = edge_nums(i)
            else
              j1 = edge_nums(i-1) + 1
              j2 = edge_nums(i)
            end if

            do j = j1, j2, 1
              i1 = edge_index(1,j)
              i2 = edge_index(2,j)
              polygon_area = polygon_area + node_xy(1,i1)*node_xy(2,i2) - node_xy(1,i2)*node_xy(2,i1)        
            end do
!C            
            polygon_area = 0.5 * polygon_area  
          
!            write(*,*) 'polygon_area = ', abs(polygon_area), 'bound_num', i
!C convert the clockwise order to the counterclockwise order
!C
            if (polygon_area < 0.0) then
              do j = 1, int((j2-j1+1)/2), 1         
                call i_swap( edge_index(1,j1+(j-1)), edge_index(1,j2-(j-1)) )
                call i_swap( edge_index(2,j1+(j-1)), edge_index(2,j2-(j-1)) )                
              end do
              do j = j1, j2, 1
                call i_swap( edge_index(1,j), edge_index(2,j) )
              end do
              polygon_area = -1.0d0 * polygon_area
!              write(*,*) 'polygon_area corrected = ', abs(polygon_area)
            end if

!C print out the edge number
!            do j = j1, j2, 1
!              i1 = edge_index(1,j)
!              i2 = edge_index(2,j)
!              write(*,*) i1, i2
!            end do
            
            if (polygon_area >= domain_area) then
              domain_area = polygon_area
              index_op = i         
            end if

            do j = j1, j2, 1

              i1 = edge_index(1,j)
              i2 = edge_index(2,j)

              if (j == j2) then
                i3 = edge_index(2,j1)
              else
                i3 = edge_index(2,j+1)
              end if

              ii = ii + 1
              boundary_node_index(ii) = i2

              call line_angle( node_xy(1,i2), node_xy(2,i2), node_xy(1,i1), node_xy(2,i1), edge_angle(2,ii) )
              call line_angle( node_xy(1,i2), node_xy(2,i2), node_xy(1,i3), node_xy(2,i3), edge_angle(1,ii) )
        
            end do
!C            
        end do ! end loop over bounds ...
!C            
!       do i = 1, ii
!         write(*,*) boundary_node_index(i), edge_angle(1,i)/(4.0d0*atan(1.0d0))*180.0d0, edge_angle(2,i)/(4.0d0*atan(1.0d0))*180.0d0
!       end do
!C
        ii = 0    
        do i = 1, bound_num ! start loop over polygons ... 
            if (i == 1) then
              j1 = 1
              j2 = edge_nums(i)
            else
              j1 = edge_nums(i-1) + 1
              j2 = edge_nums(i)
            end if
            do j = j1, j2, 1
              i1 = edge_index(1,j)
              i2 = edge_index(2,j)
              ii = ii + 1
              boundary_node_index(ii) = i2
              if (i == index_op) then
                if ( iobp(i2) == 0 ) iobp(i2) =  1
              else
                if ( iobp(i2) == 0 ) iobp(i2) = -1
              end if
            end do
        end do ! end loop over bounds ...

        return
      end subroutine
!C
!C******************************************************************************
!C
     subroutine dealloc_triang_bound()
          implicit none
          deallocate( node_boundary )
          deallocate( edge )
          deallocate( edge_boundary )
          deallocate( edge_nums )
          deallocate( edge_index )
          deallocate( edge_angle )
          deallocate( boundary_node_index )
     end subroutine
!C
!C******************************************************************************
!C
      subroutine triangulation_order3_boundary_node( node_num, &
        triangle_num, triangle_node, node_boundary, edge, edge_boundary )
!C
!C  TRIANGULATION_ORDER3_BOUNDARY_NODE indicates which nodes are on the boundary.
!C
!C  Discussion:
!C
!C    This routine is given a triangulation, an abstract list of triples
!C    of nodes.  It is assumed that the nodes in each triangle are listed
!C    in a counterclockwise order, although the routine should work 
!C    if the nodes are consistently listed in a clockwise order as well.
!C
!C    It is assumed that each edge of the triangulation is either 
!C    * an INTERIOR edge, which is listed twice, once with positive
!C      orientation and once with negative orientation, or;
!C    * a BOUNDARY edge, which will occur only once.
!C
!C    This routine should work even if the region has holes - as long
!C    as the boundary of the hole comprises more than 3 edges!
!C
!C  Modified:
!C
!C    20 March 2005
!C
!C  Author:
!C
!C    John Burkardt
!C
!C  Parameters:
!C
!C    Input, integer NODE_NUM, the number of nodes.
!C
!C    Input, integer TRIANGLE_NUM, the number of triangles.
!C
!C    Input, integer TRIANGLE_NODE(3,TRIANGLE_NUM), the nodes that make up the
!C    triangles.  These should be listed in counterclockwise order.
!C
!C    Output, logical NODE_BOUNDARY(NODE_NUM), is TRUE if the node
!C    is on a boundary edge.
!C
        implicit none
!C        
        integer node_num
        integer triangle_num
!C       
        integer e1(3*triangle_num)
        integer e2(3*triangle_num)
        integer edge(3,3*triangle_num)
        integer triangle_node(3,triangle_num)          
        logical node_boundary(node_num)
        logical edge_boundary(3*triangle_num)
        integer i
        integer j
        integer m
        integer n          
!C  
        m = 2
        n = 3 * triangle_num
!C
!C  Set up the edge array.
!C
        edge(1:2,               1:  triangle_num) = &
          triangle_node(1:2,1:triangle_num)
        edge(1:2,  triangle_num+1:2*triangle_num) = & 
          triangle_node(2:3,1:triangle_num)
        edge(1,  2*triangle_num+1:3*triangle_num) = & 
          triangle_node(3,  1:triangle_num)
        edge(2,  2*triangle_num+1:3*triangle_num) = & 
          triangle_node(1,  1:triangle_num)
!C
!C  In each column, force the smaller entry to appear first.
!C
        e1(1:n) = minval ( edge(1:2,1:n), dim = 1 )
        e2(1:n) = maxval ( edge(1:2,1:n), dim = 1 )
!C 
!        do i = 1, n
!          write(*,*) i, edge(1,i), edge(2,i)
!        end do
!C  
        edge(1,1:n) = e1(1:n)
        edge(2,1:n) = e2(1:n)
!C 
        do i = 1, n
          edge(3,i) = i
        end do
!C
!C  Ascending sort the column array.
!C
        call icol_sort_a ( 3, n, edge )
!C
!C  Records which appear twice are internal edges and can be ignored.
!C
        node_boundary(1:node_num) = .false.
!C
        edge_boundary(1:n) = .false. 
!C
        j = 0
!C        
        do while ( j < 3 * triangle_num )    
          j = j + 1        
          if ( j == 3 * triangle_num ) then
            node_boundary(edge(1:m,j)) = .true.
            edge_boundary(j) = .true.
          else if ( all ( edge(1:m,j) == edge(1:m,j+1) ) ) then
            j = j + 1
          else
            node_boundary(edge(1:m,j)) = .true.
            edge_boundary(j) = .true.    
          end if        
        end do
!C
!        do i = 1, n
!          write(*,*) i, edge(1,i), edge(2,i), edge(3,i), edge_boundary(i)
!        end do 
!C  
!        do i = 1, node_num
!          write(*,*) i, node_boundary(i)
!        end do
!C
        return
      end subroutine
!C
!C******************************************************************************
!C
      subroutine triangulation_order3_boundary_edge( triangle_num, edge, &
        edge_boundary, bound_edge_num, bound_num, edge_nums, edge_index )
!C
        implicit none
        integer triangle_num
        integer edge(3,3*triangle_num)
        logical edge_boundary(3*triangle_num)
        integer bound_edge_num
        integer bound_num
        integer edge_nums(bound_edge_num)
        integer edge_index(2,bound_edge_num)
        integer edge_tmp(3,bound_edge_num)
        integer connect_node          
        integer i, j, k, l
!C
        j = 1
        do i = 1, triangle_num*3
          if ( edge_boundary(i) ) then
            edge_tmp(1:2,j) = edge(1:2,i)
            edge_tmp(3,j) = i
            j = j + 1
          end if
        end do
!        do i = 1, bound_edge_num
!          write(*,*) i, edge_tmp(1:3,i)
!        end do
!C        
        j = 0
        i = 0  
        k = 0       
!C
        do while ( j < bound_edge_num )        
!C        
          do i = 1, bound_edge_num
!C          
            if ( edge_tmp(3,i) /= 0 ) then        
              k = k + 1
              j = j + 1              
              edge_index(1:2,j) = edge_tmp(1:2,i)
              connect_node = edge_index(2,j)
              edge_tmp(3,i) = 0
!              write(*,*) j, edge_index(1,j), edge_index(2,j)
!C             
              l = 0
              do while ( l /= bound_edge_num+1 )
                do l = 1, bound_edge_num
                  if ( edge_tmp(3,l) /= 0 ) then 
                    if ( connect_node == edge_tmp(1,l) ) then
                      j = j + 1                     
                      edge_index(1:2,j) = edge_tmp(1:2,l)                  
                      connect_node = edge_index(2,j)
                      edge_tmp(3,l) = 0
!                     write(*,*) j, edge_index(1,j), edge_index(2,j) 
                      exit 
                    else if ( connect_node == edge_tmp(2,l) ) then
                      j = j + 1
                      edge_index(1:2,j) = edge_tmp(2:1:-1,l)
                      connect_node = edge_index(2,j)
                      edge_tmp(3,l) = 0
!                     write(*,*) j, edge_index(1,j), edge_index(2,j) 
                      exit                     
                    end if
                  end if        
                end do
              end do             
!C    
            end if
            edge_nums(k) = j                        
          end do         
        end do
!C          
        bound_num = k
!C          
        return 
      end subroutine
!C
!C******************************************************************************
!C
      subroutine icol_sort_a ( m, n, a )
!
!  ICOL_SORT_A ascending sorts an integer array of columns.
!
!  Discussion:
!
!    In lexicographic order, the statement "X < Y", applied to two real
!    vectors X and Y of length M, means that there is some index I, with
!    1 <= I <= M, with the property that
!
!      X(J) = Y(J) for J < I,
!    and
!      X(I) < Y(I).
!
!    In other words, the first time they differ, X is smaller.
!
!  Modified:
!
!    25 September 2001
!
!  Author:
!
!    John Burkardt
!
!  Parameters:
!
!    Input, integer M, the number of rows of A, and the length of
!    a vector of data.
!
!    Input, integer N, the number of columns of A.
!
!    Input/output, integer A(M,N).
!    On input, the array of N columns of M-vectors.
!    On output, the columns of A have been sorted in ascending
!    lexicographic order.
!
        implicit none
      
        integer m
        integer n
      
        integer a(m,n)
        integer i
        integer indx
        integer isgn
        integer j
      
        if ( m <= 0 ) then
          return
        end if
      
        if ( n <= 1 ) then
          return
        end if
!
!  Initialize.
!
        i = 0
        indx = 0
        isgn = 0
        j = 0
!
!  Call the external heap sorter.
!
        do
      
          call sort_heap_external ( n, indx, i, j, isgn )
!
!  Interchange the I and J objects.
!
          if ( 0 < indx ) then
      
            call icol_swap ( m, n, a, i, j )
!
!  Compare the I and J objects.
!
          else if ( indx < 0 ) then
      
            call icol_compare ( m, n, a, i, j, isgn )
      
          else if ( indx == 0 ) then
      
            exit
      
          end if
      
        end do
      
        return
      end subroutine
!C
!C******************************************************************************
!C
      subroutine sort_heap_external ( n, indx, i, j, isgn )
!C
!C SORT_HEAP_EXTERNAL externally sorts a list of items into ascending order.
!C
!C  Discussion:
!C
!C    The actual list of data is not passed to the routine.  Hence this
!C    routine may be used to sort integers, real ( kind = 8 )s, numbers, names,
!C    dates, shoe sizes, and so on.  After each call, the routine asks
!C    the user to compare or interchange two items, until a special
!C    return value signals that the sorting is completed.
!C
!C  Modified:
!C
!C    05 February 2004
!C
!C  Reference:
!C
!C    A Nijenhuis and H Wilf,
!C    Combinatorial Algorithms,
!C    Academic Press, 1978, second edition,
!C    ISBN 0-12-519260-6.
!C
!C  Parameters:
!C
!C    Input, integer N, the number of items to be sorted.
!C
!C    Input/output, integer INDX, the main communication signal.
!C
!C    The user must set INDX to 0 before the first call.
!C    Thereafter, the user should not change the value of INDX until
!C    the sorting is done.
!C
!C    On return, if INDX is
!C
!C      greater than 0,
!C      * interchange items I and J;
!C      * call again.
!C
!C      less than 0,
!C      * compare items I and J;
!C      * set ISGN = -1 if I < J, ISGN = +1 if J < I;
!C      * call again.
!C
!C      equal to 0, the sorting is done.
!C
!C    Output, integer I, J, the indices of two items.
!C    On return with INDX positive, elements I and J should be interchanged.
!C    On return with INDX negative, elements I and J should be compared, and
!C    the result reported in ISGN on the next call.
!C
!C    Input, integer ISGN, results of comparison of elements I and J.
!C    (Used only when the previous call returned INDX less than 0).
!C    ISGN <= 0 means I is less than or equal to J;
!C    0 <= ISGN means I is greater than or equal to J.
!C
        implicit none
      
        integer i
        integer, save :: i_save = 0
        integer indx
        integer isgn
        integer j
        integer, save :: j_save = 0
        integer, save :: k = 0
        integer, save :: k1 = 0
        integer n
        integer, save :: n1 = 0
!C
!C  INDX = 0: This is the first call.
!C
        if ( indx == 0 ) then
      
          i_save = 0
          j_save = 0
          k = n / 2
          k1 = k
          n1 = n
!C
!C  INDX < 0: The user is returning the results of a comparison.
!C
        else if ( indx < 0 ) then
      
          if ( indx == -2 ) then
      
            if ( isgn < 0 ) then
              i_save = i_save + 1
            end if
      
            j_save = k1
            k1 = i_save
            indx = -1
            i = i_save
            j = j_save
            return
      
          end if
      
          if ( 0 < isgn ) then
            indx = 2
            i = i_save
            j = j_save
            return
          end if
      
          if ( k <= 1 ) then
      
            if ( n1 == 1 ) then
              i_save = 0
              j_save = 0
              indx = 0
            else
              i_save = n1
              n1 = n1 - 1
              j_save = 1
              indx = 1
            end if
      
            i = i_save
            j = j_save
            return
      
          end if
      
          k = k - 1
          k1 = k
!C
!C  0 < INDX, the user was asked to make an interchange.
!C
        else if ( indx == 1 ) then
      
          k1 = k
      
        end if
      
        do
      
          i_save = 2 * k1
      
          if ( i_save == n1 ) then
            j_save = k1
            k1 = i_save
            indx = -1
            i = i_save
            j = j_save
            return
          else if ( i_save <= n1 ) then
            j_save = i_save + 1
            indx = -2
            i = i_save
            j = j_save
            return
          end if
      
          if ( k <= 1 ) then
            exit
          end if
      
          k = k - 1
          k1 = k
      
        end do
      
        if ( n1 == 1 ) then
          i_save = 0
          j_save = 0
          indx = 0
          i = i_save
          j = j_save
        else
          i_save = n1
          n1 = n1 - 1
          j_save = 1
          indx = 1
          i = i_save
          j = j_save
        end if
      
        return
      end subroutine       
!C
!C******************************************************************************
!C      
      subroutine icol_swap ( m, n, a, i, j )
!C
!C  ICOL_SWAP swaps columns I and J of a integer array of column data.
!C
!C  Example:
!C
!C    Input:
!C
!C      M = 3, N = 4, I = 2, J = 4
!C
!C      A = (
!C        1  2  3  4
!C        5  6  7  8
!C        9 10 11 12 )
!C
!C    Output:
!C
!C      A = (
!C        1  4  3  2
!C        5  8  7  6
!C        9 12 11 10 )
!C
!C  Modified:
!C
!C    04 April 2001
!C
!C  Author:
!C
!C    John Burkardt
!C
!C  Parameters:
!C
!C    Input, integer M, N, the number of rows and columns in the array.
!C
!C    Input/output, integer A(M,N), an array of N columns of length M.
!C
!C    Input, integer I, J, the columns to be swapped.
!C
        implicit none
      
        integer m
        integer n
      
        integer a(m,n)
        integer col(m)
        integer i
        integer j
      
        if ( i < 1 .or. n < i .or. j < 1 .or. n < j ) then
      
!          write ( *, '(a)' ) ' '
!          write ( *, '(a)' ) 'ICOL_SWAP - Fatal error!'
!          write ( *, '(a)' ) '  I or J is out of bounds.'
!          write ( *, '(a,i6)' ) '  I =    ', i
!          write ( *, '(a,i6)' ) '  J =    ', j
!          write ( *, '(a,i6)' ) '  N =    ', n
!          stop
      
        end if
      
        if ( i == j ) then
          return
        end if
      
        col(1:m) = a(1:m,i)
        a(1:m,i) = a(1:m,j)
        a(1:m,j) = col(1:m)
      
        return
      end subroutine
!C
!C******************************************************************************
!C
      subroutine icol_compare ( m, n, a, i, j, isgn )
!C
!C  ICOL_COMPARE compares columns I and J of a integer array.
!C
!C  Example:
!C
!C    Input:
!C
!C      M = 3, N = 4, I = 2, J = 4
!C
!C      A = (
!C        1  2  3  4
!C        5  6  7  8
!C        9 10 11 12 )
!C
!C    Output:
!C
!C      ISGN = -1
!C
!C  Modified:
!C
!C    30 June 2000
!C
!C  Author:
!C
!C    John Burkardt
!C
!C  Parameters:
!C
!C    Input, integer M, N, the number of rows and columns.
!C
!C    Input, integer A(M,N), an array of N columns of vectors of length M.
!C
!C    Input, integer I, J, the columns to be compared.
!C    I and J must be between 1 and N.
!C
!C    Output, integer ISGN, the results of the comparison:
!C    -1, column I < column J,
!C     0, column I = column J,
!C    +1, column J < column I.
!C
        implicit none
      
        integer m
        integer n
      
        integer a(m,n)
        integer i
        integer isgn
        integer j
        integer k
!C
!C  Check.
!C
        if ( i < 1 .or. n < i ) then
          write ( *, '(a)' ) ' '
          write ( *, '(a)' ) 'ICOL_COMPARE - Fatal error!'
          write ( *, '(a)' ) '  Column index I is out of bounds.'
          stop
        end if
      
        if ( j < 1 .or. n < j ) then
          write ( *, '(a)' ) ' '
          write ( *, '(a)' ) 'ICOL_COMPARE - Fatal error!'
          write ( *, '(a)' ) '  Column index J is out of bounds.'
          stop
        end if
      
        isgn = 0
      
        if ( i == j ) then
          return
        end if
      
        k = 1
      
        do while ( k <= m )
      
          if ( a(k,i) < a(k,j) ) then
            isgn = -1
            return
          else if ( a(k,j) < a(k,i) ) then
            isgn = +1
            return
          end if
      
          k = k + 1
      
        end do
      
        return
      end subroutine        
!C
!C******************************************************************************
!C        
      subroutine line_angle( x1, y1, x2, y2, angle )
        implicit none
        real (kind = 8) x1, y1, x2, y2
        real (kind = 8) angle
        real (kind = 8) dx, dy
        
        dx = x2 - x1
        dy = y2 - y1
        angle = atan2( dy, dx )
        if ( angle < 0.0d0 ) angle = 8.0d0 * atan(1.0d0) + angle
        
        return
      end subroutine       
!C
!C******************************************************************************
!C
      subroutine i_swap( a, b )
        implicit none
        integer a, b
        integer itmp
        
        itmp = a
        a = b
        b = itmp
        
        return
      end subroutine
!C
!C******************************************************************************
!C
      subroutine d_swap( a, b )
        implicit none
        real (kind = 8) a, b
        real (kind = 8) dtmp
        
        dtmp = a
        a = b
        b = dtmp
        
        return
      end subroutine                                 
!/      
END MODULE W3TRIAMD
