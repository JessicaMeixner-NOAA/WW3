module w3tripmd

implicit none

private

public ReadTriPolFile

logical, public :: FIRST = .true.

type, public :: GridInfoType; private
   real, allocatable, dimension(:,:) :: VAR1, VAR2, VAR3, VAR4, VAR5, VAR6
   character(len=14) :: var1_name, var2_name, var3_name, var4_name, var5_name, var6_name 
   
end type GridInfoType

type(GridInfoType) :: GridInfo

contains

subroutine ReadTriPolFile(X, Y, LBI, UBI, LBO, UBO, &
                          MASK, GPPC, GQQC, GPQC, GSQR, HPFC, HQFC,&
                          APPC, AQQC, APQC, DXDP, DYDP, DXDQ, DYDQ, &
                          DPDX, DPDY, DQDX, DQDY, COSA, COSC, SINC, &
                          ANGL, SINA, COST, SINT)

INTEGER, INTENT(IN)   :: LBI(2), UBI(2)
INTEGER, INTENT(IN)   :: LBO(2), UBO(2)
REAL, INTENT(IN)   :: X(LBI(1):UBI(1),LBI(2):UBI(2))
REAL, INTENT(IN)   :: Y(LBI(1):UBI(1),LBI(2):UBI(2))
LOGICAL, INTENT(IN),  OPTIONAL :: MASK(LBI(1):UBI(1),LBI(2):UBI(2))
REAL, INTENT(OUT), OPTIONAL :: GPPC(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: GQQC(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: GPQC(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: GSQR(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: HPFC(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: HQFC(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: APPC(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: AQQC(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: APQC(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: DXDP(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: DYDP(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: DXDQ(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: DYDQ(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: DPDX(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: DPDY(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: DQDX(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: DQDY(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: COSA(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: COSC(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: SINC(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: ANGL(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: SINA(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: COST(LBO(1):UBO(1),LBO(2):UBO(2))
REAL, INTENT(OUT), OPTIONAL :: SINT(LBO(1):UBO(1),LBO(2):UBO(2))

INTEGER :: NQ
REAL :: GPPCL, GQQCL, GPQCL
REAL :: GSQRL, HPFCL, HQFCL
REAL :: APPCL, AQQCL, APQCL
REAL :: DXDPL, DYDPL, DXDQL, DYDQL
REAL :: DPDXL, DPDYL, DQDXL, DQDYL
REAL :: COSAL, SINAL, COSTP, SINTP, COSCL, SINCL, ANGLL

character(len=14) :: NC_filename
character(len=14) ::  Var, Var1, Var2, Var3, Var4, Var5, Var6
integer :: var_id, var1_id, var2_id, var3_id, var4_id, var5_id, var6_id
integer :: ndims, len_dim_1, len_dim_2
integer, dimension(4) :: dim_id, dims
integer, dimension(2) :: START, FINISH
integer:: rcode, ncid

integer :: I2, I1, P, Q, p_, q_

NC_filename='ocean_hgrid.nc'

GridInfo%var1_name = 'x'
GridInfo%var2_name = 'y'
GridInfo%var3_name = 'dx'
GridInfo%var4_name = 'dy'
GridInfo%var5_name = 'angle_dx'
GridInfo%var6_name = 'area'

if (first) then
   call NCreader(NC_filename,GridInfo%var1_name )
   call NCreader(NC_filename,GridInfo%var2_name )
   call NCreader(NC_filename,GridInfo%var3_name )
   call NCreader(NC_filename,GridInfo%var4_name )
   call NCreader(NC_filename,GridInfo%var5_name )
   call NCreader(NC_filename,GridInfo%var6_name )
   first=.false.
endif

NQ=300

DO I2 = LBO(2), UBO(2)
   DO I1 = LBO(1), UBO(1)
      P=I2;Q=I1
      if (.true.) then!(.not. MASK(Q,P)) then
         P_ = (P-1) *2 + 1
         Q_ = NQ + (Q-1) *2 + 1
         !         1       2
         !   5  x---x---x---x---x
         ! 4    |   |   |   |   |
         !   4  x---o---x---o---x 2
         ! 3    |   |   |   |   |
         !   3  x---x---x---x---x
         ! 2    |   |   |   |   |
         !   2  x---o---x---o---x 1
         ! 1    |   |   |   |   |
         !   1  x---x---x---x---x
         !      1   2   3   4   5
         !        1   2   3   4
         
         !  DX/DP is DX(p,q+1) + DX(p+1,q+1)
         DXDPL = GridInfo%var3(p_,q_+1) + GridInfo%var3(p_+1,q_+1)
         !  DY/DP is (DY(p+2,q) + DY(p+2,q+1)) - (DY(p,q) + DY(p,q+1))
         DYDPL = ( GridInfo%var4(p_+2,q_) + GridInfo%var4(p_+2,q_+1) ) - &
                     ( GridInfo%var4(p_,q_) + GridInfo%var4(p_,q_+1) )
         !  DX/DQ is (DX(p,q+2) + DX(p+1,q+2)) - (DX(p,q) + DX(p+1,q))
         DXDQL = ( GridInfo%var3(p_,q_+2) + GridInfo%var3(p_+1,q_+2) ) - &
                     ( GridInfo%var3(p_,q_) + GridInfo%var3(p_+1,q_) )
         !  DY/DQ is DY(p+1,q) + DY(p+1,q+1)
         DYDQL = GridInfo%var4(p_+1,q_) + GridInfo%var4(p_+1,q_+1)
         GSQRL = DXDPL*DYDQL - DXDQL*DYDPL
         IF ( GSQRL .LT. 0.0 ) THEN
            print*,'Messed up?'
            print*, GSQRL 
            print*,DXDPL
            print*,GridInfo%var3(p_,q_+1) ,GridInfo%var3(p_+1,q_+1)
            print*,DYDQL
            print*,GridInfo%var4(p_+1,q_) , GridInfo%var4(p_+1,q_+1)
            print*,DXDQL
            print*,DYDPL
            print*,i2,i1
         endif
         GPPCL = DXDPL*DXDPL + DYDPL*DYDPL
         GQQCL = DXDQL*DXDQL + DYDQL*DYDQL
         GPQCL = DXDPL*DXDQL + DYDPL*DYDQL
         GSQRL = MAX(GSQRL,1.e-15)
         GPPCL = MAX(GPPCL,1.e-15)
         GQQCL = MAX(GQQCL,1.e-15)
         DPDXL = DYDQL/GSQRL
         DPDYL =-DXDQL/GSQRL
         DQDXL =-DYDPL/GSQRL
         DQDYL = DXDPL/GSQRL
         APPCL = DPDXL*DPDXL + DPDYL*DPDYL
         AQQCL = DQDXL*DQDXL + DQDYL*DQDYL
         APQCL = DPDXL*DQDXL + DPDYL*DQDYL
         HPFCL = SQRT(GPPCL)
         HQFCL = SQRT(GQQCL)
         COSAL = GPQCL/(HPFCL*HQFCL)
         SINAL = GSQRL**2/(GPPCL*GQQCL)
         COSTP = DXDPL/HPFCL
         SINTP = DYDPL/HQFCL
         COSCL = SINAL*COSTP + COSAL*SINTP
         SINCL = SINAL*SINTP - COSAL*COSTP
         ANGLL = ATAN2(SINCL,COSCL)*180./3.1415
         IF (PRESENT(GPPC)) GPPC(I1,I2) = GPPCL
         IF (PRESENT(GQQC)) GQQC(I1,I2) = GQQCL
         IF (PRESENT(GPQC)) GPQC(I1,I2) = GPQCL
         IF (PRESENT(APPC)) APPC(I1,I2) = APPCL
         IF (PRESENT(AQQC)) AQQC(I1,I2) = AQQCL
         IF (PRESENT(APQC)) APQC(I1,I2) = APQCL
         IF (PRESENT(GSQR)) GSQR(I1,I2) = GSQRL
         IF (PRESENT(HPFC)) HPFC(I1,I2) = HPFCL
         IF (PRESENT(HQFC)) HQFC(I1,I2) = HQFCL
         IF (PRESENT(DXDP)) DXDP(I1,I2) = DXDPL
         IF (PRESENT(DYDP)) DYDP(I1,I2) = DYDPL
         IF (PRESENT(DXDQ)) DXDQ(I1,I2) = DXDQL
         IF (PRESENT(DYDQ)) DYDQ(I1,I2) = DYDQL
         IF (PRESENT(DPDX)) DPDX(I1,I2) = DPDXL
         IF (PRESENT(DPDY)) DPDY(I1,I2) = DPDYL
         IF (PRESENT(DQDX)) DQDX(I1,I2) = DQDXL
         IF (PRESENT(DQDY)) DQDY(I1,I2) = DQDYL
         IF (PRESENT(COSA)) COSA(I1,I2) = COSAL
         IF (PRESENT(COSC)) COSC(I1,I2) = COSCL
         IF (PRESENT(SINC)) SINC(I1,I2) = SINCL
         IF (PRESENT(ANGL)) ANGL(I1,I2) = ANGLL
      else
         IF (PRESENT(GPPC)) GPPC(I1,I2) = 0.
         IF (PRESENT(GQQC)) GQQC(I1,I2) = 0.
         IF (PRESENT(GPQC)) GPQC(I1,I2) = 0.
         IF (PRESENT(APPC)) APPC(I1,I2) = 0.
         IF (PRESENT(AQQC)) AQQC(I1,I2) = 0.
         IF (PRESENT(APQC)) APQC(I1,I2) = 0.
         IF (PRESENT(GSQR)) GSQR(I1,I2) = 0.
         IF (PRESENT(HPFC)) HPFC(I1,I2) = 0.
         IF (PRESENT(HQFC)) HQFC(I1,I2) = 0.
         IF (PRESENT(DXDP)) DXDP(I1,I2) = 0.
         IF (PRESENT(DYDP)) DYDP(I1,I2) = 0.
         IF (PRESENT(DXDQ)) DXDQ(I1,I2) = 0.
         IF (PRESENT(DYDQ)) DYDQ(I1,I2) = 0.
         IF (PRESENT(DPDX)) DPDX(I1,I2) = 0.
         IF (PRESENT(DPDY)) DPDY(I1,I2) = 0.
         IF (PRESENT(DQDX)) DQDX(I1,I2) = 0.
         IF (PRESENT(DQDY)) DQDY(I1,I2) = 0.
         IF (PRESENT(COSA)) COSA(I1,I2) = 0.
         IF (PRESENT(COSC)) COSC(I1,I2) = 0.
         IF (PRESENT(SINC)) SINC(I1,I2) = 0.
         IF (PRESENT(ANGL)) ANGL(I1,I2) = 0.
      endif
   enddo
enddo

return
endsubroutine ReadTriPolFile

subroutine CheckRcode(RC, ErrorFlag)

integer, intent(in) :: RC, ErrorFlag 

if (RC.ne.0) then
   if (ErrorFlag==1) &
        print*,'Not Finding NetCDF File'
   if (ErrorFlag==2) &
        print*,'Error probing NetCDF File'
   if (ErrorFlag==3) &
        print*,'Error probing NetCDF Variable'
   if (ErrorFlag==4) &
        print*,'Error reading NetCDF dimension'
   if (ErrorFlag==5) &
        print*,'Error reading NetCDF variable'
   stop
endif
end subroutine CheckRcode


subroutine NCreader(NC_filename, var)

use NETCDF

character(len=14) :: NC_filename, var
integer :: ncid, var_id
integer :: ndims, len_dim_1, len_dim_2
integer, dimension(2) :: dims, dim_id, START, FINISH
character(len=14) :: dim_name(4)
integer :: rcode

  rcode = NF90_OPEN(trim(NC_filename), NF90_NOWRITE, ncid)
  call CheckRcode(rcode,1)
  rcode = NF90_INQ_VARID(ncid, var, var_id)
  call CheckRcode(rcode,2)
  rcode=NF90_INQUIRE_VARIABLE(ncid, var_id, ndims=ndims, dimids=dim_id)
  call CheckRcode(rcode,3) 
  rcode=NF90_INQUIRE_DIMENSION(ncid, dim_id(1), dim_name(1), len=len_dim_1)
  call CheckRcode(rcode,4) 
  rcode=NF90_INQUIRE_DIMENSION(ncid, dim_id(2), dim_name(2), len=len_dim_2)
  call CheckRcode(rcode,4) 
  START(1)=1;START(2)=1;FINISH(1)=len_dim_1;FINISH(2)=len_dim_2

  if (trim(var) == trim(GridInfo%var1_name)) then
     allocate(GridInfo%Var1(len_dim_1,len_dim_2))
     rcode=NF90_GET_VAR(ncid, var_id, GridInfo%Var1, start, finish)
     call CheckRcode(rcode,5) 
  elseif (trim(var) == trim(GridInfo%var2_name)) then
     allocate(GridInfo%Var2(len_dim_1,len_dim_2))
     rcode=NF90_GET_VAR(ncid, var_id, GridInfo%Var2, start, finish)
     call CheckRcode(rcode,5) 
  elseif (trim(var) == trim(GridInfo%var3_name)) then
     allocate(GridInfo%Var3(len_dim_1,len_dim_2))
     rcode=NF90_GET_VAR(ncid, var_id, GridInfo%Var3, start, finish)
     call CheckRcode(rcode,5) 
  elseif (trim(var) == trim(GridInfo%var4_name)) then
     allocate(GridInfo%Var4(len_dim_1,len_dim_2))
     rcode=NF90_GET_VAR(ncid, var_id, GridInfo%Var4, start, finish)
     call CheckRcode(rcode,5) 
  elseif (trim(var) == trim(GridInfo%var5_name)) then
     allocate(GridInfo%Var5(len_dim_1,len_dim_2))
     rcode=NF90_GET_VAR(ncid, var_id, GridInfo%Var5, start, finish)
     call CheckRcode(rcode,5) 
  elseif (trim(var) == trim(GridInfo%var6_name)) then
     allocate(GridInfo%Var6(len_dim_1,len_dim_2))
     rcode=NF90_GET_VAR(ncid, var_id, GridInfo%Var6, start, finish)
     call CheckRcode(rcode,5) 
  endif

rcode=NF90_CLOSE(ncid)
end subroutine NCreader

end module w3tripmd
