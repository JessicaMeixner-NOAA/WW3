!/ ------------------------------------------------------------------- /
      MODULE WMGRIDMD
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           H. L. Tolman            |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         06-Jun-2012 |
!/                  +-----------------------------------+
!/
!/    28-Dec-2005 : Origination WMGLOW, WMGHGH, WMRSPC. ( version 3.08 )
!/    09-Mar-2006 : Carry land mask in WMGHGH.          ( version 3.09 )
!/    24-Apr-2006 : Origination WMGEQL.                 ( version 3.09 )
!/    25-Jul-2006 : Point output grid in WMRSPC.        ( version 3.10 )
!/    23-Dec-2006 : Adding group test in WMGEQL.        ( version 3.10 )
!/    28-Dec-2006 : Simplify NIT for partial comm.      ( version 3.10 )
!/    22-Jan-2007 : Add saving of NAVMAX in WMGEQL.     ( version 3.10 )
!/    02-Feb-2007 : Setting FLAGST in WMGEQL.           ( version 3.10 )
!/    07-Feb-2007 : Setting FLAGST in WMGHGH.           ( version 3.10 )
!/    15-Feb-2007 : Tweaking MAPODI algorithm in WMGEQL.( version 3.10 )
!/    11-Apr-2008 : Bug fix active edges WMGEQL.        ( version 3.13 )
!/    14-Apr-2008 : Bug fix for global grids WMGEQL.    ( version 3.13 )
!/    26-Mar-2009 : Adding test output !/T9 to WMGLOW.  ( version 3.14 )
!/    20-May-2009 : Linking FLAGST and FLGHG1.          ( version 3.14 )
!/    26-May-2009 : Fix erroneous cyclic upd in WMGHGH. ( version 3.14 )
!/    29-May-2009 : Preparing distribution version.     ( version 3.14 )
!/    30-Oct-2009 : Implement run-time grid selection.  ( version 3.14 )
!/                  (W. E. Rogers & T. J. Campbell, NRL)
!/    06-Dec-2010 : Change from GLOBAL (logical) to ICLOSE (integer) to
!/                  specify index closure for a grid.   ( version 3.14 )
!/                  (T. J. Campbell, NRL)
!/    23-Dec-2010 : Fix HPFAC and HQFAC by including the COS(YGRD)
!/                  factor with DXDP and DXDQ terms.    ( version 3.14 )
!/                  (T. J. Campbell, NRL)
!/    12-Mar-2012 : Use MPI_COMM_NULL in checks.        ( version 3.14 )
!/    06-Jun-2012 : Porting bugfixes from 3.14 to 4.07  ( version 4.07 )
!/
!/    Copyright 2009-2012 National Weather Service (NWS),
!/       National Oceanic and Atmospheric Administration.  All rights
!/       reserved.  WAVEWATCH III is a trademark of the NWS. 
!/       No unauthorized use without permission.
!/
!  1. Purpose :
!
!     Routines to determine and process grid dependencies in the 
!     multi-grid wave model.
!
!  2. Variables and types :
!
!  3. Subroutines and functions :
!
!      Name      Type  Scope    Description
!     ----------------------------------------------------------------
!      WMGLOW    Subr. Public   Dependencies to lower ranked grids.
!      WMGHGH    Subr. Public   Dependencies to higher ranked grids.
!      WMGEQL    Subr. Public   Dependencies to same ranked grids.
!      WMRSPC    Subr. Public   Make map of flags for spectral 
!                               conversion between grids.
!     ----------------------------------------------------------------
!
!  4. Subroutines and functions used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      W3SETO, W3SETG, W3DMO5, WMSETM
!                Subr. W3xDATMD Manage data structures.
!
!      STRACE    Sur.  W3SERVMD Subroutine tracing.
!      EXTCDE    Subr.   Id.    Program abort.
!
!      MPI_BCAST, MPI_BARRIER
!                Subr. mpif.h   Comunication routines.
!     ----------------------------------------------------------------
!
!  5. Remarks :
!
!      - WMGLOW and WMGHGH need to be run in this order to
!        assure proper resolving of cross-dependencies.
!      - WMGLOW and WMGEQL, idem.
!
!  6. Switches :
!
!     !/PRn  propagation scheme.
!
!     !/SHRD Distributed memory approach
!     !/DIST
!     !/MPI
!
!     !/O12  Removed boundary points output WMGEQL (central).
!     !/O13  Removed boundary points output WMGEQL (edge).
!
!     !/S    Enable subroutine tracing.
!     !/Tn   Enable test output.
!
!  7. Source code :
!
!/ ------------------------------------------------------------------- /
      PUBLIC
!/
      CONTAINS
!/ ------------------------------------------------------------------- /
      SUBROUTINE WMGLOW ( FLRBPI )
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           H. L. Tolman            |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         06-Jun-2012 |
!/                  +-----------------------------------+
!/
!/    06-Oct-2005 : Origination.                        ( version 3.08 )
!/    10-Feb-2006 : Add test on grid resolution.        ( version 3.09 )
!/    26-Mar-2009 : Adding test output !/T9.            ( version 3.14 )
!/    30-Oct-2009 : Implement run-time grid selection.  ( version 3.14 )
!/                  (W. E. Rogers & T. J. Campbell, NRL)
!/    06-Dec-2010 : Change from GLOBAL (logical) to ICLOSE (integer) to
!/                  specify index closure for a grid.   ( version 3.14 )
!/                  (T. J. Campbell, NRL)
!/    12-Mar-2012 : Use MPI_COMM_NULL in checks.        ( version 4.07 )
!/    06-Jun-2012 : Porting bugfixes from 3.14 to 4.07  ( version 4.07 )
!/
!  1. Purpose :
!
!     Determine relations to lower ranked grids for each grid.
!     On the fly, the oposite relations are also saved.
!
!  2. Method :
!
!     Map active boundary points to lower ranked grids.
!
!  3. Parameters :
!
!     Parameter list
!     ----------------------------------------------------------------
!       FLRBPI  L.A.   O   Array with flags for external file use.
!     ----------------------------------------------------------------
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      W3SETO, W3SETG, W3DMO5
!                Subr. W3xDATMD Manage data structures.
!
!      STRACE    Subr. W3SERVMD Subroutine tracing.
!      EXTCDE    Subr.   Id.    Program abort.
!
!      MPI_BCAST, MPI_BARRIER
!                Subr. mpif.h   Comunication routines.
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      WMINIT    Subr  WMINITMD Multi-grid model initialization.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!
!     - For MPI version it is assumed that NX, NY, NSEA, and NSEAL are
!       properly initialized even if the grid is not run on the local
!       process.
!
!  8. Structure :
!
!     See source code.
!
!  9. Switches :
!
!     !/MPI  Distribbuted memory management.
!
!     !/S    Enable subroutine tracing.
!     !/T    Enable test output.
!     !/T1   Test output for individual boundary points
!     !/T2   Test output cross-reference table
!     !/T9   Test output of map of boundary origine.
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!
      USE W3SERVMD, ONLY: EXTCDE
!/S      USE W3SERVMD, ONLY: STRACE
!
      USE W3GDATMD
      USE W3ODATMD
      USE WMMDATMD
!
      IMPLICIT NONE
!
!/MPI      INCLUDE "mpif.h"
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
      LOGICAL, INTENT(OUT), OPTIONAL :: FLRBPI(NRGRD)
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      INTEGER                 :: I, IBI, IX, IY, JS, J, JX, JY,       &
                                 JX1, JX2, JY1, JY2, JTOT, I1, J1,    &
                                 I2, J2
!/MPI      INTEGER                 :: NXYG, IERR_MPI
!/S      INTEGER, SAVE           :: IENT = 0
      INTEGER, ALLOCATABLE    :: TSTORE(:,:)
!/MPI      LOGICAL                 :: FLBARR
      REAL                    :: XA, YA, RX, RY
      REAL                    :: FACTOR
      LOGICAL                 :: GRIDD(NRGRD,NRGRD), RFILE(NRGRD),    &
                                 FLAGOK
!/T9      CHARACTER(LEN=1), ALLOCATABLE :: TMAP(:,:)
!/
!/S      CALL STRACE (IENT, 'WMGLOW')
!
! -------------------------------------------------------------------- /
! 1.  Test grid, Initialize and synchronize grids as needed ( !/MPI )
!
      IF ( GTYPE .EQ. CLGTYPE .AND. NRGRD .GT. 1 ) THEN
          WRITE (MDSE,'(/2A)') ' *** ERROR WMGLOW: ', &
          'CURVILINEAR GRID SUPPORT NOT IMPLEMENTED FOR NRGRD > 1 ***'
          CALL EXTCDE ( 999 )
        END IF
      IF ( GTYPE .EQ. UNGTYPE ) THEN
          WRITE (MDSE,'(/2A)') ' *** ERROR WMGLOW: ', &
          'UNSTRUCTURED GRID SUPPORT NOT YET IMPLEMENTED ***'
          CALL EXTCDE ( 999 )
        END IF
!
!/MPI      FLBARR = .FALSE.
!
      DO I=1, NRGRD
!
        IF ( .NOT. GRIDS(I)%GINIT ) THEN
            IF ( IMPROC .EQ. NMPERR ) WRITE (MDSE,1000) I
            CALL EXTCDE ( 1000 )
          END IF
!
        CALL W3SETO ( I, MDSE, MDST )
        CALL W3SETG ( I, MDSE, MDST )
!
!/MPI        FLBARR = FLBARR .OR. MDATAS(I)%FBCAST
!/MPI        IF ( MDATAS(I)%FBCAST .AND.                              &
!/MPI             MDATAS(I)%MPI_COMM_BCT.NE.MPI_COMM_NULL ) THEN
!/MPI             NXYG   = GRIDS(I)%NX * GRIDS(I)%NY
!/MPI             CALL MPI_BCAST ( GRIDS(I)%MAPSTA(1,1), NXYG,        &
!/MPI                              MPI_INTEGER, 0,                    &
!/MPI                              MDATAS(I)%MPI_COMM_BCT, IERR_MPI )
!/MPI             CALL MPI_BCAST ( GRIDS(I)%MAPST2(1,1), NXYG,        &
!/MPI                              MPI_INTEGER, 0,                    &
!/MPI                              MDATAS(I)%MPI_COMM_BCT, IERR_MPI )
!/MPI             CALL MPI_BCAST ( GRIDS(I)%MAPFS (1,1), NXYG,        &
!/MPI                              MPI_INTEGER, 0,                    &
!/MPI                              MDATAS(I)%MPI_COMM_BCT, IERR_MPI )
!/MPI             NXYG   = 3*GRIDS(I)%NSEA
!/MPI             CALL MPI_BCAST ( GRIDS(I)%MAPSF (1,1), NXYG,        &
!/MPI                              MPI_INTEGER, 0,                    &
!/MPI                              MDATAS(I)%MPI_COMM_BCT, IERR_MPI )
!/MPI             CALL MPI_BCAST ( GRIDS(I)%CLATIS(1), NSEA, MPI_REAL, 0,&
!/MPI                              MDATAS(I)%MPI_COMM_BCT, IERR_MPI )
!/MPI             CALL MPI_BCAST ( SGRDS(I)%SIG(0), NK+2, MPI_REAL, 0,&
!/MPI                              MDATAS(I)%MPI_COMM_BCT, IERR_MPI )
!/MPI           END IF
!
        END DO
!
!/MPI      IF (FLBARR) CALL MPI_BARRIER (MPI_COMM_MWAVE,IERR_MPI)
!
!/T      WRITE (MDST,9010)
!
! -------------------------------------------------------------------- /
! 2.  Process grids
!
      IF ( FLAGLL ) THEN
          FACTOR = 1.
        ELSE
          FACTOR = 1.E-3
        END IF
!
      GRIDD = .FALSE.
      RFILE = .FALSE.
!
      IF ( .NOT. ALLOCATED(NBI2G) ) ALLOCATE ( NBI2G(NRGRD,NRGRD) )
      NBI2G  = 0 
!
!/T      WRITE (MDST,9020)
!
      DO I=1, NRGRD
!
!/T        WRITE (MDST,9021) I, GRANK(I), OUTPTS(I)%OUT5%NBI
!
! 2.a Test for input boundary points
!
        IF ( OUTPTS(I)%OUT5%NBI .EQ. 0 ) THEN
!/T            WRITE (MDST,9022) 'NO INPUT BOUNDARY POINTS, SKIPPING'
            CYCLE
          END IF
!
! 2.b Test for lowest rank
!
        IF ( GRANK(I) .EQ. 1 ) THEN
            RFILE(I) = .TRUE.
!/T            WRITE (MDST,9022) 'RANK = 1, DATA FROM FILE'
            CYCLE
          END IF
!
! 2.c Search for input boundary points
!
!/T        WRITE (MDST,9022) 'SEARCHING FOR ACTIVE BOUNDARY POINTS'
        IBI    = 0
!
! ... Set up data structure for grid
!
        CALL W3SETO ( I, MDSE, MDST )
        CALL W3SETG ( I, MDSE, MDST )
        CALL W3DMO5 ( I, MDSE, MDST, 1 )
        ALLOCATE ( TSTORE(NBI,0:4) )
!
! ... Set up loop structure for grid
!
        DO IY=1, NY
          DO IX=1, NX
            IF ( ABS(MAPSTA(IY,IX)) .EQ. 2 ) THEN
                XA     = X0 + REAL(IX-1)*SX
                YA     = Y0 + REAL(IY-1)*SY
!
! ... Loop over previous (lower ranked) grids
!
                JS     = 0
!
                DO J=I-1, 1, -1
!
                  IF ( GRANK(J) .GE. GRANK(I) ) CYCLE
!
! ... Check if in grid
!
                  RY     = ( YA - GRIDS(J)%Y0 ) / GRIDS(J)%SY
                  JY     = 1 + INT ( RY ) 
                  RY     = RY - REAL(JY-1)
                  IF ( RY .LT. 0. ) THEN
                      RY     = 1. - RY
                      JY     = JY - 1
                    END IF
                  IF ( JY.EQ.0 .AND. ABS(RY-1.).LT.0.05 ) THEN
                      JY     = 1
                      RY     = 0.
                    END IF
                  IF ( JY.EQ.GRIDS(J)%NY .AND. ABS(RY).LT.0.05 ) THEN
                      JY     = JY - 1
                      RY     = 1.
                    END IF
                  IF ( JY.LT.1 .OR. JY.GE.GRIDS(J)%NY ) CYCLE
!
                  IF ( FLAGLL ) THEN
                      RX     = MOD (1080. + XA - GRIDS(J)%X0 , 360. ) &
                                   / GRIDS(J)%SX
                    ELSE
                      RX     = ( XA - GRIDS(J)%X0 ) / GRIDS(J)%SX
                    END IF
                  JX     = 1 + INT ( RX )
                  RX     = RX - REAL(JX-1)
                  IF ( .NOT. GRIDS(J)%ICLOSE.NE.ICLOSE_NONE ) THEN
                      IF ( JX.EQ.0 .AND. ABS(RX-1.).LT.0.05 ) THEN
                          JX     = 1
                          RX     = 0.
                        END IF
                      IF ( JX.EQ.GRIDS(J)%NX .AND.                    &
                                            ABS(RX).LT.0.05 ) THEN
                          JX     = JX - 1
                          RX     = 1.
                        END IF
                      IF ( JX.LT.1 .OR. JX.GE.GRIDS(J)%NX ) CYCLE
                    ELSE
                      JX     = 1 + MOD(JX-1,GRIDS(J)%NX)
                    END IF
!
! ... Check against MAPSTA
!
                  JX1    = JX
                  IF ( GRIDS(J)%ICLOSE.NE.ICLOSE_NONE ) THEN
                      JX2    = 1 + MOD(JX,GRIDS(J)%NX)
                    ELSE
                      JX2    = JX + 1
                    END IF
                  JY1    = JY
                  JY2    = JY + 1
!
                  FLAGOK = ( ABS(GRIDS(J)%MAPSTA(JY1,JX1)).GE.1 .OR.  &
                                 (1.-RX)*(1.-RY).LT.0.05 ) .AND.      &
                           ( ABS(GRIDS(J)%MAPSTA(JY1,JX2)).GE.1 .OR.  &
                                    RX  *(1.-RY).LT.0.05 ) .AND.      &
                           ( ABS(GRIDS(J)%MAPSTA(JY2,JX1)).GE.1 .OR.  &
                                 (1.-RX)*  RY   .LT.0.05 ) .AND.      &
                           ( ABS(GRIDS(J)%MAPSTA(JY2,JX2)).GE.1 .OR.  &
                                    RX  *  RY   .LT.0.05 ) 
!
                  IF ( .NOT.FLAGOK ) CYCLE
!
! ... We found interpolation data !
!
                  JS     = J
                  IBI    = IBI + 1
                  GRIDD(I,JS) = .TRUE.
!
                  XBPI(IBI)  = XA
                  YBPI(IBI)  = YA
                  ISBPI(IBI) = MAPFS(IY,IX)
!
                  TSTORE(IBI, 0) = JS
!
                  IF ( ABS(GRIDS(J)%MAPSTA(JY1,JX1)).GE.1 .AND.       &
                                (1.-RX)*(1.-RY).GT.0.05 ) THEN
                      RDBPI (IBI,1) = (1.-RX)*(1.-RY)
                      TSTORE(IBI,1) = GRIDS(J)%MAPFS(JY1,JX1)
                    ELSE
                      RDBPI (IBI,1) = 0.
                      TSTORE(IBI,1) = 0
                    END IF
                  IF ( ABS(GRIDS(J)%MAPSTA(JY1,JX2)).GE.1 .AND.       &
                                   RX  *(1.-RY).GT.0.05 ) THEN
                      RDBPI (IBI,2) = RX*(1.-RY)
                      TSTORE(IBI,2) = GRIDS(J)%MAPFS(JY1,JX2)
                    ELSE
                      RDBPI (IBI,2) = 0.
                      TSTORE(IBI,2) = 0
                    END IF
                  IF ( ABS(GRIDS(J)%MAPSTA(JY2,JX1)).GE.1 .AND.       &
                                (1.-RX)*  RY   .GT.0.05 ) THEN
                      RDBPI (IBI,3) = (1.-RX)*RY
                      TSTORE(IBI,3) = GRIDS(J)%MAPFS(JY2,JX1)
                    ELSE
                      RDBPI (IBI,3) = 0.
                      TSTORE(IBI,3) = 0
                    END IF
                  IF ( ABS(GRIDS(J)%MAPSTA(JY2,JX2)).GE.1 .AND.       &
                                   RX  *  RY   .GT.0.05 ) THEN
                      RDBPI (IBI,4) = RX*RY
                      TSTORE(IBI,4) = GRIDS(J)%MAPFS(JY2,JX2)
                    ELSE
                      RDBPI (IBI,4) = 0.
                      TSTORE(IBI,4) = 0
                    END IF
!
                  RDBPI(IBI,:) = RDBPI(IBI,:) / SUM(RDBPI(IBI,:))
!
                  EXIT
                  END DO
!
                IF ( JS.EQ.0 .AND. IMPROC.EQ.NMPERR )                 &
                                 WRITE (MDSE,1020) I, IX, IY, XA, YA
!
              END IF
            END DO
          END DO
!
! 2.d Error checks
!
        IF ( IBI .EQ. 0 ) THEN
            RFILE(I) = .TRUE.
            IF ( IMPROC .EQ. NMPERR ) WRITE (MDSE,1021)
            DEALLOCATE ( OUTPTS(I)%OUT5%IPBPI, OUTPTS(I)%OUT5%ISBPI,  &
                         OUTPTS(I)%OUT5%XBPI,  OUTPTS(I)%OUT5%YBPI,   &
                         OUTPTS(I)%OUT5%RDBPI )
            CYCLE
          ELSE IF ( IBI .NE. OUTPTS(I)%OUT5%NBI ) THEN
            CALL EXTCDE ( 1020 )
          ENDIF
!
! 2.e Sort spectra by grid, fill IPBPI, and get NBI2 and ....
!
        IPBPI  = 0
        NBI2   = 0
!
        DO J=1, NRGRD
          DO I1=1, NBI
            IF ( TSTORE(I1,0) .NE. J ) CYCLE
            DO J1=1, 4
              IF ( TSTORE(I1,J1).NE.0 .AND. IPBPI(I1,J1).EQ.0 ) THEN
                  NBI2         = NBI2 + 1
                  IPBPI(I1,J1) = NBI2
                  DO I2=I1, NBI
                    IF ( TSTORE(I2,0) .NE. J ) CYCLE
                    DO J2=1, 4
                      IF ( TSTORE(I2,J2) .EQ. TSTORE(I1,J1) )         &
                           IPBPI(I2,J2) = NBI2
                      END DO
                    END DO
                END IF
              END DO
            END DO
          END DO
!
! 2.f Set up spectral storage and cross-grid mapping
!
        CALL W3DMO5 ( I, MDSE, MDST, 3 )
!
        ALLOCATE ( MDATAS(I)%NBI2S(NBI2,2) )
        NBI2S  =>  MDATAS(I)%NBI2S
!
        DO I1=1, NBI
          DO J1=1, 4
            IF ( IPBPI(I1,J1) .NE. 0 ) THEN
                NBI2S(IPBPI(I1,J1),1) = TSTORE(I1,0)
                NBI2S(IPBPI(I1,J1),2) = TSTORE(I1,J1)
              END IF
            END DO
          END DO
!
        DO I1=1, NBI2
          NBI2G(I,NBI2S(I1,1)) = NBI2G(I,NBI2S(I1,1)) + 1
          END DO
!
! 2.g Test output
!
!/T1        WRITE (MDST,9023)
!/T1        DO J=1, NBI
!/T1          WRITE (MDST,9024) J, ISBPI(J), FACTOR*XBPI(J),          &
!/T1             FACTOR*YBPI(J), IPBPI(J,:), RDBPI(J,:), TSTORE(J,:)
!/T1          END DO
!
!/T2        WRITE (MDST,9025)
!/T2        DO J=1, NBI2
!/T2          WRITE (MDST,9026) J, NBI2S(J,:)
!/T2          END DO
!
!/T9        ALLOCATE ( TMAP(NX,NY) )
!
!/T9        DO IX=1, NX
!/T9          DO IY=1, NY
!/T9            IF ( ABS(MAPSTA(IY,IX)) .EQ. 0 ) then
!/T9                TMAP(IX,IY) = '/'
!/T9              ELSE IF ( ABS(MAPSTA(IY,IX)) .EQ. 1 ) then
!/T9                TMAP(IX,IY) = '-'
!/T9              ELSE IF ( ABS(MAPSTA(IY,IX)) .EQ. 2 ) then
!/T9                TMAP(IX,IY) = 'X'
!/T9              END IF
!/T9            END DO
!/T9          END DO
!
!/T9        DO J=1, NBI
!/T9          IX = MAPSF(ISBPI(J),1)
!/T9          IY = MAPSF(ISBPI(J),2)
!/T9          WRITE (TMAP(IX,IY),'(I1)') TSTORE(J,0)
!/T9          END DO
!
!/T9        DO J=1, 1+(NX-1)/130
!/T9          WRITE (MDST,9029) I, J
!/T9          DO IY=NY, 1, -1
!/T9            I1 = J*130-129
!/T9            I2 = MIN ( NX , J*130 )
!/T9            WRITE (MDST,'(1X,130A1)') TMAP(I1:I2,IY)
!/T9            END DO
!/T9          END DO
!
!/T9        DEALLOCATE ( TMAP )
!
        DEALLOCATE ( TSTORE )
!
        END DO
!
!/T      WRITE (MDST,9027)
!/T      DO I=1, NRGRD
!/T        WRITE (MDST,9028) OUTPTS(I)%OUT5%NBI, OUTPTS(I)%OUT5%NBI2, &
!/T                          RFILE(I), NBI2G(I,:)
!/T        END DO
!
! -------------------------------------------------------------------- /
! 3.  Finalyze grid dependencies in GRDLOW
! 3.a Get size of array and dimension
!
      JTOT   = 0
      DO I=1, NRGRD
        JS     = 0
        DO J=1, NRGRD
          IF ( GRIDD(I,J) ) JS = JS + 1
          END DO
        JTOT   = MAX ( JTOT , JS )
        END DO
!
      IF ( ALLOCATED(GRDLOW) ) DEALLOCATE ( GRDLOW )
      ALLOCATE ( GRDLOW(NRGRD,0:JTOT) )
      GRDLOW = 0
!
!/T      WRITE (MDST,9030) JTOT
!
! 3.b Fill array
!
      FLAGOK = .TRUE.
!
      DO I=1, NRGRD
        JTOT   = 0
        DO J=1, NRGRD
          IF ( GRIDD(I,J) ) THEN
              JTOT   = JTOT + 1
              GRDLOW(I,JTOT) = J
              IF ( GRIDS(J)%SX .LT. 0.99*GRIDS(I)%SX .OR.             &
                   GRIDS(J)%SY .LT. 0.99*GRIDS(I)%SY ) THEN
                  IF ( IMPROC.EQ.NMPERR ) WRITE (MDSE,1030)           &
                      J, GRANK(J), GRIDS(J)%SX, GRIDS(J)%SY,          &
                      I, GRANK(I), GRIDS(I)%SX, GRIDS(I)%SY
                  FLAGOK = .FALSE.
                END IF
            END IF
          END DO
        GRDLOW(I,0) = JTOT
        END DO
!
!/T      WRITE (MDST,9031)
!/T      DO I=1, NRGRD
!/T        WRITE (MDST,9032) I, GRDLOW(I,0:GRDLOW(I,0))
!/T        END DO
!
      IF ( .NOT. FLAGOK ) CALL EXTCDE ( 1030 )
!
! -------------------------------------------------------------------- /
! 4.  Finalyze grid dependencies in GRDHGH
! 4.a Get size of array and dimension
!
      JTOT   = 0
      DO I=1, NRGRD
        JS     = 0
        DO J=1, NRGRD
          IF ( GRIDD(J,I) ) JS = JS + 1
          END DO
        JTOT   = MAX ( JTOT , JS )
        END DO
!
      IF ( ALLOCATED(GRDHGH) ) DEALLOCATE ( GRDHGH )
      ALLOCATE ( GRDHGH(NRGRD,0:JTOT) )
      GRDHGH = 0
!
!/T      WRITE (MDST,9040) JTOT
!
! 4.b Fill array
!
      DO I=1, NRGRD
        JTOT   = 0
        DO J=1, NRGRD
          IF ( GRIDD(J,I) ) THEN
              JTOT   = JTOT + 1
              GRDHGH(I,JTOT) = J
            END IF
          END DO
        GRDHGH(I,0) = JTOT
        END DO
!
!/T      WRITE (MDST,9041)
!/T      DO I=1, NRGRD
!/T        WRITE (MDST,9042) I, GRDHGH(I,0:GRDHGH(I,0))
!/T        END DO
!
! -------------------------------------------------------------------- /
! 5.  Export file flags
!
      IF ( PRESENT(FLRBPI) ) FLRBPI = RFILE
!
      RETURN
!
! Formats
!
 1000 FORMAT (/' *** WAVEWATCH III ERROR IN WMGLOW : *** '/           &
               '     GRID NOT INITIALIZED, GRID NR',I4 /)
!
 1020 FORMAT (/' *** WAVEWATCH III ERROR IN WMGLOW : *** '/           &
               '     CANNOT FIND SOURCE FOR BOUNDARY DATA '/          &
               '     GRID, IX, IY, X, Y:',3I6,2E12.4/)
!
 1030 FORMAT (/' *** WAVEWATCH III ERROR IN WMGLOW : *** '/           &
               '     RANKS AND RESOLUTIONS INCONSISTENT'/             &
               '        GRID',I4,' RANK',I4,' RESOLUTION :',2E10.3/   &
               '        GRID',I4,' RANK',I4,' RESOLUTION :',2E10.3/)
!
 1021 FORMAT (/' *** WAVEWATCH III ERROR IN WMGLOW : *** '/           &
               '     NONE OF BOUNDARY POINTS CAN BE MAPPED'/          &
               '     READING FROM FILE INSTEAD'/)
!
!/T 9010 FORMAT ( ' TEST WMGLOW : ALL GRIDS INITIALIZED')
!
!/T 9020 FORMAT ( ' TEST WMGLOW : STARTING LOOP OVER GRIDS')
!/T 9021 FORMAT ( ' TEST WMGLOW : I, RANK, NBI :',2I4,I6)
!/T 9022 FORMAT ( '               ',A)
!/T1 9023 FORMAT (' TEST WMGLOW : POINT DATA ')
!/T1 9024 FORMAT (I5,I8,2F6.1,4I5,4F5.2,I3,4I8)
!/T2 9025 FORMAT (' TEST WMGLOW : NBI2S ')
!/T2 9026 FORMAT ('           ',2I4,2X,I8)
!/T 9027 FORMAT (' TEST WMGLOW : NBI, NBI2, RFILE, NBI2G ')
!/T 9028 FORMAT ('               ',2I5,L2,' : ',20I5)
!/T9 9029 FORMAT (' TEST WMGLOW : SOURCE MAP GRID',I3,'   PART',I3)
!
!/T 9030 FORMAT ( ' TEST WMGLOW : GRDLOW DIMENSIONED AT ',I2)
!/T 9031 FORMAT ( ' TEST WMGLOW : GRDLOW :')
!/T 9032 FORMAT ( '                 ',2i4,' : ',20I3)
!
!/T 9040 FORMAT ( ' TEST WMGLOW : GRDHGH DIMENSIONED AT ',I2)
!/T 9041 FORMAT ( ' TEST WMGLOW : GRDHGH :')
!/T 9042 FORMAT ( '                 ',2i4,' : ',20I3)
!/
!/ End of WMGLOW ----------------------------------------------------- /
!/
      END SUBROUTINE WMGLOW
!/ ------------------------------------------------------------------- /
      SUBROUTINE WMGHGH
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           H. L. Tolman            |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         23-Dec-2010 |
!/                  +-----------------------------------+
!/
!/    28-Dec-2005 : Origination.                        ( version 3.08 )
!/    09-Mar-2006 : Carry over land mask.               ( version 3.09 )
!/    28-Dec-2006 : Simplify NIT for partial comm.      ( version 3.10 )
!/    07-Feb-2007 : Setting FLAGST.                     ( version 3.10 )
!/    20-May-2009 : Linking FLAGST and FLGHG1.          ( version 3.14 )
!/    26-May-2009 : Fix erroneous cyclic updating.      ( version 3.14 )
!/    30-Oct-2009 : Implement run-time grid selection.  ( version 3.14 )
!/                  (W. E. Rogers & T. J. Campbell, NRL)
!/    23-Dec-2010 : Fix HPFAC and HQFAC by including the COS(YGRD)
!/                  factor with DXDP and DXDQ terms.    ( version 3.14 )
!/                  (T. J. Campbell, NRL)
!/    07-Jul-2011 : Bug fix for IX bounds with wrapping ( version 3.14+)
!/                  grids (see use of "IDSTLA" below)
!/                  (W. E. Rogers, NRL)
!/
!  1. Purpose :
!
!     Determine relation to higher ranked grids for each grid.
!     Base map set in WMGLOW, supplemental data computed here.
!
!  2. Method :
!
!     Map averaging information for higher ranked grid to lower
!     ranked grid.
!
!  3. Parameters :
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      W3SETO, W3SETG, W3DMO5, WMSETM
!                Subr. W3xDATMD Manage data structures.
!      STRACE    Sur.  W3SERVMD Subroutine tracing.
!      EXTCDE    Sur.    Id.    Program abort.
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!      - Note that the map of distances to the boundary does not
!        need to be an accurate characteristc distance. More important
!        is that it is 'save' and quick to compute. Hence the local
!        increment solution only.
!
!  8. Structure :
!
!     See source code.
!
!  9. Switches :
!
!     !/SHRD Distributed memory approach
!     !/DIST
!
!     !/PRn  propagation scheme.
!
!     !/S    Enable subroutine tracing.
!     !/T    Enable test output.
!     !/T3   Test output for received spectra.
!     !/T4   Test output for sent spectra.
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!
      USE CONSTANTS
      USE W3SERVMD, ONLY: EXTCDE
!/S      USE W3SERVMD, ONLY: STRACE
!
      USE W3GDATMD
      USE W3ODATMD
      USE WMMDATMD
!
      IMPLICIT NONE
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      INTEGER                 :: I, IJ, IX, IY, J, JJ, IB, ISEA,      &
                                 JSEA, IXLA, IXHA, IYLA, IYHA,        &
                                 JX, JY, JXL, JXH, JYL, JYH, NIT,     &
                                 NRTOT, NROK, NR0, NR1, NR2, NRL,     &
                                 JF, JR, NLMAX, NLOC, ISPROC, ISPRO2, &
                                 IREC, ISND, IDSTLA, IDSTHA
!/DIST      INTEGER                 :: LTAG0
!/S      INTEGER, SAVE           :: IENT = 0
      INTEGER, ALLOCATABLE    :: IXL(:), IXH(:), IYL(:), IYH(:),      &
                                 MAPTST(:,:), TMPINT(:,:),            &
                                 I1(:,:), I2(:,:), I3(:), I4(:),      &
                                 INFLND(:,:)
!/DIST      INTEGER, ALLOCATABLE    :: LTAG(:)
      REAL                    :: FACTOR, STX, STY, STXY, NEWVAL,      &
                                 XL, XH, YL, YH, XA, YA, DXC, JD,     &
                                 WX, WY, WTOT
      REAL, ALLOCATABLE       :: BDIST(:), TMPRL(:,:)
      LOGICAL                 :: CHANGD, FLGREC
      LOGICAL, ALLOCATABLE    :: CHANGE(:,:), GRIDOK(:),              &
                                 STMASK(:,:), MASKI(:,:), TMPLOG(:)
!/T      CHARACTER(LEN=1), ALLOCATABLE :: MAPST(:,:)
!/
!/S      CALL STRACE (IENT, 'WMGHGH')
!
! -------------------------------------------------------------------- /
! 0.  Initializations / tests
!
      IF ( GTYPE .EQ. CLGTYPE .AND. NRGRD .GT. 1 ) THEN
          WRITE (MDSE,'(/2A)') ' *** ERROR WMGHGH: ', &
          'CURVILINEAR GRID SUPPORT NOT IMPLEMENTED FOR NRGRD > 1 ***'
          CALL EXTCDE ( 999 )
        END IF
      IF ( GTYPE .EQ. UNGTYPE ) THEN
          WRITE (MDSE,'(/2A)') ' *** ERROR WMGHGH: ', &
          'UNSTRUCTURED GRID SUPPORT NOT YET IMPLEMENTED ***'
          CALL EXTCDE ( 999 )
        END IF
!
      IF ( .NOT. ALLOCATED(GRDHGH) ) THEN
          IF ( IMPROC.EQ.NMPERR ) WRITE(MDSE,1000)
          CALL EXTCDE (1000)
        END IF
!
      DO I=1, NRGRD
        DO J=1, NRGRD
            IF ( HGSTGE(I,J)%INIT ) THEN
                IF ( HGSTGE(I,J)%NREC .NE. 0 ) DEALLOCATE             &
                           ( HGSTGE(I,J)%LJSEA , HGSTGE(I,J)%NRAVG,   &
                             HGSTGE(I,J)%IMPSRC, HGSTGE(I,J)%ITAG ,   &
                             HGSTGE(I,J)%WGTH  , HGSTGE(I,J)%SHGH )
                IF ( HGSTGE(I,J)%NSND .NE. 0 ) DEALLOCATE             &
                           ( HGSTGE(I,J)%ISEND )
                HGSTGE(I,J)%NTOT = 0
                HGSTGE(I,J)%NREC = 0
                HGSTGE(I,J)%NRC1 = 0
                HGSTGE(I,J)%NSND = 0
                HGSTGE(I,J)%NSN1 = 0
                HGSTGE(I,J)%NSMX = 0
                HGSTGE(I,J)%INIT = .FALSE.
              END IF
          END DO
        END DO
!
! -------------------------------------------------------------------- /
! 1.  Set boundary distance maps
! 1.a Check if needed
!
      IF ( .NOT. FLGBDI ) THEN
!
          IF ( FLAGLL ) THEN
              FACTOR = RADIUS / 360.
            ELSE
              FACTOR = 1.
            END IF
!
!/T          WRITE (MDST,9010)
!
! 1.b Loop over grids
!
          DO I=1, NRGRD
            CALL W3SETO ( I, MDSE, MDST )
            CALL W3SETG ( I, MDSE, MDST )
            CALL WMSETM ( I, MDSE, MDST )
!
!/T            WRITE (MDST,9011) I, GRANK(I), NBI
!
! 1.c Not needed (test output only)
!
            IF ( GRANK(I) .EQ. 1 ) THEN
!
!/T                WRITE (MDST,9012)
!
! 1.d Inconsistend RANK vs NBI (error message)
!
              ELSE IF ( NBI .EQ. 0 ) THEN
                IF ( IMPROC.EQ.NMPERR ) WRITE (MDSE,1010)
                CALL EXTCDE (1010)
!
! 1.e Generate map
!
              ELSE
                ALLOCATE ( MDATAS(I)%MAPBDI(NY,NX) )
                MAPBDI => MDATAS(I)%MAPBDI
                DO IX=1, NX
                  DO IY=1, NY
                    IF ( MAPSTA(IY,IX) .EQ. 0 ) THEN
                        MAPBDI(IY,IX) = -1. / DTMAX
                      ELSE IF ( ABS(MAPSTA(IY,IX)) .EQ. 2 ) THEN
                        MAPBDI(IY,IX) =  0.
                      ELSE
                        MAPBDI(IY,IX) = -2. 
                      END IF
                    END DO
                  END DO
!
                ALLOCATE ( CHANGE(NY,NX) )
!
                DO
!
                  CHANGE = .FALSE.
!
                  DO IX=2, NX-1
                    DO IY=2, NY-1
                      IF ( MAPBDI(IY,IX) .EQ. -2. .AND. (             &
                           MAPBDI(IY+1,IX  ) .GE. 0. .OR.             &
                           MAPBDI(IY-1,IX  ) .GE. 0. .OR.             &
                           MAPBDI(IY  ,IX+1) .GE. 0. .OR.             &
                           MAPBDI(IY  ,IX-1) .GE. 0. .OR.             &
                         ( MAPBDI(IY+1,IX+1) .GE. 0. .AND. .NOT.      &
                         ( MAPSTA(IY+1,IX  ) .LE. 0 .AND.             &
                           MAPSTA(IY  ,IX+1) .LE. 0 ) ) .OR.          &
                         ( MAPBDI(IY+1,IX-1) .GE. 0. .AND. .NOT.      &
                         ( MAPSTA(IY+1,IX  ) .LE. 0 .AND.             &
                           MAPSTA(IY  ,IX-1) .LE. 0 ) ) .OR.          &
                         ( MAPBDI(IY-1,IX-1) .GE. 0. .AND. .NOT.      &
                         ( MAPSTA(IY-1,IX  ) .LE. 0 .AND.             &
                           MAPSTA(IY  ,IX-1) .LE. 0 ) ) .OR.          &
                         ( MAPBDI(IY-1,IX+1) .GE. 0. .AND. .NOT.      &
                         ( MAPSTA(IY-1,IX  ) .LE. 0 .AND.             &
                           MAPSTA(IY  ,IX+1) .LE. 0 ) ) ) )           &
                          CHANGE(IY,IX) = .TRUE.
                      END DO
                    END DO
!
                  CHANGD = .FALSE.
                  DO IY=2, NY-1
                    DO IX=2, NX-1
                      ISEA   = MAPFS(IY,IX)
                      STY    = FACTOR * HQFAC(IY,IX) / ( 0.58 * GRAV )
                      STX    = FACTOR * HPFAC(IY,IX) &
                                                     / ( 0.58 * GRAV )
                      STXY   = SQRT ( STX**2 + STY**2 )
                      IF ( CHANGE(IY,IX) ) THEN
                          NEWVAL = 9.99E33
                          IF ( MAPBDI(IY+1,IX  ).GE.0. .AND. .NOT.    &
                               CHANGE(IY+1,IX  ) ) NEWVAL = MIN (     &
                               NEWVAL , MAPBDI(IY+1,IX  )+STY )
                          IF ( MAPBDI(IY-1,IX  ).GE.0. .AND. .NOT.    &
                               CHANGE(IY-1,IX  ) ) NEWVAL = MIN (     &
                               NEWVAL , MAPBDI(IY-1,IX  )+STY )
                          IF ( MAPBDI(IY  ,IX+1).GE.0. .AND. .NOT.    &
                               CHANGE(IY  ,IX+1) ) NEWVAL = MIN (     &
                               NEWVAL , MAPBDI(IY  ,IX+1)+STX)
                          IF ( MAPBDI(IY  ,IX-1).GE.0. .AND. .NOT.    &
                               CHANGE(IY  ,IX-1) ) NEWVAL = MIN (     &
                               NEWVAL , MAPBDI(IY  ,IX-1)+STX)
                          IF ( MAPBDI(IY+1,IX+1).GE.0. .AND. .NOT.    &
                             ( MAPSTA(IY+1,IX  ) .LE. 0 .AND.         &
                               MAPSTA(IY  ,IX+1) .LE. 0 ) ) NEWVAL =  &
                               MIN ( NEWVAL , MAPBDI(IY+1,IX+1)+STXY)
                          IF ( MAPBDI(IY+1,IX-1).GE.0. .AND. .NOT.    &
                             ( MAPSTA(IY+1,IX  ) .LE. 0 .AND.         &
                               MAPSTA(IY  ,IX-1) .LE. 0 ) ) NEWVAL =  &
                               MIN ( NEWVAL , MAPBDI(IY+1,IX-1)+STXY)
                          IF ( MAPBDI(IY-1,IX-1).GE.0. .AND. .NOT.    &
                             ( MAPSTA(IY-1,IX  ) .LE. 0 .AND.         &
                               MAPSTA(IY  ,IX-1) .LE. 0 ) ) NEWVAL =  &
                               MIN ( NEWVAL , MAPBDI(IY-1,IX-1)+STXY)
                          IF ( MAPBDI(IY-1,IX+1).GE.0. .AND. .NOT.    &
                             ( MAPSTA(IY-1,IX  ) .LE. 0 .AND.         &
                               MAPSTA(IY  ,IX+1) .LE. 0 ) ) NEWVAL =  &
                               MIN ( NEWVAL , MAPBDI(IY-1,IX+1)+STXY)
                          MAPBDI(IY,IX) = NEWVAL
                          CHANGD = .TRUE.
                        END IF
                      END DO
                    END DO
!
                  IF ( .NOT. CHANGD ) EXIT
                  END DO
!
                DEALLOCATE ( CHANGE )
!
! 1.f Test output
!
!/T                WRITE (MDST,9013)
!/T                DO IY=NY,1 , -1
!/T                  WRITE (MDST,9014) NINT(MAPBDI(IY,:)*SIG(1)/DTMAX)
!/T                  END DO
!
              END IF
            END DO
          FLGBDI = .TRUE.
        END IF
!
! -------------------------------------------------------------------- /
! 2.  Data sources for reconcilliation
! 2.a Loop over grids, processing check
!
      ALLOCATE ( I1(NRGRD,NMPROC), I2(NRGRD,NMPROC),                  &
                 I3(NRGRD), I4(NRGRD) )
!/DIST      LTAG0  = 0
!
      DO I=1, NRGRD
!/T        WRITE (MDST,9020) I, GRDHGH(I,0)
!
        IF ( GRDHGH(I,0) .EQ. 0 ) THEN
!/T            WRITE (MDST,9021)
          ELSE
!
! 2.b Process grid
! 2.b.1 Preparations
!
            CALL W3SETO ( I, MDSE, MDST )
            CALL W3SETG ( I, MDSE, MDST )
            CALL WMSETM ( I, MDSE, MDST )
!
            ALLOCATE ( MAPTST(NY,NX), INFLND(NY,NX) )
            MAPTST = 0
            INFLND = 0
!
! 2.b.2 Find points used for boundary data in higher ranked grids
!
            DO JJ=1, GRDHGH(I,0)
              J      = GRDHGH(I,JJ)
              DO IB=1, SIZE(MDATAS(J)%NBI2S(:,1))
                IF ( MDATAS(J)%NBI2S(IB,1) .EQ. I ) THEN
                    IX     = MAPSF(MDATAS(J)%NBI2S(IB,2),1)
                    IY     = MAPSF(MDATAS(J)%NBI2S(IB,2),2)
                    MAPTST(IY,IX) = - J
                  END IF
                END DO
              END DO
!
! 2.b.3 Range of coverage per grid
!
            ALLOCATE ( IXL(GRDHGH(I,0)), IXH(GRDHGH(I,0)),            &
                       IYL(GRDHGH(I,0)), IYH(GRDHGH(I,0)),            &
                       GRIDOK(GRDHGH(I,0)), BDIST(GRDHGH(I,0)) )
!
            DO JJ=1, GRDHGH(I,0)
              J      = GRDHGH(I,JJ)
!
!       Notes: outer edges already taken off here ...
!              will not work in a simple way for spherical grids,
!              so we don't even try ....
!
              XL     = GRIDS(J)%X0 + 0.5 * GRIDS(J)%SX
              XH     = GRIDS(J)%X0 + ( REAL(GRIDS(J)%NX) - 1.5 )      &
                                         * GRIDS(J)%SX
              YL     = GRIDS(J)%Y0 + 0.5 * GRIDS(J)%SY
              YH     = GRIDS(J)%Y0 + ( REAL(GRIDS(J)%NY) - 1.5 )      &
                                         * GRIDS(J)%SY
!
              IF ( FLAGLL ) THEN
                  IXL(JJ) = 1
                  IXH(JJ) = NX
                ELSE
                  IXL(JJ) = 2 + INT( (XL-X0)/SX + 0.49 )
                  IXH(JJ) = 1 + INT( (XH-X0)/SX - 0.49 )
                END IF
              IYL(JJ) = 2 + INT( (YL-Y0)/SY + 0.49 )
              IYH(JJ) = 1 + INT( (YH-Y0)/SY - 0.49 )
!
              IXL(JJ) = MAX (  1 , IXL(JJ) )
              IXH(JJ) = MIN ( NX , IXH(JJ) )
              IYL(JJ) = MAX (  1 , IYL(JJ) )
              IYH(JJ) = MIN ( NY , IYH(JJ) )
!
!/T              WRITE (MDST,9022) J, IXL(JJ),IXH(JJ), IYL(JJ),IYH(JJ)
!
              END DO
!
            IXLA   = MINVAL(IXL)
            IXHA   = MAXVAL(IXH)
            IYLA   = MINVAL(IYL)
            IYHA   = MAXVAL(IYH)
!
! 2.b.4 Point by point check
!
            NLMAX  = 0
            DO JJ=1, GRDHGH(I,0)
              J      = GRDHGH(I,JJ)
              NLMAX  = MAX ( NLMAX , (2+INT(SX/GRIDS(J)%SX+0.001)) *  &
                                     (2+INT(SY/GRIDS(J)%SY+0.001)) )
              END DO
!
            NRTOT  = 0
            ALLOCATE ( TMPINT(NX*NY,-4:NLMAX), TMPRL(NX*NY,0:NLMAX),  &
                       TMPLOG(NX*NY) )
!
!/DIST            ALLOCATE ( LTAG(NLMAX) )
!/DIST            DO J=1, NLMAX
!/DIST              LTAG(J) = J + LTAG0
!/DIST              END DO
!
            DO IY=1, NY
              IF ( IY.LT.IYLA .OR. IY.GT.IYHA ) CYCLE
              YA     = Y0 + REAL(IY-1)*SY
!
              DO IX=1, NX
                IF ( IX.LT.IXLA .OR. IX.GT.IXHA ) CYCLE
                IF ( ABS(MAPSTA(IY,IX)) .NE. 1 ) CYCLE
                IF ( MAPTST(IY,IX) .LT. 0 ) CYCLE
                XA     = X0 + REAL(IX-1)*SX
!
                NROK   = 0
                DO JJ=1, GRDHGH(I,0)
                  J      = GRDHGH(I,JJ)
!
!       Note for LLG: Assumption is made that the higher ranked grid
!                     cannot be global.
!
                  IF ( FLAGLL ) THEN
                      DXC    = MOD ( 1080.+XA-GRIDS(J)%X0 , 360. )
                      XL     = 1. + (DXC-0.5*SX)/GRIDS(J)%SX
                      XH     = 1. + (DXC+0.5*SX)/GRIDS(J)%SX
                    ELSE
                      XL     = 1. + (XA-GRIDS(J)%X0-0.5*SX)/GRIDS(J)%SX
                      XH     = 1. + (XA-GRIDS(J)%X0+0.5*SX)/GRIDS(J)%SX
                    END IF
                  YL     = 1. + (YA-GRIDS(J)%Y0-0.5*SY)/GRIDS(J)%SY
                  YH     = 1. + (YA-GRIDS(J)%Y0+0.5*SY)/GRIDS(J)%SY
!
                  JXL    = NINT(XL+0.01)
                  JXH    = NINT(XH-0.01)
                  JYL    = NINT(YL+0.01)
                  JYH    = NINT(YH-0.01)
!
                  IF ( JXL.LT.1 .OR. JXH.GT.GRIDS(J)%NX .OR.          &
                       JYL.LT.1 .OR. JYH.GT.GRIDS(J)%NY ) THEN
                      GRIDOK(JJ) = .FALSE.
                      CYCLE
                    END IF
!
                  NR0    = 0
                  NRL    = 0
                  NR1    = 0
                  NR2    = 0
!
                  BDIST(JJ) = 9.99E33
!
                  DO JX=JXL, JXH
                    DO JY=JYL, JYH
                      IF (GRIDS(J)%MAPSTA(JY,JX).EQ.0) THEN
                          NR0    = NR0 + 1
                          IF (GRIDS(J)%MAPST2(JY,JX).EQ.0) NRL = NRL + 1
                        ELSE IF (ABS(GRIDS(J)%MAPSTA(JY,JX)).EQ.1) THEN
                          NR1    = NR1 + 1
                          BDIST(JJ) = MIN ( BDIST(JJ) ,               &
                                            MDATAS(J)%MAPBDI(JY,JX) )
                        ELSE IF (ABS(GRIDS(J)%MAPSTA(JY,JX)).EQ.2) THEN
                          NR2    = NR2 + 1
                        END IF
                      END DO
                    END DO
!
                  IF ( NRL .GT. (NR0+NR1+NR2)/2 ) THEN
                      INFLND(IY,IX) = 1
                    ELSE
                      GRIDOK(JJ) = NR1.GT.0 .AND. NR2.EQ.0
                      IF ( GRIDOK(JJ) ) NROK = NROK + 1
                    END IF
!
                  END DO
!
                IF ( NROK .EQ. 0 ) THEN
                    CYCLE
                  ELSE
                    INFLND(IY,IX) = 0
                  END IF
!
! 2.b.5 Select source grid
!
                JF     = 0
!
                DO JJ=1, GRDHGH(I,0)
                  J      = GRDHGH(I,JJ)
                  IF ( GRIDOK(JJ) ) THEN
                      IF ( JF .EQ. 0 ) THEN
                          JF     = J
                          JR     = GRANK(J)
                          JD     = BDIST(JJ)
                        ELSE
                          IF ( GRANK(J) .NE. JR ) EXIT
                          IF ( BDIST(JJ) .GT. JD ) THEN
                              JF     = J
                              JD     = BDIST(JJ)
                            END IF
                        END IF
                    END IF
                  END DO
!
                MAPTST(IY,IX) = JF
!
! 2.b.6 Store data (temp)
!
                NRTOT  = NRTOT + 1
                TMPINT(NRTOT,-4) = IX
                TMPINT(NRTOT,-3) = IY
                TMPINT(NRTOT,-2) = MAPFS(IY,IX)
                TMPINT(NRTOT,-1) = JF
                TMPRL (NRTOT, 0) = JD * SIG(1) / DTMAX
!
                IF ( FLAGLL ) THEN
                    DXC    = MOD ( 1080.+XA-GRIDS(JF)%X0 , 360. )
                    XL     = 1. + (DXC-0.5*SX)/GRIDS(JF)%SX
                    XH     = 1. + (DXC+0.5*SX)/GRIDS(JF)%SX
                  ELSE
                    XL     = 1. + (XA-GRIDS(JF)%X0-0.5*SX)/GRIDS(JF)%SX
                    XH     = 1. + (XA-GRIDS(JF)%X0+0.5*SX)/GRIDS(JF)%SX
                  END IF
                YL     = 1. + (YA-GRIDS(JF)%Y0-0.5*SY)/GRIDS(JF)%SY
                YH     = 1. + (YA-GRIDS(JF)%Y0+0.5*SY)/GRIDS(JF)%SY
!
                JXL    = NINT(XL+0.01)
                JXH    = NINT(XH-0.01)
                JYL    = NINT(YL+0.01)
                JYH    = NINT(YH-0.01)
!
                WTOT   = 0.
                NLOC   = 0
                DO JX=JXL, JXH
                  WX     = MIN(XH,REAL(JX)+0.5) - MAX(XL,REAL(JX)-0.5)
                  DO JY=JYL, JYH
                    IF (ABS(GRIDS(JF)%MAPSTA(JY,JX)).EQ.1) THEN
                        WY     = MIN(YH,REAL(JY)+0.5) -               &
                                 MAX(YL,REAL(JY)-0.5)
                        WTOT   = WTOT + WX*WY
                        NLOC   = NLOC + 1
                        IF ( NLOC .GT. NLMAX ) THEN
                            IF ( IMPROC.EQ.NMPERR ) WRITE (MDSE,1020)
                            CALL EXTCDE(1020)
                          END IF
                        TMPINT(NRTOT,NLOC) = GRIDS(JF)%MAPFS(JY,JX)
                        TMPRL (NRTOT,NLOC) = WX*WY
                      END IF
                    END DO
                  END DO
                TMPINT(NRTOT,0) = NLOC
                TMPRL (NRTOT,1:NLOC) = TMPRL(NRTOT,1:NLOC) / WTOT
!
                NROK   = 0
!
                END DO
              END DO
!
!/T            WRITE (MDST,9023) I, NRTOT
!
! 2.c Set up masks based on stencil width of scheme and inferred land
! 2.c.1 Inferred land
!
            MAPST2 = MAPST2 - 4*MOD(MAPST2/4,2)
            MAPST2 = MAPST2 + 4*INFLND
            DO IX=1, NX
              DO IY=1, NY
                IF ( MAPST2(IY,IX).GT.0 ) MAPSTA(IY,IX) =             &
                                    - ABS(MAPSTA(IY,IX))
                END DO
              END DO
!
! 2.c.2 Masking
!
            ALLOCATE ( STMASK(NY,0:NX+1), MASKI(NY,NX) )
            IF ( MDATAS(I)%MSKINI ) DEALLOCATE ( MDATAS(I)%MAPMSK )
            ALLOCATE ( MDATAS(I)%MAPMSK(NY,NX) )
            MAPMSK => MDATAS(I)%MAPMSK
            MDATAS(I)%MSKINI = .TRUE.
!
            MAPMSK = MOD(MAPST2/8,2)
            MAPST2 = MAPST2 - 8*MAPMSK
!
            STMASK(:,1:NX) = MAPTST .LT. 0
            STMASK(:,0) = STMASK(:,NX)
            STMASK(:,NX+1) = STMASK(:,1)
!/PR0            NIT    = 0
!/PR1            NIT    = ( 1 + INT(DTMAX/DTCFL-0.001) ) * 1
!/PR2            NIT    = ( 1 + INT(DTMAX/DTCFL-0.001) ) * 3
!/PR3            NIT    = ( 1 + INT(DTMAX/DTCFL-0.001) ) * 3
!

            IDSTLA=2
            IDSTHA=NX-1
!...........notes: bug fix: in official release 3.14, the if-then and 
!..................do loop below was missing. 
            IF ( ICLOSE.NE.ICLOSE_NONE ) THEN
               IDSTLA=1
               IDSTHA=NX
            ENDIF

            DO J=1, NIT
              MASKI  = .FALSE.
              DO IX=IDSTLA,IDSTHA
                DO IY=2, NY-1
                  IF ( .NOT. STMASK(IY,IX) .AND. (                    &
                      STMASK(IY+1,IX+1) .OR.  STMASK(IY+1,IX  ) .OR.  &
                      STMASK(IY+1,IX-1) .OR.  STMASK(IY  ,IX-1) .OR.  &
                      STMASK(IY-1,IX-1) .OR.  STMASK(IY-1,IX  ) .OR.  &
                      STMASK(IY-1,IX+1) .OR.  STMASK(IY  ,IX+1) ) )   &
                          MASKI(IY,IX) = .TRUE.
                  END DO
                END DO
                STMASK(:,1:NX) = STMASK(:,1:NX) .OR. MASKI
                STMASK(:,0) = STMASK(:,NX)
                STMASK(:,NX+1) = STMASK(:,1)
              END DO
!
            DO J=1, NRTOT
              IX     = TMPINT(J,-4)
              IY     = TMPINT(J,-3)
              TMPLOG(J) = STMASK(IY,IX)
              IF ( .NOT. STMASK(IY,IX) ) THEN
                  MAPMSK(IY,IX) = 1
                  IF ( FLGHG1 ) MAPSTA(IY,IX) = -ABS(MAPSTA(IY,IX))
                  MAPTST(IY,IX) = 99
                END IF
              END DO
!
            IF ( FLGHG1 ) MAPST2 = MAPST2 + 8*MAPMSK
!
            DEALLOCATE ( STMASK, MASKI )
!
! 2.d Set up mapping for staging data
! 2.d.1 Set counters / required array sizes
!
!/SHRD            ISPROC = 1
!/SHRD            ISPRO2 = 1
            I1     = 0
            I2     = 0
            I3     = 0
            I4     = 0
!
            DO J=1, NRTOT
!
              JJ     = TMPINT(J,-1)
              HGSTGE(I,JJ)%NTOT = HGSTGE(I,JJ)%NTOT + 1
              ISEA   = TMPINT(J,-2)
!/DIST              JSEA   = 1 + (ISEA-1)/NAPROC
!/DIST              ISPROC = ISEA - (JSEA-1)*NAPROC + CROOT - 1
!
              I1(JJ,ISPROC) = I1(JJ,ISPROC) + 1
              IF ( TMPLOG(J) ) I2(JJ,ISPROC) = I2(JJ,ISPROC) + 1
              IF ( IMPROC .EQ. ISPROC ) THEN
                  HGSTGE(I,JJ)%NSMX = MAX(HGSTGE(I,JJ)%NSMX,TMPINT(J,0))
                END IF
!
              DO JR=1, TMPINT(J,0)
                ISEA   = TMPINT(J,JR)
!/DIST                JSEA   = 1 + (ISEA-1)/OUTPTS(JJ)%NAPROC
!/DIST                ISPRO2 = ISEA - (JSEA-1)*OUTPTS(JJ)%NAPROC +    &
!/DIST                                MDATAS(JJ)%CROOT - 1
                IF ( ISPRO2 .EQ. IMPROC ) THEN
                    HGSTGE(I,JJ)%NSND = HGSTGE(I,JJ)%NSND + 1
                    IF ( TMPLOG(J) ) HGSTGE(I,JJ)%NSN1 =              &
                                        HGSTGE(I,JJ)%NSN1 + 1
                  END IF
                END DO
!
              END DO
!
            HGSTGE(I,:)%NREC = I1(:,IMPROC)
            HGSTGE(I,:)%NRC1 = I2(:,IMPROC)
!
! 2.d.2 Allocate (deallocate in section 0 as needed)
!
            DO J=1, NRGRD
              IF ( HGSTGE(I,J)%NREC .GT. 0 ) THEN
                  ALLOCATE ( HGSTGE(I,J)%LJSEA (HGSTGE(I,J)%NREC),    &
                             HGSTGE(I,J)%NRAVG (HGSTGE(I,J)%NREC),    &
                             HGSTGE(I,J)%IMPSRC(HGSTGE(I,J)%NREC,     &
                                                HGSTGE(I,J)%NSMX),    &
                             HGSTGE(I,J)%ITAG  (HGSTGE(I,J)%NREC,     &
                                                HGSTGE(I,J)%NSMX),    &
                             HGSTGE(I,J)%WGTH  (HGSTGE(I,J)%NREC,     &
                                                HGSTGE(I,J)%NSMX),    &
                             HGSTGE(I,J)%SHGH  (SGRDS(J)%NSPEC,       &
                                                HGSTGE(I,J)%NSMX,     &
                                                HGSTGE(I,J)%NREC) )
!/T3                  HGSTGE(I,J)%LJSEA  = -1
!/T3                  HGSTGE(I,J)%NRAVG  = -1
!/T3                  HGSTGE(I,J)%IMPSRC = -1
!/T3                  HGSTGE(I,J)%ITAG   = -1
!/T3                  HGSTGE(I,J)%WGTH   = -1.
                END IF
              IF ( HGSTGE(I,J)%NSND .GT. 0 ) THEN
                  ALLOCATE ( HGSTGE(I,J)%ISEND (HGSTGE(I,J)%NSND,5) )
!/T4                  HGSTGE(I,J)%ISEND = -1
                END IF
              HGSTGE(I,J)%INIT = .TRUE.
              END DO
!
! 2.d.3 Fill allocated arrays
!
            FLGREC = .TRUE.
            I2     = I1 + 1
            I1     = 0
            I4     = HGSTGE(I,:)%NSND + 1
            I3     = 0
!
            DO J=1, NRTOT
!
              ISEA   = TMPINT(J,-2)
              JJ     = TMPINT(J,-1)
              NR0    = TMPINT(J, 0)
!/SHRD              JSEA   = ISEA
!/DIST              JSEA   = 1 + (ISEA-1)/NAPROC
!/DIST              ISPROC = ISEA - (JSEA-1)*NAPROC + CROOT - 1
!/DIST              FLGREC = ISPROC .EQ. IMPROC
!
              IF ( TMPLOG(J) ) THEN
                  I1(JJ,ISPROC) = I1(JJ,ISPROC) + 1
                  IREC          = I1(JJ,ISPROC)
                ELSE
                  I2(JJ,ISPROC) = I2(JJ,ISPROC) - 1
                  IREC          = I2(JJ,ISPROC)
                END IF
!
              IF ( FLGREC ) THEN
                  HGSTGE(I,JJ)%LJSEA(IREC) = JSEA
                  HGSTGE(I,JJ)%NRAVG(IREC) = NR0
                  HGSTGE(I,JJ)%WGTH(IREC,:NR0) = TMPRL(J,1:NR0)
!/DIST                  HGSTGE(I,JJ)%ITAG(IREC,:NR0) = LTAG(:NR0)
                END IF
!
              DO IJ=1, NR0
!
                ISEA   = TMPINT(J,IJ)
!/SHRD                JSEA   = ISEA
!/DIST                JSEA   = 1 + (ISEA-1)/OUTPTS(JJ)%NAPROC
!/DIST                ISPRO2 = ISEA - (JSEA-1)*OUTPTS(JJ)%NAPROC      &
!/DIST                              + MDATAS(JJ)%CROOT - 1
!
                IF ( FLGREC ) HGSTGE(I,JJ)%IMPSRC(IREC,IJ) = ISPRO2
!
                IF ( ISPRO2 .EQ. IMPROC ) THEN
                    IF ( TMPLOG(J) ) THEN
                        I3(JJ) = I3(JJ) + 1
                        ISND   = I3(JJ)
                      ELSE
                        I4(JJ) = I4(JJ) - 1
                        ISND   = I4(JJ)
                      END IF
                  HGSTGE(I,JJ)%ISEND(ISND,1) = JSEA
!/DIST                  HGSTGE(I,JJ)%ISEND(ISND,2) = ISPROC
                  HGSTGE(I,JJ)%ISEND(ISND,3) = IREC
                  HGSTGE(I,JJ)%ISEND(ISND,4) = IJ
!/DIST                  HGSTGE(I,JJ)%ISEND(ISND,5) = LTAG(IJ)
                  END IF
!
                END DO
!
!/DIST              LTAG   = LTAG + NR0
!/DIST              LTAG0  = LTAG0 + NR0
!
              END DO
!
! 2.e Adjust FLAGST using MAPTST
!
!/T            ALLOCATE ( MAPST(NY,NX) )
!/T            MAPST  = '-'
!
            DO ISEA=1, NSEA
              IX     = MAPSF(ISEA,1)
              IY     = MAPSF(ISEA,2)
              IF ( MAPTST(IY,IX) .GT. 0 ) FLAGST(ISEA) = .NOT. FLGHG1
!/T              IF ( FLAGST(ISEA) ) THEN
!/T                  MAPST(IY,IX)  = 'O'
!/T                ELSE
!/T                  MAPST(IY,IX)  = 'X'
!/T                END IF
              END DO
!
! 2.f Test output map
!
!/T            WRITE (MDST,9025) 'MAPTST'
!/T            DO IY=NY,1 , -1
!/T              WRITE (MDST,9026) MAPTST(IY,:) + 88*INFLND(IY,:)
!/T              END DO
!
!/T            WRITE (MDST,9025) 'MAPSTA'
!/T            DO IY=NY,1 , -1
!/T              WRITE (MDST,9026) MAPSTA(IY,:)
!/T              END DO
!
!/T            WRITE (MDST,9025) 'MAPST2'
!/T            DO IY=NY,1 , -1
!/T              WRITE (MDST,9026) MAPST2(IY,:)
!/T              END DO
!
!/T            WRITE (MDST,9025) 'FLAGST'
!/T            DO IY=NY,1 , -1
!/T              WRITE (MDST,9027) MAPST(IY,:)
!/T              END DO
!
            DEALLOCATE ( MAPTST, INFLND )
!/T            DEALLOCATE ( MAPST )
!
! 2.g Test output receiving
!
!/T3            DO J=1, NRGRD
!/T3              NR0    = HGSTGE(I,J)%NREC
!/T3              IF ( NR0 .EQ. 0 ) THEN
!/T3                  WRITE (MDST,9030) J
!/T3                ELSE
!/T3                  WRITE (MDST,9031) J, NR0
!/T3                  DO IREC=1, NR0
!/T3                    JSEA   = HGSTGE(I,J)%LJSEA(IREC)
!/T3                    NRTOT  = HGSTGE(I,J)%NRAVG(IREC)
!/T3                    IF ( NRTOT .LE. 15 ) THEN
!/T3                        WRITE (MDST,9032) JSEA, NRTOT,           &
!/T3                               HGSTGE(I,J)%WGTH(IREC,:NRTOT)
!/T3                      ELSE
!/T3                        WRITE (MDST,9032) JSEA, NRTOT,           &
!/T3                               HGSTGE(I,J)%WGTH(IREC,1:15)
!/T3                        WRITE (MDST,9033)                        &
!/T3                               HGSTGE(I,J)%WGTH(IREC,16:NRTOT)
!/T3                      END IF
!/T3                    WRITE (MDST,9034)                            &
!/T3                               HGSTGE(I,J)%IMPSRC(IREC,1:NRTOT)
!/T3                    WRITE (MDST,9034)                            &
!/T3                               HGSTGE(I,J)%ITAG(IREC,1:NRTOT)
!/T3                    END DO
!/T3                END IF
!/T3              END DO
!
! 2.h Test output sending
!
!/T4            DO J=1, NRGRD
!/T4              NR0    = HGSTGE(I,J)%NSND
!/T4              IF ( NR0 .EQ. 0 ) THEN
!/T4                  WRITE (MDST,9040) J
!/T4                ELSE
!/T4                  WRITE (MDST,9041) J, NR0
!/T4                  DO ISND=1, NR0
!/T4                    WRITE (MDST,9042) HGSTGE(I,J)%ISEND(ISND,:)
!/T4                    END DO
!/T4                END IF
!/T4              END DO
!
! 2.i Final clean up
!
            DEALLOCATE ( IXL, IXH, IYL, IYH, GRIDOK,  BDIST, TMPINT,  &
                         TMPRL, TMPLOG )
!/DIST            DEALLOCATE ( LTAG )
!
          END IF
        END DO
!
      DEALLOCATE ( I1, I2, I3, I4 )
!
! 2.j Test output counters
!
!/T      WRITE (MDST,9028) 'NTOT'
!/T      DO JJ=1, NRGRD
!/T        WRITE (MDST,9029) HGSTGE(JJ,:)%NTOT
!/T        END DO
!
!/T      WRITE (MDST,9028) 'NREC'
!/T      DO JJ=1, NRGRD
!/T        WRITE (MDST,9029) HGSTGE(JJ,:)%NREC
!/T        END DO
!
!/T      WRITE (MDST,9028) 'NRC1'
!/T      DO JJ=1, NRGRD
!/T        WRITE (MDST,9029) HGSTGE(JJ,:)%NRC1
!/T        END DO
!
!/T      WRITE (MDST,9028) 'NSND'
!/T      DO JJ=1, NRGRD
!/T        WRITE (MDST,9029) HGSTGE(JJ,:)%NSND
!/T        END DO
!
!/T      WRITE (MDST,9028) 'NSN1'
!/T      DO JJ=1, NRGRD
!/T        WRITE (MDST,9029) HGSTGE(JJ,:)%NSN1
!/T        END DO
!
!/T      WRITE (MDST,9028) 'NSMX'
!/T      DO JJ=1, NRGRD
!/T        WRITE (MDST,9029) HGSTGE(JJ,:)%NSMX
!/T        END DO
!
      RETURN
!
! Formats
!
 1000 FORMAT (/' *** WAVEWATCH III ERROR IN WMGHGH : *** '/           &
               '     GRDHGH NOT YET ALLOCATED, CALL WMGLOW FIRST'/)
 1010 FORMAT (/' *** WAVEWATCH III ERROR IN WMGHGH : *** '/           &
               '     NBI = 0 MAKES NO SENCE FOR RANK > 1 '/)
 1020 FORMAT (/' *** WAVEWATCH III ERROR IN WMGHGH : *** '/           &
               '     TMPINT AND TMPRL TOO SMALL '/)
!
!/T 9010 FORMAT ( ' TEST WMGHGH : INITIALIZE BOUNDARY DISTANCE MAPS')
!/T 9011 FORMAT ( '               GRID = ',I3,'  RANK = ',I3,         &
!/T               '  NBI = ',I6)
!/T 9012 FORMAT ( '                  *** MAP NOT NEEDED ***')
!/T 9013 FORMAT ( ' TEST WMGHGH : FINAL MAP ')
!/T 9014 FORMAT (2x,65I2)
!/
!/T 9020 FORMAT ( ' TEST WMGHGH : GRID',I3,' HAS',I3,' DATA SOURCES')
!/T 9021 FORMAT ( '               NO PROCESSING REQUIRED')
!/T 9022 FORMAT ( ' TEST WMGHGH : GRID',I3,' COVERS ',4I8)
!/T 9023 FORMAT ( ' TEST WMGHGH : GRID',I3,                           &
!/T                                ', NR OF POINTS TO PROCESS:',I5)
!/T 9025 FORMAT ( ' TEST WMGHGH : FINAL ',A)
!/T 9026 FORMAT (2X,65I2)
!/T 9027 FORMAT (2X,65A2)
!
!/T 9028 FORMAT ( ' TEST WMGHGH : COUNTERS ',A)
!/T 9029 FORMAT (2x,20I6)
!
!/T3 9030 FORMAT ( ' TEST WMGHG : FROM GRID',I3,', NO DATA TO RECEIVE')
!/T3 9031 FORMAT ( ' TEST WMGHG : FROM GRID',I3,', RECEIVING ',I6)
!/T3 9032 FORMAT ( 2X,I10,I6,15F6.2)
!/T3 9033 FORMAT ( 18X,15F6.2)
!/T3 9034 FORMAT ( 18X,15I6)
!
!/T4 9040 FORMAT ( ' TEST WMGHG : FROM GRID',I3,', NO DATA TO SEND')
!/T4 9041 FORMAT ( ' TEST WMGHG : FROM GRID',I3,', SENDING ',I6)
!/T4 9042 FORMAT ( 12X,I10,4I6)
!/
!/ End of WMGHGH ----------------------------------------------------- /
!/
      END SUBROUTINE WMGHGH
!/ ------------------------------------------------------------------- /
      SUBROUTINE WMGEQL
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           H. L. Tolman            |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         23-Dec-2010 |
!/                  +-----------------------------------+
!/
!/    24-Apr-2006 : Origination.                        ( version 3.09 )
!/    23-Dec-2006 : Adding group test.                  ( version 3.10 )
!/    28-Dec-2006 : Simplify NIT for partial comm.      ( version 3.10 )
!/    22-Jan-2007 : Add saving og NAVMAX.               ( version 3.10 )
!/    02-Feb-2007 : Setting FLAGST for replaced points. ( version 3.10 )
!/    15-Feb-2007 : Tweaking MAPODI algorithm in WMGEQL.( version 3.10 )
!/    11-Apr-2008 : Big fix active edges (MAPSTA=2)     ( version 3.13 )
!/    14-Apr-2008 : Big fix for global grids.           ( version 3.13 )
!/    20-May-2009 : Linking FLAGST and FLGHG1.          ( version 3.14 )
!/    30-Oct-2009 : Implement run-time grid selection.  ( version 3.14 )
!/                  (W. E. Rogers & T. J. Campbell, NRL)
!/    06-Dec-2010 : Change from GLOBAL (logical) to ICLOSE (integer) to
!/                  specify index closure for a grid.   ( version 3.14 )
!/                  (T. J. Campbell, NRL)
!/    23-Dec-2010 : Fix HPFAC and HQFAC by including the COS(YGRD)
!/                  factor with DXDP and DXDQ terms.    ( version 3.14 )
!/                  (T. J. Campbell, NRL)
!/
!  1. Purpose :
!
!     Determine relations to same ranked grids for each grid.
!
!  2. Method :
!
!     Cross mapping of grid points, determine boundary distance data
!     and interpolation weights.
!
!  3. Parameters :
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      W3SETG, W3SETO, WMSETM
!                Subr. W3GDATMD Manage data structures.
!      STRACE    Subr. W3SERVMD Subroutine tracing.
!      EXTCDE    Subr.   Id.    Program abort.
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!  6. Error messages :
!
!  7. Remarks :
!
!     - In looking for compatable boundary points in overlapping grids
!       two assumptions hav been made.
!        a) No active boundary points exist in global grids.
!        b) For a lower resolution grid an expanded sewarch area is
!           required for corresponding active grid points. By limiting
!           the resolution ratio to 2, only one extra grid point needs
!           to be considered (JXL2 versus JXL etc.).
!
!  8. Structure :
!
!  9. Switches :
!
!     !/PRn  Propagation scheme.
!
!     !/O12  Removed boundary points output (central).
!     !/O13  Removed boundary points output (edge).

!     !/S    Enable subroutine tracing.
!     !/T    Enable test output.
!     !/T5   Detailed test output 'receiving'.
!     !/T6   Detailed test output 'sending'.
!     !/T7   Detailed test output all.
!
!     !/MPI  Distribbuted memory management.
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!
      USE CONSTANTS
      USE W3GDATMD
      USE W3ODATMD
      USE W3ADATMD
      USE WMMDATMD
!
      USE W3SERVMD, ONLY: EXTCDE
!/S      USE W3SERVMD, ONLY: STRACE
!
      IMPLICIT NONE
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      INTEGER                  :: I, J, IX, IXL, IXH, IY, IYL, IYH,   &
                                  JX, JXL, JXH, JXL2, JXH2,           &
                                  JY, JYL, JYH, JYL2, JYH2,           &
                                  NR, NT, NA, NTL, JJ, NIT, NG, NOUT, &
                                  ISEA, JSEA, ISPROC, ITAG, TGRP,     &
                                  EXTRA, IP, NP
!/T7      INTEGER                  :: IA
!/S      INTEGER, SAVE            :: IENT = 0
      INTEGER, ALLOCATABLE     :: MAP3D(:,:,:), NREC(:), NSND(:),     &
                                  NTPP(:), MAPOUT(:,:)
      REAL                     :: FACTOR, XSL, XSH, YSL, YSH, XA, YA, &
                                  XR, YR, RX(2), RY(2), STX, STY,     &
                                  STXY, NEWVAL, WGTH
      REAL, PARAMETER          :: TODO   = -9.99E25
      REAL, PARAMETER          :: ODIMAX = 25.
      REAL, PARAMETER          :: FACMAX = 2.001
      REAL, ALLOCATABLE        :: WGT3D(:,:,:)
      LOGICAL                  :: CHANGE, XEXPND, YEXPND
      LOGICAL, ALLOCATABLE     :: SHRANK(:,:), DOGRID(:),             &
                                  MASKA(:,:), MASKI(:,:)
!/T5      CHARACTER(LEN=18), ALLOCATABLE :: TSTR(:)
!/T5      CHARACTER(LEN=18)              :: DSTR
!
      TYPE STORE
        INTEGER                :: NTOT, NFIN
        INTEGER, POINTER       :: IX(:), IY(:), NAV(:), ISS(:,:),     &
                                  JSS(:,:), IPS(:,:), ITG(:,:)
        REAL, POINTER          :: AWG(:,:)
        LOGICAL, POINTER       :: FLA(:)
        LOGICAL                :: INIT
      END TYPE STORE
!
      TYPE(STORE), ALLOCATABLE :: STORES(:,:)
!/
!/S      CALL STRACE (IENT, 'WMGEQL')
!
! -------------------------------------------------------------------- /
! 0.  Initializations
!
      IF ( GTYPE .EQ. CLGTYPE .AND. NRGRD .GT. 1 ) THEN
          WRITE (MDSE,'(/2A)') ' *** ERROR WMGEQL: ', &
          'CURVILINEAR GRID SUPPORT NOT IMPLEMENTED FOR NRGRD > 1 ***'
          CALL EXTCDE ( 999 )
        END IF
      IF ( GTYPE .EQ. UNGTYPE ) THEN
          WRITE (MDSE,'(/2A)') ' *** ERROR WMGEQL: ', &
          'UNSTRUCTURED GRID SUPPORT NOT YET IMPLEMENTED ***'
          CALL EXTCDE ( 999 )
        END IF
!
      ALLOCATE ( SHRANK(NRGRD,NRGRD), STORES(NRGRD,NRGRD),            &
                 DOGRID(NRGRD) )
!
      SHRANK = .FALSE.
!
      DO I=1, NRGRD
        DO J=1, NRGRD
          STORES(I,J)%INIT = .FALSE.
          STORES(I,J)%NTOT = 0
          STORES(I,J)%NFIN = 0
          END DO
        END DO
!
      IF ( FLAGLL ) THEN
          FACTOR = RADIUS / 360.
        ELSE
          FACTOR = 1.
        END IF
      ITAG   = 0
!
! -------------------------------------------------------------------- /
! 1.  Grid point relations and temp data storage
! 1.a Outer loop over all grids
!
!/T      WRITE (MDST,9010)
!
      DO I=1, NRGRD
!/T        WRITE (MDST,9011) I, GRANK(I)
!
! 1.b Find grids with same rank
!
        NR     = 0
!
        DO J=1, NRGRD
          IF ( GRANK(I).NE.GRANK(J) .OR. I.EQ.J ) CYCLE
!/T          WRITE (MDST,9012) J
          SHRANK(I,J) = .TRUE.
          NR          = NR + 1
          END DO
!
        CALL W3SETG ( I, MDSE, MDST )
!
        DOGRID(I) = NR .GT. 0
!/T        IF ( NR .EQ. 0 ) WRITE (MDST,9013) 'NO GRIDS WITH SAME RANK'
        IF ( NR .EQ. 0 ) CYCLE
!
! 1.c Fill TMPMAP with raw relational data
!
! 1.c.1 Loop over grids, select same rank
!
        DO J=1, NRGRD
          IF ( .NOT. SHRANK(I,J) ) CYCLE
!
! 1.c.2 Determine shared area
!       Don't even try for X in LLG
!
          IF ( FLAGLL ) THEN
              IXL    =  1
              IXH    = NX
            ELSE
              XSL    = ( GRIDS(J)%X0 - X0 ) / SX - 0.01
              XSH    = ( GRIDS(J)%X0 + GRIDS(J)%SX*(GRIDS(J)%NX-1)   &
                                     - X0 ) / SX + 0.01
              IXL    = MAX ( 1+NINT(XSL) ,  1 )
              IXH    = MIN ( 1+NINT(XSH) , NX )
            END IF
!
          YSL    = ( GRIDS(J)%Y0 - Y0 ) / SY - 0.01
          YSH    = ( GRIDS(J)%Y0 + GRIDS(J)%SY*(GRIDS(J)%NY-1)   &
                                 - Y0 ) / SY + 0.01
          IYL    = MAX ( 1+NINT(YSL) ,  1 )
          IYH    = MIN ( 1+NINT(YSH) , NY )
!
          NT     = (1+IXH-IXL) * (1+IYH-IYL)
          IF ( NT .EQ. 0 ) CYCLE
!
          STORES(I,J)%INIT = .TRUE.
          ALLOCATE ( STORES(I,J)%IX(NT)   , STORES(I,J)%IY(NT)   ,    &
                     STORES(I,J)%NAV(NT)  , STORES(I,J)%FLA(NT)  ,    &
                     STORES(I,J)%ISS(NT,4), STORES(I,J)%JSS(NT,4),    &
                     STORES(I,J)%IPS(NT,4), STORES(I,J)%ITG(NT,4),    &
                     STORES(I,J)%AWG(NT,4) )
          STORES(I,J)%NAV  = 0
          STORES(I,J)%FLA  = .FALSE.
          STORES(I,J)%ISS  = 0
          STORES(I,J)%JSS  = 0
          STORES(I,J)%IPS  = 0
          STORES(I,J)%ITG  = 0
          STORES(I,J)%AWG  = 0.
!
! 1.c.3 Loops over shared area
!
          NT     = 0
!
          XEXPND = SX .GT. GRIDS(J)%SX
          YEXPND = SY .GT. GRIDS(J)%SY
!
          DO IX=IXL, IXH
            XA     = X0 + REAL(IX-1)*SX
            IF ( FLAGLL ) THEN
                XR     = 1. + MOD (1080. + XA - GRIDS(J)%X0 , 360. ) &
                                  / GRIDS(J)%SX
              ELSE
                XR     = 1. + (XA-GRIDS(J)%X0) / GRIDS(J)%SX
              END IF
            JXL    = INT(XR)
            JXH    = JXL + 1
            RX(1)     = 1. - MOD(XR,1.)
            IF ( RX(1).GT.0.99 .OR. JXH.EQ.GRIDS(J)%NX+1 ) THEN
                JXH    = JXL
                RX(1)  = 1.
              END IF
            IF ( RX(1).LT.0.01 .OR. JXL.EQ.0 ) THEN
                JXL    = JXH
                RX(1)  = 1.
              END IF
            RX(2)  = 1. - RX(1)
!
            IF ( JXL.LT.1 .OR. JXH.GT.GRIDS(J)%NX ) CYCLE
!
            IF ( XEXPND ) THEN
                JXL2   = MAX ( 1 , JXL-1 )
                JXH2   = MIN ( GRIDS(J)%NX , JXH+1 )
              ELSE
                JXL2   = JXL
                JXH2   = JXH
              END IF
!
            DO IY=IYL, IYH
              YA     = Y0 + REAL(IY-1)*SY
              YR     = 1. + (YA-GRIDS(J)%Y0) / GRIDS(J)%SY
              JYL    = INT(YR)
              JYH    = JYL + 1
              RY(1)  = 1. - MOD(YR,1.)
              IF ( RY(1).GT.0.99 .OR. JYH.EQ.GRIDS(J)%NY+1 ) THEN
                  JYH    = JYL
                  RY(1)  = 1.
                END IF
              IF ( RY(1).LT.0.01 .OR. JYL.EQ.0 ) THEN
                  JYL    = JYH
                  RY(1)  = 1.
                END IF
              IF ( RY(1) .GT. 0.99 ) JYH = JYL
              RY(2)  = 1. - RY(1)
!
              IF ( JYL.LT.1 .OR. JYH.GT.GRIDS(J)%NY ) CYCLE
!
              IF ( YEXPND ) THEN
                  JYL2   = MAX ( 1 , JYL-1 )
                  JYH2   = MIN ( GRIDS(J)%NY , JYH+1 )
                ELSE
                  JYL2   = JYL
                  JYH2   = JYH
                END IF
!
! 1.c.4 Temp storage of raw data
!
              NT     = NT + 1
              NA     = 0
!/SHRD              ISPROC = 1
              STORES(I,J)%IX(NT)  = IX
              STORES(I,J)%IY(NT)  = IY
!
              DO JX = JXL, JXH
                DO JY = JYL, JYH
                  IF ( GRIDS(J)%MAPSTA(JY,JX) .NE. 0 ) THEN
                      NA     = NA + 1
                      ITAG   = ITAG + 1
                      WGTH   = RX(1+JX-JXL) * RY(1+JY-JYL)
                      ISEA   = GRIDS(J)%MAPFS(JY,JX)
                      IF ( ISEA .EQ. 0 ) THEN
                          JSEA   = 0
!/MPI                          ISPROC = 1
                        ELSE
                          JSEA   = 1 + (ISEA-1)/OUTPTS(J)%NAPROC
!/MPI                          ISPROC = ISEA -                        &
!/MPI                                      (JSEA-1)*OUTPTS(J)%NAPROC  &
!/MPI                                           + MDATAS(J)%CROOT - 1
                        END IF
                      STORES(I,J)%AWG(NT,NA) = WGTH
                      STORES(I,J)%ISS(NT,NA) = ISEA
                      STORES(I,J)%JSS(NT,NA) = JSEA
                      STORES(I,J)%IPS(NT,NA) = ISPROC
                      STORES(I,J)%ITG(NT,NA) = ITAG
                    END IF
                  END DO
                END DO
!
              DO JX = JXL2, JXH2
                DO JY = JYL2, JYH2
                  IF ( ABS(GRIDS(J)%MAPSTA(JY,JX)) .EQ. 2 )           &
                      STORES(I,J)%FLA(NT) = .TRUE.
                  END DO
                END DO
!
              WGTH   = SUM ( STORES(I,J)%AWG(NT,1:NA) )
              IF ( WGTH .LT. 0.499 ) THEN
                  NA    = 0
                ELSE
                  STORES(I,J)%AWG(NT,:) = STORES(I,J)%AWG(NT,:) / WGTH
                END IF
!
              STORES(I,J)%NAV(NT) = NA
!
! ... End of loops in 1.c
!
              END DO
            END DO
!
          STORES(I,J)%NTOT = NT
!
          END DO
!
! -------------------------------------------------------------------- /
! 2.  Generate open edge distance maps
! 2.a Base map based on MAPSTA only, time step not included.
!
!/T        WRITE (MDST,9020) I
!
        ALLOCATE ( MDATAS(I)%MAPODI(NY,NX) )
        MAPODI => MDATAS(I)%MAPODI
        MAPODI = 0.
!
        DO IX=1, NX
          DO IY=1, NY
            IF ( ABS(MAPSTA(IY,IX)) .EQ. 1 ) THEN
                MAPODI(IY,IX) = TODO
              ELSE IF ( ABS(MAPSTA(IY,IX)) .EQ. 2 ) THEN
                MAPODI(IY,IX) = -2. / SIG(1) * DTMAX
              ELSE
                MAPODI(IY,IX) = -1. / SIG(1) * DTMAX
              END IF
            END DO
          END DO
!
! 2.b Add in cross-grid information from STORES
!
        ALLOCATE ( MASKA(NY,NX) )
        MASKA  = .FALSE.
!
        DO J=1, NRGRD
          IF ( .NOT. SHRANK(I,J) ) CYCLE
          DO JJ=1, STORES(I,J)%NTOT
            IX     = STORES(I,J)%IX(JJ)
            IY     = STORES(I,J)%IY(JJ)
            IF ( IX.EQ.1 .OR. IX.EQ.NX .OR. IY.EQ.1 .OR. IY.EQ.NY ) THEN
                MASKA(IY,IX) = STORES(I,J)%FLA(JJ) .OR.               &
                               STORES(I,J)%NAV(JJ).EQ.0 
                IF ( ABS(MAPSTA(IY,IX)).EQ.2 .AND.                    &
                     .NOT.STORES(I,J)%FLA(JJ) .AND.                   &
                     STORES(I,J)%NAV(JJ).GT.0 ) THEN
                     MAPODI(IY,IX) = 0.
!/O13                    IF ( IMPROC.EQ.NMPERR )                      &
!/O13                         WRITE (MDSE,1020) I, IX, 1
                  END IF
              ELSE
                MASKA(IY,IX) = STORES(I,J)%FLA(JJ)
              END IF
            IF ( MAPSTA(IY,IX).EQ.0 .AND. MAPST2(IY,IX) .EQ.1 .AND.   &
                 STORES(I,J)%NAV(JJ).GT.0 ) MAPODI(IY,IX) = 0.
            END DO
          END DO
!
! 2.c Remove incompatable boundary points
!
        ALLOCATE ( MASKI(NY,NX) )
        MASKI  = .FALSE.
!
        DO IX=2, NX-1
          DO IY=2, NY-1
            IF ( ABS(MAPSTA(IY,IX)) .EQ. 2 .AND.                      &
                 .NOT. MASKA(IY,IX) .AND. (                           &
                          MAPODI(IY-1,IX  ) .GE. 0. .OR.              &
                          MAPODI(IY+1,IX  ) .GE. 0. .OR.              &
                          MAPODI(IY  ,IX-1) .GE. 0. .OR.              &
                          MAPODI(IY  ,IX+1) .GE. 0. ) ) THEN
                MASKI(IY,IX) = .TRUE.
!/O12                IF ( IMPROC.EQ.NMPERR ) WRITE (MDSE,1020) I, IX, IY
              END IF
            END DO
          END DO
!
        DEALLOCATE ( MASKA )
!
        DO IX=1, NX
          DO IY=1, NY
            IF ( MASKI(IY,IX) ) MAPODI(IY,IX) = 0.
            END DO
          END DO
!
! 2.d Mask out influenced edge
!
!/PR0        NIT    = 0
!/PR1        NIT    = ( 1 + INT(DTMAX/DTCFL-0.001) ) * 1
!/PR2        NIT    = ( 1 + INT(DTMAX/DTCFL-0.001) ) * 3
!/PR3        NIT    = ( 1 + INT(DTMAX/DTCFL-0.001) ) * 3
!
        IF ( ICLOSE.NE.ICLOSE_NONE ) THEN
            IXL    =  1
            IXH    = NX
          ELSE
            IXL    =  2
            IXH    = NX - 1
          END IF
!
        DO J=1, NIT
!
          MASKI  = .FALSE.
!
          DO IX=IXL, IXH
            IF ( IX .EQ. 1 ) THEN
                JXL    = NX
                JXH    =  2
              ELSE IF ( IX .EQ. NX ) THEN
                JXL    = NX - 1
                JXH    = 1
              ELSE
                JXL    = IX - 1
                JXH    = IX + 1
              END IF
!
            DO IY=2, NY-1
              IF ( MAPODI(IY,IX) .EQ. TODO .AND. (                    &
                   MAPODI(IY+1,IX ) .GE. 0. .OR.                      &
                   MAPODI(IY  ,JXL) .GE. 0. .OR.                      &
                   MAPODI(IY-1,IX ) .GE. 0. .OR.                      &
                   MAPODI(IY  ,JXH) .GE. 0. .OR.                      &
                 ( MAPODI(IY+1,JXH) .GE. 0. .AND. .NOT.               &
                 ( MAPSTA(IY+1,IX ) .NE. 1 .AND.                      &
                   MAPSTA(IY  ,JXH) .NE. 1 ) ) .OR.                   &
                 ( MAPODI(IY+1,JXL) .GE. 0. .AND. .NOT.               &
                 ( MAPSTA(IY+1,IX ) .NE. 1 .AND.                      &
                   MAPSTA(IY  ,JXL) .NE. 1 ) ) .OR.                   &
                 ( MAPODI(IY-1,JXL) .GE. 0. .AND. .NOT.               &
                 ( MAPSTA(IY-1,IX ) .NE. 1 .AND.                      &
                   MAPSTA(IY  ,JXL) .NE. 1 ) ) .OR.                   &
                 ( MAPODI(IY-1,JXH) .GE. 0. .AND. .NOT.               &
                 ( MAPSTA(IY-1,IX ) .NE. 1 .AND.                      &
                   MAPSTA(IY  ,JXH) .NE. 1 ) ) ) )                    &
                  MASKI(IY,IX) = .TRUE.
              END DO
!
            END DO
!
          DO IX=IXL, IXH
            DO IY=2, NY-1
              IF ( MASKI(IY,IX) ) MAPODI(IY,IX) = 0.
              END DO
            END DO
!
          END DO
!
! 2.e Compute distances
!
        DO
          MASKI  = .FALSE.
!
          DO IX=IXL, IXH
            IF ( IX .EQ. 1 ) THEN
                JXL    = NX
                JXH    =  2
              ELSE IF ( IX .EQ. NX ) THEN
                JXL    = NX - 1
                JXH    = 1
              ELSE
                JXL    = IX - 1
                JXH    = IX + 1
              END IF
            DO IY=2, NY-1
              IF ( MAPODI(IY,IX) .EQ. TODO .AND. (                    &
                   MAPODI(IY+1,IX ) .GE. 0. .OR.                      &
                   MAPODI(IY-1,IX ) .GE. 0. .OR.                      &
                   MAPODI(IY  ,JXH) .GE. 0. .OR.                      &
                   MAPODI(IY  ,JXL) .GE. 0. .OR.                      &
                 ( MAPODI(IY+1,JXH) .GE. 0. .AND. .NOT.               &
                 ( MAPSTA(IY+1,IX ) .NE. 1 .AND.                      &
                   MAPSTA(IY  ,JXH) .NE. 1 ) ) .OR.                   &
                 ( MAPODI(IY+1,JXL) .GE. 0. .AND. .NOT.               &
                 ( MAPSTA(IY+1,IX ) .NE. 1 .AND.                      &
                   MAPSTA(IY  ,JXL) .NE. 1 ) ) .OR.                   &
                 ( MAPODI(IY-1,JXL) .GE. 0. .AND. .NOT.               &
                 ( MAPSTA(IY-1,IX ) .NE. 1 .AND.                      &
                   MAPSTA(IY  ,JXL) .NE. 1 ) ) .OR.                   &
                 ( MAPODI(IY-1,JXH) .GE. 0. .AND. .NOT.               &
                 ( MAPSTA(IY-1,IX ) .NE. 1 .AND.                      &
                   MAPSTA(IY  ,JXH) .NE. 1 ) ) ) )                    &
                  MASKI(IY,IX) = .TRUE.
              END DO
            END DO
!
          CHANGE = .FALSE.
          DO IY=2, NY-1
            DO IX=IXL, IXH
              IF ( IX .EQ. 1 ) THEN
                  JXL    = NX
                  JXH    =  2
                ELSE IF ( IX .EQ. NX ) THEN
                  JXL    = NX - 1
                  JXH    = 1
                ELSE
                  JXL    = IX - 1
                  JXH    = IX + 1
                END IF
              ISEA   = MAPFS(IY,IX)
              STY    = FACTOR * HQFAC(IY,IX) / ( 0.58 * GRAV )
              STX    = FACTOR * HPFAC(IY,IX) &
                                             / ( 0.58 * GRAV )
              STXY   = SQRT ( STX**2 + STY**2 )
              IF ( MASKI(IY,IX) ) THEN
                  NEWVAL = ODIMAX / SIG(1) * DTMAX
                  IF ( MAPODI(IY+1,IX ).GE.0. .AND. .NOT.             &
                       MASKI (IY+1,IX ) ) NEWVAL = MIN (              &
                       NEWVAL , MAPODI(IY+1,IX )+STY )
                  IF ( MAPODI(IY-1,IX ).GE.0. .AND. .NOT.             &
                       MASKI (IY-1,IX ) ) NEWVAL = MIN (              &
                       NEWVAL , MAPODI(IY-1,IX )+STY )
                  IF ( MAPODI(IY  ,JXH).GE.0. .AND. .NOT.             &
                       MASKI (IY  ,JXH) ) NEWVAL = MIN (              &
                       NEWVAL , MAPODI(IY  ,JXH)+STX)
                  IF ( MAPODI(IY  ,JXL).GE.0. .AND. .NOT.             &
                       MASKI (IY  ,JXL) ) NEWVAL = MIN (              &
                       NEWVAL , MAPODI(IY  ,JXL)+STX)
                  IF ( MAPODI(IY+1,JXH).GE.0. .AND. .NOT.             &
                     ( MAPSTA(IY+1,IX ) .NE. 1 .AND.                  &
                       MAPSTA(IY  ,JXH) .NE. 1 ) ) NEWVAL =           &
                       MIN ( NEWVAL , MAPODI(IY+1,JXH)+STXY)
                  IF ( MAPODI(IY+1,JXL).GE.0. .AND. .NOT.             &
                     ( MAPSTA(IY+1,IX ) .NE. 1 .AND.                  &
                       MAPSTA(IY  ,JXL) .NE. 1 ) ) NEWVAL =           &
                       MIN ( NEWVAL , MAPODI(IY+1,JXL)+STXY)
                  IF ( MAPODI(IY-1,JXL).GE.0. .AND. .NOT.             &
                     ( MAPSTA(IY-1,IX ) .NE. 1 .AND.                  &
                       MAPSTA(IY  ,JXL) .NE. 1 ) ) NEWVAL =           &
                       MIN ( NEWVAL , MAPODI(IY-1,JXL)+STXY)
                  IF ( MAPODI(IY-1,JXH).GE.0. .AND. .NOT.             &
                     ( MAPSTA(IY-1,IX ) .NE. 1 .AND.                  &
                       MAPSTA(IY  ,JXH) .NE. 1 ) ) NEWVAL =           &
                       MIN ( NEWVAL , MAPODI(IY-1,JXH)+STXY)
                  MAPODI(IY,IX) = NEWVAL
                  CHANGE = .TRUE.
                END IF
              END DO
            END DO
!
          IF ( .NOT. CHANGE ) EXIT
          END DO
!
        DO IX=2, NX-1
          DO IY=2, NY-1
            IF ( MAPODI(IY,IX) .EQ. TODO )                            &
                 MAPODI(IY,IX) = 2. * ODIMAX / SIG(1) * DTMAX
            END DO
          END DO
!
        DEALLOCATE ( MASKI )
!
! 2.f Update FLAGST
!
        DO ISEA=1, NSEA
          IX     = MAPSF(ISEA,1)
          IY     = MAPSF(ISEA,2)
          IF ( MAPODI(IY,IX) .EQ. 0. ) FLAGST(ISEA) = .NOT. FLGHG1
          END DO
!
! 2.g Test output
!
!/T        NP     = 1 + (NX-1)/65
!/T        DO IP=1, NP
!/T          IXL    = 1 + (IP-1)*65
!/T          IXH    = MIN( NX, IP*65 )
!/T          WRITE (MDST,9024) IXL, IXH
!/T          DO IY=NY,1 , -1
!/T            WRITE (MDST,9025) NINT(MAPODI(IY,IXL:IXH)*SIG(1)/DTMAX)
!/T            END DO
!/T          END DO
!
! ... End of loop in 1.a
!
        END DO
!
! -------------------------------------------------------------------- /
! 3.  Final data base (full data base, scratched at end of routine)
! 3.a Loop over grids
!
      ALLOCATE ( NREC(NRGRD), NSND(NRGRD), NTPP(NMPROC) )
!
      DO I=1, NRGRD
        IF ( .NOT. DOGRID(I) ) CYCLE
!/T        WRITE (MDST,9030) I
!
        CALL W3SETG ( I, MDSE, MDST )
        CALL W3SETO ( I, MDSE, MDST )
        CALL WMSETM ( I, MDSE, MDST )
!
        ALLOCATE ( MAP3D(NY,NX,-4:NRGRD), WGT3D(NY,NX,0:NRGRD) )
        MAP3D  = 0
        WGT3D  = 0.
        NREC   = 0 
        NSND   = 0 
!
! 3.b Filling MAP3D and WGT3D, as well as NREC and NSND
!
        DO J=1, NRGRD
          IF ( .NOT. SHRANK(I,J) ) CYCLE
!/T          WRITE (MDST,9031) J
          MAPODI => MDATAS(J)%MAPODI
!
          DO JJ=1, STORES(I,J)%NTOT
            IX     = STORES(I,J)%IX(JJ)
            IY     = STORES(I,J)%IY(JJ)
            WGT3D(IY,IX,0) = MDATAS(I)%MAPODI(IY,IX)
            MAP3D(IY,IX,-2) = MAPFS(IY,IX)
            IF ( MAP3D(IY,IX,-2) .NE. 0 ) THEN
                MAP3D(IY,IX,-3) = 1 + (MAP3D(IY,IX,-2)-1)/NAPROC
!/SHRD                MAP3D(IY,IX,-4) = 1
!/MPI                MAP3D(IY,IX,-4) = MAP3D(IY,IX,-2) -              &
!/MPI                     (MAP3D(IY,IX,-3)-1)*NAPROC + CROOT - 1
              END IF
            IF ( WGT3D(IY,IX,0).GE.0. .AND. MAPSTA(IY,IX).NE.0. .AND. &
                 STORES(I,J)%NAV(JJ).GT.0 ) THEN
                WGT3D(IY,IX,J) = ODIMAX / SIG(1) * DTMAX
                DO NA=1, STORES(I,J)%NAV(JJ)
                  JX     = GRIDS(J)%MAPSF(STORES(I,J)%ISS(JJ,NA),1)
                  JY     = GRIDS(J)%MAPSF(STORES(I,J)%ISS(JJ,NA),2)
                  IF ( MAPODI(JY,JX) .GE. 0. ) WGT3D(IY,IX,J) =       &
                         MIN( WGT3D(IY,IX,J) , MAPODI(JY,JX) )
                  END DO
                IF ( WGT3D(IY,IX,J) .GT. 0. ) MAP3D(IY,IX,J) = 1
              END IF
            END DO
!
          STORES(I,J)%NFIN = SUM(MAP3D(:,:,J))
!/T          WRITE (MDST,9032) STORES(I,J)%NFIN, STORES(I,J)%NTOT
!
          END DO
!
        MAPODI => MDATAS(I)%MAPODI
        DO IX=1, NX
          DO IY=1, NY
            MAP3D(IY,IX, 0) = MAXVAL(MAP3D(IY,IX,1:))
            MAP3D(IY,IX,-1) = SUM(MAP3D(IY,IX,1:))
            IF ( MAP3D(IY,IX,-1) .GT. 0 ) THEN
                IF ( MAPODI(IY,IX)*SIG(1)/DTMAX .GT. 1.5*ODIMAX ) THEN
                    WGT3D(IY,IX, 0:) = 0.
                    MAP3D(IY,IX,-1:) = 0
                  ELSE
                    WGTH   = SUM(WGT3D(IY,IX,:))
                    IF ( WGTH .GT. 1.E-25 ) THEN
                        WGT3D(IY,IX,:) = WGT3D(IY,IX,:) / WGTH
                      ELSE
                        WGT3D(IY,IX,:) = 0.
                      END IF
                    IF ( MAP3D(IY,IX,-4) .EQ. IMPROC ) THEN
                        NREC(I) = NREC(I) + 1
                        DO JJ=1, NRGRD
                          IF ( MAP3D(IY,IX,JJ) .GT. 0 )               &
                               NREC(JJ) = NREC(JJ) + 1
                            END DO
                      END IF
                  END IF
              END IF
            END DO
          END DO
!
        DO J=1, NRGRD
          IF ( .NOT. SHRANK(I,J) ) CYCLE
          DO JJ=1, STORES(I,J)%NTOT
            IX     = STORES(I,J)%IX(JJ)
            IY     = STORES(I,J)%IY(JJ)
            IF ( MAP3D(IY,IX,J) .NE. 0 ) THEN
                DO NA=1, STORES(I,J)%NAV(JJ)
                  IF ( STORES(I,J)%IPS(JJ,NA) .EQ. IMPROC )           &
                      NSND(J) = NSND(J) + 1
                  END DO
              END IF
            END DO
          END DO
!
        NG     = MAXVAL(MAP3D(:,:,-1))
        NTL    = SUM(MAP3D(:,:,0))
!
! 3.c Check for points with all ODI = 0
!
        MAPODI => MDATAS(I)%MAPODI
        NOUT   = 0
!
        JXL    = NX
        JXH    =  1
        JYL    = NY
        JYH    =  1
!
        ALLOCATE ( MAPOUT(NY,NX) )
        MAPOUT = MAPSTA
!
        DO IX=1, NX
          DO IY=1, NY
            IF ( ABS(MAPSTA(IY,IX)).EQ. 1 .AND.                       &
                 MAPODI(IY,IX) .EQ. 0.    .AND.                       &
                 MAP3D(IY,IX,-1) .EQ. 0 ) THEN
                NOUT = NOUT + 1
                IF ( IMPROC.EQ.NMPERR .AND. NOUT.EQ. 1 )              &
                     WRITE(MDSE,*) ' '
                IF ( IMPROC.EQ.NMPERR .AND. NOUT.LE.25 )              &
                     WRITE(MDSE,1001) I, IX, IY
                IF ( IMPROC.EQ.NMPERR .AND. NOUT.EQ.25 )              &
                     WRITE(MDSE,1006)
                JXL    = MIN ( IX, JXL )
                JXH    = MAX ( IX, JXH )
                JYL    = MIN ( IY, JYL )
                JYH    = MAX ( IY, JYH )
                MAPOUT(IY,IX) = 999
              END IF
            END DO
          END DO
!
! 3.d Test and error output
!
!/T        WRITE (MDST,9033) NTL, NG, NOUT
!/T        WRITE (MDST,9034) NREC
!/T        WRITE (MDST,9035) NSND
!/T        WRITE (MDST,9036)
!/T        DO IY=NY,1 , -1
!/T          WRITE (MDST,9037) MAP3D(IY,:,-1)
!/T          END DO
!
        IF ( NOUT .GT. 0 ) THEN
            IF ( IMPROC.EQ.NMPERR ) THEN
                WRITE(MDSE,1000) I, NOUT
                EXTRA  = 2
                JXL = MAX (  1, JXL - EXTRA )
                JXH = MIN ( NX, JXH + EXTRA )
                JYL = MAX (  1, JYL - EXTRA )
                JYH = MIN ( NY, JYH + EXTRA )
                WRITE (MDSE,1002) JXL, JXH, JYL, JYH
                NP     = 1 + (JXH-JXL)/65
                DO IP=1, NP
                  IXL    = JXL + (IP-1)*65
                  IXH    = MIN( NX, IXL+64 )
                  WRITE (MDSE,1005) IXL, IXH
                  WRITE (MDSE,1003) 'STATUS MAP MAPSTA'
                  DO IY=JYH, JYL, -1
                    WRITE (MDSE,1004) MAPSTA(IY,IXL:IXH)
                    END DO
                  WRITE (MDSE,1003) 'MISSING POINTS IN MAPSTA (**)'
                  DO IY=JYH, JYL, -1
                    WRITE (MDSE,1004) MAPOUT(IY,IXL:IXH)
                    END DO
                  WRITE (MDSE,1003) 'OPEN BOUND. DISTANCE MAP MAPODI'
                  DO IY=JYH, JYL, -1
                   WRITE (MDSE,1004)                                 &
                          NINT(MAPODI(IY,IXL:IXH)*SIG(1)/DTMAX)
                    END DO
                  WRITE (MDSE,1003) 'GRID COVERAGE MAP MAP3D'
                  DO IY=JYH, JYL, -1
                    WRITE (MDSE,1004) MAP3D(IY,IXL:IXH,-1)
                    END DO
                  WRITE (MDSE,*)
                  END DO
              END IF
            CALL EXTCDE (1000)
          END IF
!
        DEALLOCATE ( MAPOUT )
!
!/T7        WRITE (MDST,9330) I
!/T7        DO J=1, NRGRD
!/T7          IF ( .NOT. SHRANK(I,J) ) THEN
!/T7              IF ( I .NE. J ) WRITE (MDST,9331) J
!/T7              CYCLE
!/T7            END IF
!/T7          WRITE (MDST,9332) J, STORES(I,J)%NFIN, I, J
!/T7          IF ( STORES(I,J)%NFIN .EQ. 0 ) CYCLE
!/T7          NTL    = 0
!/T7          DO JJ=1, STORES(I,J)%NTOT
!/T7            IX     = STORES(I,J)%IX(JJ)
!/T7            IY     = STORES(I,J)%IY(JJ)
!/T7            IF ( MAP3D(IY,IX,J) .EQ. 0 ) CYCLE
!/T7            NTL    = NTL + 1
!/T7            NA     = STORES(I,J)%NAV(JJ)
!/T7            WRITE (MDST,9333) NTL, IX, IY, MAP3D(IY,IX,-2),       &
!/T7                              MAP3D(IY,IX,-3), MAP3D(IY,IX,-4),   &
!/T7                              WGT3D(IY,IX,0), WGT3D(IY,IX,J), NA, &
!/T7                              STORES(I,J)%ISS(JJ,1),              &
!/T7                              STORES(I,J)%JSS(JJ,1),              &
!/T7                              STORES(I,J)%IPS(JJ,1),              &
!/T7                              STORES(I,J)%AWG(JJ,1),              &
!/T7                              STORES(I,J)%ITG(JJ,1)
!/T7            DO IA=2, NA
!/T7              WRITE (MDST,9334) STORES(I,J)%ISS(JJ,IA),           &
!/T7                                STORES(I,J)%JSS(JJ,IA),           &
!/T7                                STORES(I,J)%IPS(JJ,IA),           &
!/T7                                STORES(I,J)%AWG(JJ,IA),           &
!/T7                                STORES(I,J)%ITG(JJ,IA)
!/T7              END DO
!/T7            END DO
!/T7          END DO
!
! -------------------------------------------------------------------- /
! 4.  Save data base as needed in EQSTGE
!
! 4.a   Allocate storage
! 4.a.1 Local counters, weights and sea counters (grid 'I')
!
        IF ( EQSTGE(I,I)%NREC .NE. 0 ) THEN
            DEALLOCATE (EQSTGE(I,I)%ISEA , EQSTGE(I,I)%JSEA ,         &
                        EQSTGE(I,I)%WGHT ) 
            EQSTGE(I,I)%NREC = 0
!/T            WRITE (MDST,9040) I, I
          END IF
!
        IF ( NREC(I) .GT. 0 ) THEN
            ALLOCATE ( EQSTGE(I,I)%ISEA(NREC(I))  ,                   &
                       EQSTGE(I,I)%JSEA(NREC(I))  ,                   &
                       EQSTGE(I,I)%WGHT(NREC(I)) )
            EQSTGE(I,I)%NREC = NREC(I)
!/T            WRITE (MDST,9041) I, I, NREC(I)
          END IF
!
! 4.a.1 Local counters, arrays weights etc.  (grid 'J' receive)
!
        DO J=1, NRGRD
          IF ( I .EQ. J ) CYCLE
          EQSTGE(I,I)%NTOT = STORES(I,J)%NFIN
!
          IF ( EQSTGE(I,J)%NREC .NE. 0 ) THEN
              DEALLOCATE ( EQSTGE(I,J)%ISEA , EQSTGE(I,J)%JSEA ,      &
                           EQSTGE(I,J)%WGHT , EQSTGE(I,J)%SEQL ,      &
                           EQSTGE(I,J)%NAVG , EQSTGE(I,J)%WAVG ,      &
                           EQSTGE(I,J)%RIP  , EQSTGE(I,J)%RTG  )
              EQSTGE(I,J)%NREC   = 0
              EQSTGE(I,J)%NAVMAX = 1
!/T              WRITE (MDST,9042) I, J
            END IF
!
          IF ( NREC(J) .GT. 0 ) THEN
              NA     =  MAXVAL ( STORES(I,J)%NAV(1:STORES(I,J)%NTOT) )
              EQSTGE(I,J)%NAVMAX = NA
              ALLOCATE ( EQSTGE(I,J)%ISEA(NREC(J))  ,                 &
                         EQSTGE(I,J)%JSEA(NREC(J))  ,                 &
                         EQSTGE(I,J)%WGHT(NREC(J))  ,                 &
                         EQSTGE(I,J)%SEQL(SGRDS(J)%NSPEC,NREC(J),NA), &
                         EQSTGE(I,J)%NAVG(NREC(J))  ,                 &
                         EQSTGE(I,J)%WAVG(NREC(J),NA),                &
                         EQSTGE(I,J)%RIP(NREC(J),NA),                 &
                         EQSTGE(I,J)%RTG(NREC(J),NA) )
              EQSTGE(I,J)%NREC = NREC(J)
!/T              WRITE (MDST,9043) I, J, NREC(J), NA
            END IF
!
          IF ( EQSTGE(I,J)%NSND .NE. 0 ) THEN
              DEALLOCATE ( EQSTGE(I,J)%SIS , EQSTGE(I,J)%SJS ,        &
                           EQSTGE(I,J)%SI1 , EQSTGE(I,J)%SI2 ,        &
                           EQSTGE(I,J)%SIP , EQSTGE(I,J)%STG )
              EQSTGE(I,J)%NSND = 0
!/T              WRITE (MDST,9044) I, J
            END IF
!
          IF ( NSND(J) .GT. 0 ) THEN
              ALLOCATE ( EQSTGE(I,J)%SIS(NSND(J)) ,                   &
                         EQSTGE(I,J)%SJS(NSND(J)) ,                   &
                         EQSTGE(I,J)%SI1(NSND(J)) ,                   &
                         EQSTGE(I,J)%SI2(NSND(J)) ,                   &
                         EQSTGE(I,J)%SIP(NSND(J)) ,                   &
                         EQSTGE(I,J)%STG(NSND(J)) )
              EQSTGE(I,J)%NSND = NSND(J)
!/T              WRITE (MDST,9045) I, J, NSND(J)
            END IF
!
          END DO
!
! 4.b   Store data in EQSTGE
! 4.b.1 Grid I (JSEA and weight only)
!
        IF ( EQSTGE(I,I)%NREC .GT. 0 ) THEN
            NTL    = 0
            DO IX=1, NX
              DO IY=1, NY
                IF ( MAP3D(IY,IX,0) .EQ. 0 ) CYCLE
                IF ( MAP3D(IY,IX,-4) .NE. IMPROC ) CYCLE
                NTL    = NTL + 1
                EQSTGE(I,I)%ISEA(NTL) = MAP3D(IY,IX,-2)
                EQSTGE(I,I)%JSEA(NTL) = MAP3D(IY,IX,-3)
                EQSTGE(I,I)%WGHT(NTL) = WGT3D(IY,IX,0)
                END DO
              END DO
          END IF
!
! 4.b.2 All other grids, info for receiving
!
        DO J=1, NRGRD 
          IF ( .NOT. SHRANK(I,J) ) CYCLE
          IF ( EQSTGE(I,J)%NREC .EQ. 0 ) CYCLE
          NTL    = 0
!
          DO JJ=1, STORES(I,J)%NTOT
            IX     = STORES(I,J)%IX(JJ)
            IY     = STORES(I,J)%IY(JJ)
            IF ( MAP3D(IY,IX,J) .EQ. 0 ) CYCLE
            IF ( MAP3D(IY,IX,-4) .NE. IMPROC ) CYCLE
            NTL    = NTL + 1
            EQSTGE(I,J)%ISEA(NTL) = MAP3D(IY,IX,-2)
            EQSTGE(I,J)%JSEA(NTL) = MAP3D(IY,IX,-3)
            EQSTGE(I,J)%WGHT(NTL) = WGT3D(IY,IX,J)
            NA     = STORES(I,J)%NAV(JJ)
            EQSTGE(I,J)%NAVG(NTL) = NA
            EQSTGE(I,J)%WAVG(NTL,1:NA) = STORES(I,J)%AWG(JJ,1:NA)
            EQSTGE(I,J)%RIP (NTL,1:NA) = STORES(I,J)%IPS(JJ,1:NA)
            EQSTGE(I,J)%RTG (NTL,1:NA) = STORES(I,J)%ITG(JJ,1:NA)
            END DO
!
          END DO
!
! 4.b.3 All other grids, info for sending
!
        DO J=1, NRGRD 
          IF ( .NOT. SHRANK(I,J) ) CYCLE
          IF ( EQSTGE(I,J)%NSND .EQ. 0 ) CYCLE
          NTPP   = 0
          NTL    = 0
!
          DO JJ=1, STORES(I,J)%NTOT
            IX     = STORES(I,J)%IX(JJ)
            IY     = STORES(I,J)%IY(JJ)
            IF ( MAP3D(IY,IX,J) .NE. 0 ) THEN
                NTPP(MAP3D(IY,IX,-4)) = NTPP(MAP3D(IY,IX,-4)) + 1
                DO NA=1, STORES(I,J)%NAV(JJ)
                  IF ( STORES(I,J)%IPS(JJ,NA) .EQ. IMPROC ) THEN
                      NTL    = NTL + 1
                      EQSTGE(I,J)%SIS(NTL) = STORES(I,J)%ISS(JJ,NA)
                      EQSTGE(I,J)%SJS(NTL) = STORES(I,J)%JSS(JJ,NA)
                      EQSTGE(I,J)%SI1(NTL) = NTPP(MAP3D(IY,IX,-4))
                      EQSTGE(I,J)%SI2(NTL) = NA
                      EQSTGE(I,J)%SIP(NTL) = MAP3D(IY,IX,-4)
                      EQSTGE(I,J)%STG(NTL) = STORES(I,J)%ITG(JJ,NA)
                    END IF
                  END DO
              END IF
            END DO
!
          END DO
!
! 4.c Detailed test output
!
!/T5        DSTR   = '                  '
!
!/T5        IF ( EQSTGE(I,I)%NREC .EQ. 0 ) THEN
!/T5            WRITE (MDST,9140) I
!/T5          ELSE
!/T5            WRITE (MDST,9141) I
!/T5            NA     = 0
!/T5            DO J=1, NRGRD
!/T5              IF ( I.EQ.J .OR. EQSTGE(I,J)%NREC.EQ.0 ) CYCLE
!/T5              NA     = NA + 1
!/T5              NSND(NA) = J
!/T5              END DO
!/T5            WRITE (MDST,9142) NSND(1:NA)
!/T5            WRITE (MDST,9143)
!/T5            ALLOCATE ( TSTR(NA) )
!/T5            DO JJ=1, EQSTGE(I,I)%NREC
!/T5              DO NG=1, NA
!/T5                J      = NSND(NG)
!/T5                TSTR(NG) = DSTR
!/T5                DO NTL=1, EQSTGE(I,J)%NREC
!/T5                    IF ( EQSTGE(I,I)%ISEA(JJ) .EQ.                &
!/T5                         EQSTGE(I,J)%ISEA(NTL) ) THEN
!/T5                        WRITE (TSTR(NG),9144) NTL,                &
!/T5                                    EQSTGE(I,J)%WGHT(NTL),        &
!/T5                                    EQSTGE(I,J)%NAVG(NTL)
!/T5                        EXIT
!/T5                      END IF
!/T5                  END DO
!/T5                END DO
!/T5              WRITE (MDST,9145) JJ, EQSTGE(I,I)%ISEA(JJ),         &
!/T5                                    EQSTGE(I,I)%JSEA(JJ),         &
!/T5                                    EQSTGE(I,I)%WGHT(JJ),         &
!/T5                                    TSTR
!/T5              END DO
!/T5            DEALLOCATE ( TSTR )
!/T5          END IF
!
!/T5        DO J=1, NRGRD
!/T5          IF ( I.EQ.J .OR. EQSTGE(I,J)%NREC.EQ.0 ) CYCLE
!/T5          WRITE (MDST,9146) J
!/T5          DO JJ=1, EQSTGE(I,J)%NREC
!/T5            WRITE (MDST,9147) JJ, EQSTGE(I,J)%NAVG(JJ),           &
!/T5                            ( EQSTGE(I,J)%WAVG(JJ,NA),            &
!/T5                              EQSTGE(I,J)%RIP (JJ,NA),            &
!/T5                              EQSTGE(I,J)%RTG (JJ,NA),            &
!/T5                                  NA=1, EQSTGE(I,J)%NAVG(JJ) )
!/T5            END DO
!/T5          END DO
!
!/T6        DO J=1, NRGRD
!/T6          IF ( I .EQ. J ) CYCLE
!/T6          IF ( EQSTGE(I,J)%NSND .EQ. 0 ) THEN
!/T6              WRITE (MDST,9240) J
!/T6            ELSE
!/T6              WRITE (MDST,9241) J
!/T6              DO JJ=1, EQSTGE(I,J)%NSND
!/T6                WRITE (MDST,9242) JJ, EQSTGE(I,J)%SIS(JJ),        &
!/T6                                      EQSTGE(I,J)%SJS(JJ),        &
!/T6                                      EQSTGE(I,J)%SI1(JJ),        &
!/T6                                      EQSTGE(I,J)%SI2(JJ),        &
!/T6                                      EQSTGE(I,J)%SIP(JJ),        &
!/T6                                      EQSTGE(I,J)%STG(JJ)
!/T6                END DO
!/T6            END IF
!/T6          END DO
!
! ... End of loop started in 3.a
!
        DEALLOCATE ( MAP3D, WGT3D )
        END DO
!
! -------------------------------------------------------------------- /
! 5.  Generate GRDEQL
! 5.a Size of array
!
      NREC   = 0
!
      DO I=1, NRGRD
        DO J=1, NRGRD
          IF ( I.EQ.J .OR. STORES(I,J)%NFIN.EQ.0 ) CYCLE
          NREC(I) = NREC(I) + 1
          END DO
        END DO
!
      NA     = MAXVAL(NREC)
      ALLOCATE ( GRDEQL(NRGRD,0:NA) )
      GRDEQL = 0
!
!/T      WRITE (MDST,9050) NA
!
! 5.b Fill array
!
      DO I=1, NRGRD
        GRDEQL(I,0) = NREC(I)
        JJ          = 0
        DO J=1, NRGRD
          IF ( I.EQ.J .OR. STORES(I,J)%NFIN.EQ.0 ) CYCLE
          JJ           = JJ + 1
          GRDEQL(I,JJ) = J
          END DO
        END DO
!
!/T      WRITE (MDST,9051)
!/T      DO I=1, NRGRD
!/T        WRITE (MDST,9052) I, GRDEQL(I,0:GRDEQL(I,0))
!/T        END DO
!
! 5.c Resolution test
!
      IF ( FLAGLL ) THEN
          FACTOR = 1.
        ELSE
          FACTOR = 1.E-3
        END IF
!
      DO I=1, NRGRD
        CALL W3SETG ( I, MDSE, MDST )
        DO JJ=1, GRDEQL(I,0)
          J      = GRDEQL(I,JJ)
          IF ( SX/GRIDS(J)%SX .GT. FACMAX     .OR.                    &
               SX/GRIDS(J)%SX .LT. 1./FACMAX  .OR.                    &
               SY/GRIDS(J)%SY .GT. FACMAX     .OR.                    &
               SY/GRIDS(J)%SY .LT. 1./FACMAX ) THEN
              IF ( IMPROC.EQ.NMPERR ) WRITE(MDSE,1050) I, FACTOR*SX,  &
                  FACTOR*SY, J, FACTOR*GRIDS(J)%SX, FACTOR*GRIDS(J)%SY
              CALL EXTCDE ( 1050 )
            ENDIF
          END DO
        END DO
!
! 5.d Group number test
!
      DO I=1, NRGRD
        IF ( GRDEQL(I,0) .GE. 2 ) THEN
            TGRP   = GRGRP(GRDEQL(I,1))
            DO J=2, GRDEQL(I,0)
              IF ( GRGRP(GRDEQL(I,J)) .NE. TGRP ) THEN
                  IF ( IMPROC .EQ. NMPERR ) WRITE(MDSE,1051)          &
                                   GRDEQL(I,1), GRGRP(GRDEQL(I,1)),   &
                                   GRDEQL(I,J), GRGRP(GRDEQL(I,J))
                  CALL EXTCDE ( 1051 )
                END IF
              END DO
          END IF
        END DO
!
! -------------------------------------------------------------------- /
! 6.  Final clean up
!
      DO I=1, NRGRD
        DO J=1, NRGRD
          IF ( STORES(I,J)%INIT ) DEALLOCATE                          &
                         ( STORES(I,J)%IX  , STORES(I,J)%IY  ,        &
                           STORES(I,J)%NAV , STORES(I,J)%FLA ,        &
                           STORES(I,J)%ISS , STORES(I,J)%JSS ,        &
                           STORES(I,J)%IPS , STORES(I,J)%ITG ,        &
                           STORES(I,J)%AWG )
          END DO
        END DO
!
      DEALLOCATE ( SHRANK, STORES, NREC, NSND, NTPP )
!
      RETURN
!
! Formats
!
 1000 FORMAT (/' *** WAVEWATCH III ERROR IN WMGEQL : *** '/           &
               '     UNCOVERED EDGE POINTS FOR GRID',I4,'  (',I6,')'/)
 1001 FORMAT ( '     GRID',I4,'  POINT',2I5,' NOT COVERED (WMGEQL)')
 1002 FORMAT ( '     DIAGNOSTICS IX AND IY RANGE:',4I6)
 1003 FORMAT (/'     SHOWING ',A/)
 1004 FORMAT (2X,65I2)
 1005 FORMAT (/'     SHOWING IX RANGE ',2I6)
 1006 FORMAT ( '        (WILL NOT PRINT ANY MORE UNCOVERED POINTS)')
!
 1020 FORMAT (/' *** WAVEWATCH III WARNING WMGEQL : *** '/            &
       '     REMOVED BOUNDARY POINT FROM OPEN EDGE DISTANCE MAP'/     &
       '     GRID, IX, IY :',3I6)
!
 1050 FORMAT (/' *** WAVEWATCH III ERROR IN WMGEQL : *** '/           &
               '     GRID INCREMENTS TOO DIFFERENT '/                 &
               '     GRID',I4,'   INCREMENTS ',2F8.2/                 &
               '     GRID',I4,'   INCREMENTS ',2F8.2/)
 1051 FORMAT (/' *** WAVEWATCH III ERROR IN WMGEQL : *** '/           &
               '     OVERLAPPING GRIDS NEED TO BE IN SAME GROUP '/    &
               '         GRID',I4,' IN GROUP',I4/                     &
               '         GRID',I4,' IN GROUP',I4/)
!
!/T 9010 FORMAT ( ' TEST WMGEQL : STARTING LOOP OVER GRIDS')
!/T 9011 FORMAT ( ' TEST WMGEQL : I, RANK :',2I4)
!/T 9012 FORMAT ( '               GRID ',I3,' HAS SAME RANK')
!/T 9013 FORMAT ( '               ',A)
!
!/T 9020 FORMAT ( ' TEST WMGEQL : GENERATING DISTANCE MAP GRID ',I3)
!/T 9024 FORMAT ( ' TEST WMGEQL : FINAL MAP FOR X RANGE ',2I6)
!/T 9025 FORMAT (2X,65I2)
!
!/T 9030 FORMAT ( ' TEST WMGEQL : DEPENDENCE INFORMATION GRID ',I3)
!/T 9031 FORMAT ( '               CHECKING GRID ',I3)
!/T 9032 FORMAT ( '               POINTS USED/AVAIL :',2I6)
!/T 9033 FORMAT ( '               TOTAL/GRIDS/OUT   :',3I6)
!/T 9034 FORMAT ( '               LOCAL PER GRID    :',15I6)
!/T 9035 FORMAT ( '               SENDING PER GRID  :',15I6)
!/T 9036 FORMAT ( ' TEST WMGEQL : NUMBER OF CONTRIBUTING GRIDS MAP')
!/T 9037 FORMAT (2X,65I2)
!
!/T 9040 FORMAT ( ' TEST WMGEQL : GRID ',I2,'-',I2,' CLEAR STORAGE')
!/T 9041 FORMAT ( ' TEST WMGEQL : GRID ',I2,'-',I2,' STORAGE SIZE',I6)
!/T 9042 FORMAT ( '               RECV ',I2,'-',I2,' CLEAR STORAGE')
!/T 9043 FORMAT ( '               RECV ',I2,'-',I2,' STORAGE SIZE',2I6)
!/T 9044 FORMAT ( '               SEND ',I2,'-',I2,' CLEAR STORAGE')
!/T 9045 FORMAT ( '               SEND ',I2,'-',I2,' STORAGE SIZE',I6)
!
!/T 9050 FORMAT ( ' TEST WMGEQL : GRDEQL DIMENSIONED AT ',I2)
!/T 9051 FORMAT ( ' TEST WMGEQL : GRDEQL :')
!/T 9052 FORMAT ( '                 ',2i4,' : ',20I3)
!
!/T5 9140 FORMAT ( ' TEST WMGEQL : NO RECEIVING DATA FOR GRID ',I3,   &
!/T5               ' <=====================================')
!/T5 9141 FORMAT ( ' TEST WMGEQL : RECEIVING DATA GRID ',I3,          &
!/T5               ' <=====================================')
!/T5 9142 FORMAT ( '               RECEIVING FROM GRID(S) ',10I3)
!/T5 9143 FORMAT (16X,'COUNT, ISEA, JSEA, WEIGHT / ',                 &
!/T5               'COUNT WEIGHT NR PER GRID')
!/T5 9144 FORMAT (I6,F6.2,I6)
!/T5 9145 FORMAT (12X,3I6,F6.2,10(' - ',A))
!/T5 9146 FORMAT ( ' TEST WMGEQL : RECEIVING DATA AVG. GRID ',I3)
!/T5 9147 FORMAT (12X,I6,I2,4(F8.2,I4,I6))
!
!/T6 9240 FORMAT ( ' TEST WMGEQL : NO SENDING DATA FOR GRID ',I3,     &
!/T6               ' <=====================================')
!/T6 9241 FORMAT ( ' TEST WMGEQL : SENDING DATA GRID ',I3,            &
!/T6               ' <====================================='/         &
!/T6               11X,'COUNT, ISEA, JSEA, ARRAY IND., PROC, TAG')
!/T6 9242 FORMAT ( '              ',4I8,I4,2I8)
!
!/T7 9330 FORMAT ( ' TEST WMGEQL : FULL SOURCE INFO GRID ',I3,        &
!/T7               ' <=====================================')
!/T7 9331 FORMAT ( '               GRID ',I3,' IS NOT OF SAME RANK')
!/T7 9332 FORMAT ( '               GRID ',I3,' CONTRIBUTES TO',I6,    &
!/T7               ' GRID POINTS'/                                    &
!/T7               18X,'<---------- GRID',I6,' ---------->',          &
!/T7                4X,'<----------- GRID',I6,' ----------->'/        &
!/T7               18X,'NR   IX   IY  ISEA  JSEA  IP  WGTH',          &
!/T7                2X,'  WGTH  NA  ISEA  JSEA  IP  WGTH   TAG' )
!/T7 9333 FORMAT (15X,3I5,2I6,I4,F6.2,2X,F6.2,I4,2I6,I4,F6.2,I6)
!/T7 9334 FORMAT (64X,2I6,I4,F6.2,I6)
!/
!/ End of WMGEQL ----------------------------------------------------- /
!/
      END SUBROUTINE WMGEQL
!/ ------------------------------------------------------------------- /
      SUBROUTINE WMRSPC
!/
!/                  +-----------------------------------+
!/                  | WAVEWATCH III           NOAA/NCEP |
!/                  |           H. L. Tolman            |
!/                  |                        FORTRAN 90 |
!/                  | Last update :         30-Oct-2009 |
!/                  +-----------------------------------+
!/
!/    22-Sep-2005 : Origination.                        ( version 3.08 )
!/    25-Jul-2006 : Point output grid added.            ( version 3.10 )
!/    30-Oct-2009 : Implement run-time grid selection.  ( version 3.14 )
!/                  (W. E. Rogers & T. J. Campbell, NRL)
!/
!  1. Purpose :
!
!     Generate map with flogs for need of spectral grid conversion 
!     between models.
!
!  2. Method :
!
!     Test of parameters as introduced before in W3IOBC.
!
!  3. Parameters :
!
!  4. Subroutines used :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      STRACE    Sur.  W3SERVMD Subroutine tracing.
!     ----------------------------------------------------------------
!
!  5. Called by :
!
!      Name      Type  Module   Description
!     ----------------------------------------------------------------
!      WMINIT    Subr  WMINITMD Multi-grid model initialization.
!     ----------------------------------------------------------------
!
!  6. Error messages :
!
!  7. Remarks :
!
!  8. Structure :
!
!     See source code.
!
!  9. Switches :
!
!     !/S    Enable subroutine tracing.
!     !/T    Enable test output
!
! 10. Source code :
!
!/ ------------------------------------------------------------------- /
!
!/S      USE W3SERVMD, ONLY: STRACE
!
      USE W3GDATMD
      USE W3ODATMD, ONLY: UNIPTS
      USE WMMDATMD
!
      IMPLICIT NONE
!/
!/ ------------------------------------------------------------------- /
!/ Parameter list
!/
!/ ------------------------------------------------------------------- /
!/ Local parameters
!/
      INTEGER                 :: I, J, LOW
!/S      INTEGER, SAVE           :: IENT = 0
!/
!/S      CALL STRACE (IENT, 'WMRSPC')
!
! -------------------------------------------------------------------- /
! 0.  Initializations
!
      IF ( UNIPTS ) THEN
          LOW    = 0
        ELSE
          LOW    = 1
        END IF
      IF ( .NOT. ALLOCATED(RESPEC) )                                  &
                 ALLOCATE ( RESPEC(LOW:NRGRD,LOW:NRGRD) )
      RESPEC = .FALSE.
!
! -------------------------------------------------------------------- /
! 1.  Fill map with flags
!
      DO I=LOW, NRGRD
        DO J=I+1, NRGRD
          RESPEC(I,J) = SGRDS(I)%NK    .NE. SGRDS(J)%NK     .OR.      &
                        SGRDS(I)%NTH   .NE. SGRDS(J)%NTH    .OR.      &
                        SGRDS(I)%XFR   .NE. SGRDS(J)%XFR    .OR.      &
                        SGRDS(I)%FR1   .NE. SGRDS(J)%FR1    .OR.      &
                        SGRDS(I)%TH(1) .NE. SGRDS(J)%TH(1)
          RESPEC(J,I) = RESPEC(I,J)
          END DO
        END DO
!
! -------------------------------------------------------------------- /
! 2.  Test output
!
!/T      WRITE (MDST,9000)
!/T      DO I=LOW, NRGRD
!/T        WRITE (MDST,9001) I, RESPEC(I,:)
!/T        END DO
!
      RETURN
!
! Formats
!
!/T 9000 FORMAT ( 'TEST WMRSPC : MAP RESPEC FILLED ')
!/T 9001 FORMAT ( '              ',I4,' : ',20L2)
!/
!/ End of WMRSPC ----------------------------------------------------- /
!/
      END SUBROUTINE WMRSPC
!/
!/ End of module WMGRIDMD -------------------------------------------- /
!/
      END MODULE WMGRIDMD
