#include "w3macros.h" 
!/ ------------------------------------------------------------------- /

module w3namlmd

!/ ------------------------------------------------------------------- /

  ! module defaults
  implicit none

  public

  ! domain definition structure
  type domain_def_t
    integer                     :: nrinp
    integer                     :: nrgrd
    integer                     :: nmove
    logical                     :: unipts
    integer                     :: iostyp
    logical                     :: upproc
    logical                     :: pshare
    logical                     :: flghg1
    logical                     :: flghg2
    character(15)               :: start
    character(15)               :: stop
  end type domain_def_t



  ! model grid data structure
  type model_forcing_t
    character(10)               :: water_levels
    character(10)               :: currents
    character(10)               :: winds
    character(10)               :: ice_conc
    character(10)               :: ice_param1
    character(10)               :: ice_param2
    character(10)               :: ice_param3
    character(10)               :: ice_param4
    character(10)               :: ice_param5
    character(10)               :: mud_density
    character(10)               :: mud_thickness
    character(10)               :: mud_viscosity
  end type model_forcing_t
!
  type model_assim_t
    character(10)               :: mean
    character(10)               :: spec1d
    character(10)               :: spec2d
  end type model_assim_t
!
  type model_resource_t
    integer                     :: rank_id
    integer                     :: group_id
    integer                     :: sibling_id
    real(4)                     :: comm_frac(2)
    logical                     :: bound_flag
  end type model_resource_t
!
  type model_grid_t 
    character(10)               :: name
    type(model_forcing_t)       :: forcing
    type(model_assim_t)         :: assim
    type(model_resource_t)      :: resource
  end type model_grid_t



  ! input grid data structure
  type input_forcing_t
    logical                     :: water_levels
    logical                     :: currents
    logical                     :: winds
    logical                     :: ice_conc
    logical                     :: ice_param1
    logical                     :: ice_param2
    logical                     :: ice_param3
    logical                     :: ice_param4
    logical                     :: ice_param5
    logical                     :: mud_density
    logical                     :: mud_thickness
    logical                     :: mud_viscosity
  end type input_forcing_t
!
  type input_assim_t
    logical                     :: mean
    logical                     :: spec1d
    logical                     :: spec2d
  end type input_assim_t
!
  type input_grid_t
    character(10)               :: name
    type(input_forcing_t)       :: forcing
    type(input_assim_t)         :: assim
  end type input_grid_t



  ! output type structure
  type point_t
    character(10)               :: name
    character(64)               :: file
  end type point_t
!
  type field_t
    character(1024)             :: list
  end type field_t
!
  type track_t
    logical                     :: format
  end type track_t
!
  type partition_t
    integer                     :: x0
    integer                     :: xn
    integer                     :: nx
    integer                     :: y0
    integer                     :: yn
    integer                     :: ny
    logical                     :: format
  end type partition_t
!
!/COU  type coupling_t
!/COU    character(1024)             :: list
!/COU  end type coupling_t
!
  type output_type_t
    type(point_t)               :: point
    type(field_t)               :: field
    type(track_t)               :: track
    type(partition_t)           :: partition
!/COU    type(coupling_t)           :: coupling
  end type output_type_t



  ! output date structure
  type output_time_t 
    character(15)               :: start
    character(15)               :: stride
    character(15)               :: stop
  end type output_time_t
!
  type output_date_t
    type(output_time_t)         :: field
    type(output_time_t)         :: point
    type(output_time_t)         :: track
    type(output_time_t)         :: restart
    type(output_time_t)         :: boundary
    type(output_time_t)         :: partition
!/COU    type(output_time_t)         :: coupling
  end type output_date_t



  ! homogeneous input structure
  type homogeneous_field_t
    character(15)               :: start
    real                        :: speed
    real                        :: direction
    real                        :: gradient    
  end type homogeneous_field_t
!
  type homogeneous_input_t
    type(homogeneous_field_t)   :: moving
  end type homogeneous_input_t



  ! miscellaneous
  character(256)                :: msg



  contains

!/ ------------------------------------------------------------------- /

  subroutine namlmultidef (MPI_COMM, ndsi, infil, domain_def, ierr)

    USE WMMDATMD, ONLY: MDSE, MDSS, IMPROC, NMPLOG
!/MPI      USE WMMDATMD, ONLY: MPI_COMM_MWAVE
    IMPLICIT NONE

    integer, intent(in)                       :: MPI_COMM, ndsi
    character*(*), intent(in)                 :: infil
    type(domain_def_t), intent(out)           :: domain_def 
    integer, intent(out)                      :: ierr
!/MPI      INTEGER                                 :: IERR_MPI

    ierr = 0

!/MPI      MPI_COMM_MWAVE = MPI_COMM
!/MPI      CALL MPI_COMM_RANK ( MPI_COMM_MWAVE, IMPROC, IERR_MPI )
!/MPI      IMPROC = IMPROC + 1


    ! open input file
    open (ndsi, file=trim(infil), form='formatted', status='old', iostat=ierr)
    if (ierr.ne.0) then
      write (MDSE,'(a)') 'ERROR: open input file '//trim(infil)//' failed'
      return
    endif

    ! read domain def namelist
    call read_domain_def_nml (ndsi, domain_def, ierr)
    if (ierr.ne.0) then
      write (MDSE,'(a)') 'ERROR: error occured in read_model_def_nml'
      return
    endif
!/T    IF ( IMPROC .EQ. NMPLOG ) call report_domain_def_nml (domain_def)

    ! close namelist file
    close (ndsi)

  end subroutine namlmultidef

!/ ------------------------------------------------------------------- /

  subroutine namlmulticonf (MPI_COMM, ndsi, infil, domain_def, &
                            input_grid, model_grid, output_type, output_date, &
                            homogeneous_input, ierr)

    USE WMMDATMD, ONLY: MDSE, MDSS, IMPROC, NMPLOG
!/MPI      USE WMMDATMD, ONLY: MPI_COMM_MWAVE
    IMPLICIT NONE

    integer, intent(in)                       :: MPI_COMM, ndsi
    character*(*), intent(in)                 :: infil
    type(domain_def_t), intent(inout)         :: domain_def
    type(input_grid_t), intent(inout)         :: input_grid(:) 
    type(model_grid_t), intent(inout)         :: model_grid(:) 
    type(output_type_t), intent(inout)        :: output_type(:)
    type(output_date_t), intent(inout)        :: output_date(:)
    type(homogeneous_input_t), intent(inout)  :: homogeneous_input(:)
    integer, intent(out)                      :: ierr
!/MPI      INTEGER                                 :: IERR_MPI

    ierr = 0

!/MPI      MPI_COMM_MWAVE = MPI_COMM
!/MPI      CALL MPI_COMM_RANK ( MPI_COMM_MWAVE, IMPROC, IERR_MPI )
!/MPI      IMPROC = IMPROC + 1


    ! open input file
    open (ndsi, file=trim(infil), form='formatted', status='old', iostat=ierr)
    if (ierr.ne.0) then
      write (*,'(a)') 'ERROR: open input file '//trim(infil)//' failed'
      return
    endif

    ! read input grid namelist
    call read_input_grid_nml (ndsi, domain_def%nrinp, input_grid, ierr)
    if (ierr.ne.0) then
      write (MDSE,'(a)') 'ERROR: error occured in read_input_grid_nml'
      return
    endif
!/T    IF ( IMPROC .EQ. NMPLOG ) call report_input_grid_nml (domain_def%nrinp, input_grid)

    ! read model grid namelist
    call read_model_grid_nml (ndsi, domain_def%nrgrd, model_grid, ierr)
    if (ierr.ne.0) then
      write (MDSE,'(a)') 'ERROR: error occured in read_model_grid_nml'
      return
    endif
!/T    IF ( IMPROC .EQ. NMPLOG ) call report_model_grid_nml (domain_def%nrgrd, model_grid)

    ! read output type namelist
    call read_output_type_nml (ndsi, domain_def%unipts, domain_def%nrgrd, output_type, ierr)
    if (ierr.ne.0) then
      write (MDSE,'(a)') 'ERROR: error occured in read_output_type_nml'
      return
    endif
!/T    IF ( IMPROC .EQ. NMPLOG ) call report_output_type_nml (domain_def%nrgrd, output_type)

    ! read output date namelist
    call read_output_date_nml (ndsi, domain_def%nrgrd, output_date, ierr)
    if (ierr.ne.0) then
      write (MDSE,'(a)') 'ERROR: error occured in read_output_date_nml'
      return
    endif
!/T    IF ( IMPROC .EQ. NMPLOG ) call report_output_date_nml (domain_def%nrgrd,output_date)

    ! read homogeneous input namelist
    call read_homogeneous_input_nml (ndsi, domain_def%nmove, homogeneous_input, ierr)
    if (ierr.ne.0) then
      write (MDSE,'(a)') 'ERROR: error occured in read_homogeneous_input_nml'
      return
    endif
!/T    IF ( IMPROC .EQ. NMPLOG ) call report_homogeneous_input_nml (domain_def%nmove, homogeneous_input)


    ! close namelist file
    close (ndsi)

  end subroutine namlmulticonf

!/ ------------------------------------------------------------------- /











!/ ------------------------------------------------------------------- /

  subroutine read_domain_def_nml (ndsi, domain_def, ierr)

    USE WMMDATMD, ONLY: MDSE, MDSS
    IMPLICIT NONE

    integer, intent(in)               :: ndsi
    type(domain_def_t), intent(out)   :: domain_def
    integer, intent(out)              :: ierr

    ! locals
    type(domain_def_t) :: domain
    namelist /domain_def_nml/ domain

    ierr = 0

    ! set default values for model definition data
    domain%nrinp  = 0
    domain%nrgrd  = 1
    domain%nmove  = 0
    domain%unipts = .false.
    domain%iostyp = 1
    domain%upproc = .false.
    domain%pshare = .false.
    domain%flghg1 = .true.
    domain%flghg2 = .true.
    domain%start  = '19680606 000000'
    domain%stop   = '19680607 000000'

    ! read model def namelist
    rewind (ndsi)
    read (ndsi, nml=domain_def_nml, iostat=ierr, iomsg=msg)
    if (ierr.ne.0) then
      write (MDSE,'(a,/a)') &
        'ERROR: read_domain_def_nml: namelist read error', &
        'ERROR: '//trim(msg)
      return
    endif

    ! set/check return values
    if (domain%nrinp.lt.0) then
      write (MDSE,'(a,i3)') 'ERROR: bad nrinp input: ',domain%nrinp
      ierr = 1
      return
    endif
    if (domain%nrgrd.le.0) then
      write (MDSE,'(a,i3)') 'ERROR: bad nrgrd input: ',domain%nrgrd
      ierr = 1
      return
    endif
    if (domain%iostyp.lt.0.or.domain%iostyp.gt.3) then
      write (MDSE,'(a,i3)') 'ERROR: bad iostyp input: ',domain%iostyp
      ierr = 1
      return
    endif
    domain_def = domain

  end subroutine read_domain_def_nml

!/ ------------------------------------------------------------------- /

  subroutine read_input_grid_nml (ndsi, nrinp, input_grid, ierr)

    USE WMMDATMD, ONLY: MDSE, MDSS
    IMPLICIT NONE

    integer, intent(in)               :: ndsi, nrinp
    type(input_grid_t), intent(inout) :: input_grid(nrinp)
    integer, intent(out)              :: ierr

    ! locals
    integer, parameter :: max_nrinp = 99
    type(input_grid_t) :: input(max_nrinp)
    namelist /input_grid_nml/ input
    integer            :: i

    ierr = 0

    ! test nrinp
    if (nrinp.gt.max_nrinp) then
      write (MDSE,'(a,/a,i6,/a,i6)') &
        'ERROR: read_input_grid_nml: nrinp > max_nrinp',      &
        'ERROR: read_input_grid_nml:     nrinp = ',    nrinp, &
        'ERROR: read_input_grid_nml: max_nrinp = ',max_nrinp
        ierr = 1
        return
    endif

    ! if number of input grids == 0, then return
    if (nrinp.eq.0) return

    ! set default values for grid input data
    do i = 1,nrinp
      input(i)%name                  = 'unset'
      input(i)%forcing%water_levels  = .false.
      input(i)%forcing%currents      = .false.
      input(i)%forcing%winds         = .false.
      input(i)%forcing%ice_conc      = .false.
      input(i)%forcing%ice_param1    = .false.
      input(i)%forcing%ice_param2    = .false.
      input(i)%forcing%ice_param3    = .false.
      input(i)%forcing%ice_param4    = .false.
      input(i)%forcing%ice_param5    = .false.
      input(i)%forcing%mud_density   = .false.
      input(i)%forcing%mud_thickness = .false.
      input(i)%forcing%mud_viscosity = .false.
      input(i)%assim%mean            = .false.
      input(i)%assim%spec1d          = .false.
      input(i)%assim%spec2d          = .false.
    enddo

    ! read input grid namelist
    rewind (ndsi)
    read (ndsi, nml=input_grid_nml, iostat=ierr, iomsg=msg)
    if (ierr.ne.0) then
      write (MDSE,'(a,/a)') &
        'ERROR: read_input_grid_nml: namelist read error', &
        'ERROR: '//trim(msg)
      return
    endif

    ! set/check return values
    do i = 1,nrinp
      if (trim(input(i)%name).eq.'unset') then
        write (MDSE,10) 'ERROR: read_input_grid_nml: required input(',i,')%name not set'
        ierr = 1
      endif
      input_grid(i) = input(i)
    enddo
10  format (a,i0,a)

  end subroutine read_input_grid_nml

!/ ------------------------------------------------------------------- /

  subroutine read_model_grid_nml (ndsi, nrgrd, model_grid, ierr)

    USE WMMDATMD, ONLY: MDSE, MDSS
    IMPLICIT NONE

    integer, intent(in)               :: ndsi, nrgrd
    type(model_grid_t), intent(inout) :: model_grid(nrgrd)
    integer, intent(out)              :: ierr

    ! locals
    integer, parameter :: max_nrgrd = 99
    type(model_grid_t) :: model(max_nrgrd)
    namelist /model_grid_nml/ model
    integer            :: i

    ierr = 0

    ! test nrgrd
    if (nrgrd.gt.max_nrgrd) then
      write (MDSE,'(a,/a,i6,/a,i6)') &
        'ERROR: read_model_grid_nml: nrgrd > max_nrgrd',      &
        'ERROR: read_model_grid_nml:     nrgrd = ',    nrgrd, &
        'ERROR: read_model_grid_nml: max_nrgrd = ',max_nrgrd
        ierr = 1
        return
    endif

    ! set default values for model input data
    do i = 1,nrgrd
      model(i)%name                  = 'unset'
      model(i)%forcing%water_levels  = 'no'
      model(i)%forcing%currents      = 'no'
      model(i)%forcing%winds         = 'no'
      model(i)%forcing%ice_conc      = 'no'
      model(i)%forcing%ice_param1    = 'no'
      model(i)%forcing%ice_param2    = 'no'
      model(i)%forcing%ice_param3    = 'no'
      model(i)%forcing%ice_param4    = 'no'
      model(i)%forcing%ice_param5    = 'no'
      model(i)%forcing%mud_density   = 'no'
      model(i)%forcing%mud_thickness = 'no'
      model(i)%forcing%mud_viscosity = 'no'
      model(i)%assim%mean            = 'no'
      model(i)%assim%spec1d          = 'no'
      model(i)%assim%spec2d          = 'no'
      model(i)%resource%rank_id      = i
      model(i)%resource%group_id     = 1
      model(i)%resource%sibling_id   = 0
      model(i)%resource%comm_frac    = (/0.00,1.00/)
      model(i)%resource%bound_flag   = .false.
    enddo

    ! read model model namelist
    rewind (ndsi)
    read (ndsi, nml=model_grid_nml, iostat=ierr, iomsg=msg)
    if (ierr.ne.0) then
      write (MDSE,'(a,/a)') &
        'ERROR: read_model_grid_nml: namelist read error', &
        'ERROR: '//trim(msg)
      return
    endif

    ! set/check return values
    do i = 1,nrgrd
      if (trim(model(i)%name).eq.'unset') then
        write (MDSE,10) 'ERROR: read_model_grid_nml: required model(',i,')%name not set'
        ierr = 1
      endif
      model_grid(i) = model(i)
    enddo

10  format (a,i0,a)

  end subroutine read_model_grid_nml

!/ ------------------------------------------------------------------- /

  subroutine read_output_type_nml (ndsi, unipts, nrgrd, output_type, ierr)

    USE WMMDATMD, ONLY: MDSE, MDSS
    IMPLICIT NONE

    integer, intent(in)                :: ndsi, nrgrd
    logical, intent(in)                :: unipts
    type(output_type_t), intent(inout) :: output_type(nrgrd)
    integer, intent(out)               :: ierr

    ! locals
    integer, parameter  :: max_nrgrd = 99
    type(output_type_t) :: alltype
    type(output_type_t) :: itype(max_nrgrd)
    namelist /output_type_nml/ alltype, itype
    integer             :: i, j

    ierr = 0

    ! set default values for output type data
    do i=1,nrgrd
      itype(i)%point%name   = 'unset'
      itype(i)%point%file   = 'unset'
      itype(i)%field%list   = 'unset'
      itype(i)%track%format = .true.
      itype(i)%partition%x0 = 0
      itype(i)%partition%xn = 0
      itype(i)%partition%nx = 0
      itype(i)%partition%y0 = 0
      itype(i)%partition%yn = 0
      itype(i)%partition%ny = 0
      itype(i)%partition%format = .true.
!/COU      itype(i)%coupling%list   = 'unset'
    enddo
    alltype%point%name   = 'unset'
    alltype%point%file   = 'unset'
    alltype%field%list   = 'unset'
    alltype%track%format = .true.
    alltype%partition%x0 = 0
    alltype%partition%xn = 0
    alltype%partition%nx = 0
    alltype%partition%y0 = 0
    alltype%partition%yn = 0
    alltype%partition%ny = 0
    alltype%partition%format = .true.
!/COU    alltype%coupling%list   = 'unset'


    ! read output_type namelist
    rewind (ndsi)
    read (ndsi, nml=output_type_nml, iostat=ierr, iomsg=msg)
    if (ierr.ne.0) then
      write (MDSE,'(a,/a)') &
        'ERROR: read_output_type_nml: namelist read error', &
        'ERROR: '//trim(msg)
      return
    endif

    do i=1,nrgrd
      itype(i) = alltype
    end do

    ! read output_type namelist
    rewind (ndsi)
    read (ndsi, nml=output_type_nml, iostat=ierr, iomsg=msg)
    if (ierr.ne.0) then
      write (MDSE,'(a,/a)') &
        'ERROR: read_output_type_nml: namelist read error', &
        'ERROR: '//trim(msg)
      return
    endif

    do i=1,nrgrd
      output_type(i) = itype(i)
    end do
   
  end subroutine read_output_type_nml

!/ ------------------------------------------------------------------- /

  subroutine read_output_date_nml (ndsi, nrgrd, output_date, ierr)

    USE WMMDATMD, ONLY: MDSE, MDSS
    IMPLICIT NONE

    integer, intent(in)                :: ndsi, nrgrd
    type(output_date_t), intent(inout) :: output_date(nrgrd)
    integer, intent(out)               :: ierr

    ! locals
    integer, parameter  :: max_nrgrd = 99
    type(output_date_t) :: alldate
    type(output_date_t) :: idate(max_nrgrd)
    namelist /output_date_nml/ alldate, idate
    integer             :: i

    ierr = 0

    ! set default values for output_date input data
    do i=1,nrgrd
      idate(i)%field%start = '19680606 000000'
      idate(i)%field%stride = '0'
      idate(i)%field%stop = '19680607 000000'
      idate(i)%point%start = '19680606 000000'
      idate(i)%point%stride = '0'
      idate(i)%point%stop = '19680607 000000'
      idate(i)%track%start = '19680606 000000'
      idate(i)%track%stride = '0'
      idate(i)%track%stop = '19680607 000000'
      idate(i)%restart%start = '19680606 000000'
      idate(i)%restart%stride = '0'
      idate(i)%restart%stop = '19680607 000000'
      idate(i)%boundary%start = '19680606 000000'
      idate(i)%boundary%stride = '0'
      idate(i)%boundary%stop = '19680607 000000'
      idate(i)%partition%start = '19680606 000000'
      idate(i)%partition%stride = '0'
      idate(i)%partition%stop = '19680607 000000'
!/COU      idate(i)%coupling%start = '19680606 000000'
!/COU      idate(i)%coupling%stride = '0'
!/COU      idate(i)%coupling%stop = '19680607 000000'
    end do
    alldate%field%start = '19680606 000000'
    alldate%field%stride = '0'
    alldate%field%stop = '19680607 000000'
    alldate%point%start = '19680606 000000'
    alldate%point%stride = '0'
    alldate%point%stop = '19680607 000000'
    alldate%track%start = '19680606 000000'
    alldate%track%stride = '0'
    alldate%track%stop = '19680607 000000'
    alldate%restart%start = '19680606 000000'
    alldate%restart%stride = '0'
    alldate%restart%stop = '19680607 000000'
    alldate%boundary%start = '19680606 000000'
    alldate%boundary%stride = '0'
    alldate%boundary%stop = '19680607 000000'
    alldate%partition%start = '19680606 000000'
    alldate%partition%stride = '0'
    alldate%partition%stop = '19680607 000000'
!/COU    alldate%coupling%start = '19680606 000000'
!/COU    alldate%coupling%stride = '0'
!/COU    alldate%coupling%stop = '19680607 000000'


    ! read output_date namelist
    rewind (ndsi)
    read (ndsi, nml=output_date_nml, iostat=ierr, iomsg=msg)
    if (ierr.ne.0) then
      write (MDSE,'(a,/a)') &
        'ERROR: read_output_date_nml: namelist read error', &
        'ERROR: '//trim(msg)
      return
    endif

    do i=1,nrgrd
      idate(i) = alldate
    end do

    ! read output_date namelist
    rewind (ndsi)
    read (ndsi, nml=output_date_nml, iostat=ierr, iomsg=msg)
    if (ierr.ne.0) then
      write (MDSE,'(a,/a)') &
        'ERROR: read_output_date_nml: namelist read error', &
        'ERROR: '//trim(msg)
      return
    endif

    do i=1,nrgrd
      output_date(i) = idate(i)
    end do


  end subroutine read_output_date_nml

!/ ------------------------------------------------------------------- /

  subroutine read_homogeneous_input_nml (ndsi, nmove, homogeneous_input, ierr)

    USE WMMDATMD, ONLY: MDSE, MDSS
    IMPLICIT NONE

    integer, intent(in)                      :: ndsi, nmove
    type(homogeneous_input_t), intent(inout) :: homogeneous_input(nmove)
    integer, intent(out)                     :: ierr

    ! locals
    integer, parameter        :: max_nmove = 99
    integer                   :: i
    type(homogeneous_input_t) :: homogeneous(max_nmove)
    namelist /homogeneous_input_nml/ homogeneous

    ierr = 0

    ! set default values for homogeneous input data
    do i=1,nmove
      homogeneous(i)%moving%start     = '19680606 000000'
      homogeneous(i)%moving%speed     = 0.
      homogeneous(i)%moving%direction = 0.
      homogeneous(i)%moving%gradient  = 0.
    enddo

    ! read homogeneous_input namelist
    rewind (ndsi)
    read (ndsi, nml=homogeneous_input_nml, iostat=ierr, iomsg=msg)
    if (ierr.ne.0) then
      write (MDSE,'(a,/a)') &
        'ERROR: read_homogeneous_input_nml: namelist read error', &
        'ERROR: '//trim(msg)
      return
    endif

    do i=1,nmove
      homogeneous_input(i) = homogeneous(i)
    end do
    
  end subroutine read_homogeneous_input_nml

!/ ------------------------------------------------------------------- /








!/ ------------------------------------------------------------------- /

  subroutine report_domain_def_nml (domain_def)

    USE WMMDATMD, ONLY: MDSE, MDSS
    IMPLICIT NONE

    type(domain_def_t), intent(in) :: domain_def

      write (msg,'(a)') 'domain def :'
      write (MDSS,'(a)')
      write (MDSS,11) trim(msg),'nrinp  = ',domain_def%nrinp
      write (MDSS,11) trim(msg),'nrgrd  = ',domain_def%nrgrd
      write (MDSS,13) trim(msg),'unipts = ',domain_def%unipts
      write (MDSS,11) trim(msg),'iostyp = ',domain_def%iostyp
      write (MDSS,13) trim(msg),'upproc = ',domain_def%upproc
      write (MDSS,13) trim(msg),'pshare = ',domain_def%pshare
      write (MDSS,13) trim(msg),'flghg1 = ',domain_def%flghg1
      write (MDSS,13) trim(msg),'flghg2 = ',domain_def%flghg2
      write (MDSS,10) trim(msg),'start  = ',trim(domain_def%start)
      write (MDSS,10) trim(msg),'stop   = ',trim(domain_def%stop)

10  format (a,2x,a,a)
11  format (a,2x,a,i1)
13  format (a,2x,a,l1)

  end subroutine report_domain_def_nml

!/ ------------------------------------------------------------------- /

  subroutine report_input_grid_nml (nrinp, input_grid)

    USE WMMDATMD, ONLY: MDSE, MDSS
    IMPLICIT NONE

    integer, intent(in)            :: nrinp
    type(input_grid_t), intent(in) :: input_grid(nrinp)

    ! locals
    integer              :: i

    do i = 1,nrinp
      write (msg,'(a,i0.2,a)') 'input grid ',i,' :'
      write (MDSS,'(a)')
      write (MDSS,10) trim(msg),'name                     = ',trim(input_grid(i)%name)
      write (MDSS,13) trim(msg),'forcing % water_levels   = ',input_grid(i)%forcing%water_levels
      write (MDSS,13) trim(msg),'forcing % currents       = ',input_grid(i)%forcing%currents
      write (MDSS,13) trim(msg),'forcing % wind           = ',input_grid(i)%forcing%winds
      write (MDSS,13) trim(msg),'forcing % ice_conc       = ',input_grid(i)%forcing%ice_conc
      write (MDSS,13) trim(msg),'forcing % ice_param1     = ',input_grid(i)%forcing%ice_param1
      write (MDSS,13) trim(msg),'forcing % ice_param2     = ',input_grid(i)%forcing%ice_param2
      write (MDSS,13) trim(msg),'forcing % ice_param3     = ',input_grid(i)%forcing%ice_param3
      write (MDSS,13) trim(msg),'forcing % ice_param4     = ',input_grid(i)%forcing%ice_param4
      write (MDSS,13) trim(msg),'forcing % ice_param5     = ',input_grid(i)%forcing%ice_param5
      write (MDSS,13) trim(msg),'forcing % mud_density    = ',input_grid(i)%forcing%mud_density
      write (MDSS,13) trim(msg),'forcing % mud_thickness  = ',input_grid(i)%forcing%mud_thickness
      write (MDSS,13) trim(msg),'forcing % mud_viscosity  = ',input_grid(i)%forcing%mud_viscosity
      write (MDSS,13) trim(msg),'assim % mean             = ',input_grid(i)%assim%mean
      write (MDSS,13) trim(msg),'assim % spec1d           = ',input_grid(i)%assim%spec1d
      write (MDSS,13) trim(msg),'assim % spec2d           = ',input_grid(i)%assim%spec2d
    enddo
    write (*,*)

10  format (a,2x,a,a)
13  format (a,2x,a,l1)

  end subroutine report_input_grid_nml

!/ ------------------------------------------------------------------- /

  subroutine report_model_grid_nml (nrgrd, model_grid)

    USE WMMDATMD, ONLY: MDSE, MDSS
    IMPLICIT NONE

    integer, intent(in)            :: nrgrd
    type(model_grid_t), intent(in) :: model_grid(nrgrd)

    ! locals
    integer              :: i

    do i = 1,nrgrd
      write (msg,'(a,i0.4,a)') 'model grid ',i,' :'
      write (MDSS,'(a)')
      write (MDSS,10) trim(msg),'name                     = ',trim(model_grid(i)%name)
      write (MDSS,10) trim(msg),'forcing % water_levels   = ',trim(model_grid(i)%forcing%water_levels)
      write (MDSS,10) trim(msg),'forcing % currents       = ',trim(model_grid(i)%forcing%currents)
      write (MDSS,10) trim(msg),'forcing % winds          = ',trim(model_grid(i)%forcing%winds)
      write (MDSS,10) trim(msg),'forcing % ice_conc       = ',trim(model_grid(i)%forcing%ice_conc)
      write (MDSS,10) trim(msg),'forcing % ice_param1     = ',trim(model_grid(i)%forcing%ice_param1)
      write (MDSS,10) trim(msg),'forcing % ice_param2     = ',trim(model_grid(i)%forcing%ice_param2)
      write (MDSS,10) trim(msg),'forcing % ice_param3     = ',trim(model_grid(i)%forcing%ice_param3)
      write (MDSS,10) trim(msg),'forcing % ice_param4     = ',trim(model_grid(i)%forcing%ice_param4)
      write (MDSS,10) trim(msg),'forcing % ice_param5     = ',trim(model_grid(i)%forcing%ice_param5)
      write (MDSS,10) trim(msg),'forcing % mud_density    = ',trim(model_grid(i)%forcing%mud_density)
      write (MDSS,10) trim(msg),'forcing % mud_thickness  = ',trim(model_grid(i)%forcing%mud_thickness)
      write (MDSS,10) trim(msg),'forcing % mud_viscosity  = ',trim(model_grid(i)%forcing%mud_viscosity)
      write (MDSS,10) trim(msg),'assim % mean             = ',trim(model_grid(i)%assim%mean)
      write (MDSS,10) trim(msg),'assim % spec1d           = ',trim(model_grid(i)%assim%spec1d)
      write (MDSS,10) trim(msg),'assim % spec2d           = ',trim(model_grid(i)%assim%spec2d)
      write (MDSS,11) trim(msg),'resource % rank_id       = ',model_grid(i)%resource%rank_id
      write (MDSS,11) trim(msg),'resource % group_id      = ',model_grid(i)%resource%group_id
      write (MDSS,11) trim(msg),'resource % sibling_id    = ',model_grid(i)%resource%sibling_id
      write (MDSS,12) trim(msg),'resource % comm_frac     = ',model_grid(i)%resource%comm_frac(1), &
                                                              model_grid(i)%resource%comm_frac(2)
      write (MDSS,13) trim(msg),'resource % bound_flag    = ',model_grid(i)%resource%bound_flag
    enddo
    write (MDSS,'(a)')

10  format (a,2x,a,a)
11  format (a,2x,a,i1)
12  format (a,2x,a,'(',f5.2,',',f5.2,' )')
13  format (a,2x,a,l1)

  end subroutine report_model_grid_nml

!/ ------------------------------------------------------------------- /

  subroutine report_output_type_nml (nrgrd, output_type)

    USE WMMDATMD, ONLY: MDSE, MDSS
    IMPLICIT NONE

    integer, intent(in)             :: nrgrd
    type(output_type_t), intent(in) :: output_type(nrgrd)

    ! locals
    integer              :: i

    do i=1,nrgrd
      write (msg,'(a,i1,a)') 'output type model grid',i, ' :'
      write (MDSS,'(a)')
      write (MDSS,10) trim(msg),'point % name         = ',trim(output_type(i)%point%name)
      write (MDSS,10) trim(msg),'point % file         = ',trim(output_type(i)%point%file)
      write (MDSS,10) trim(msg),'field % list         = ',trim(output_type(i)%field%list)
      write (MDSS,13) trim(msg),'track % format       = ',output_type(i)%track%format
      write (MDSS,11) trim(msg),'partition % x0       = ',output_type(i)%partition%x0
      write (MDSS,11) trim(msg),'partition % xn       = ',output_type(i)%partition%xn
      write (MDSS,11) trim(msg),'partition % nx       = ',output_type(i)%partition%nx
      write (MDSS,11) trim(msg),'partition % y0       = ',output_type(i)%partition%y0
      write (MDSS,11) trim(msg),'partition % yn       = ',output_type(i)%partition%yn
      write (MDSS,11) trim(msg),'partition % ny       = ',output_type(i)%partition%ny
      write (MDSS,13) trim(msg),'partition % format   = ',output_type(i)%partition%format
!/COU      write (MDSS,10) trim(msg),'coupling % list         = ',trim(output_type(i)%coupling%list)
    end do
    write (MDSS,'(a)')

10  format (a,2x,a,a)
11  format (a,2x,a,i1)
13  format (a,2x,a,l1)

  end subroutine report_output_type_nml

!/ ------------------------------------------------------------------- /

  subroutine report_output_date_nml (nrgrd, output_date)

    USE WMMDATMD, ONLY: MDSE, MDSS
    IMPLICIT NONE

    integer, intent(in)             :: nrgrd
    type(output_date_t), intent(in) :: output_date(nrgrd)

    ! locals
    integer              :: i

    do i=1,nrgrd
      write (msg,'(a,i1,a)') 'output date model grid',i, ' :'
      write (MDSS,'(a)')
      write (MDSS,10) trim(msg),'field start        = ',trim(output_date(i)%field%start)
      write (MDSS,10) trim(msg),'field stride       = ',trim(output_date(i)%field%stride)
      write (MDSS,10) trim(msg),'field stop         = ',trim(output_date(i)%field%stop)
      write (MDSS,10) trim(msg),'point start        = ',trim(output_date(i)%point%start)
      write (MDSS,10) trim(msg),'point stride       = ',trim(output_date(i)%point%stride)
      write (MDSS,10) trim(msg),'point stop         = ',trim(output_date(i)%point%stop)
      write (MDSS,10) trim(msg),'track start        = ',trim(output_date(i)%track%start)
      write (MDSS,10) trim(msg),'track stride       = ',trim(output_date(i)%track%stride)
      write (MDSS,10) trim(msg),'track stop         = ',trim(output_date(i)%track%stop)
      write (MDSS,10) trim(msg),'restart start      = ',trim(output_date(i)%restart%start)
      write (MDSS,10) trim(msg),'restart stride     = ',trim(output_date(i)%restart%stride)
      write (MDSS,10) trim(msg),'restart stop       = ',trim(output_date(i)%restart%stop)
      write (MDSS,10) trim(msg),'boundary start     = ',trim(output_date(i)%boundary%start)
      write (MDSS,10) trim(msg),'boundary stride    = ',trim(output_date(i)%boundary%stride)
      write (MDSS,10) trim(msg),'boundary stop      = ',trim(output_date(i)%boundary%stop)
      write (MDSS,10) trim(msg),'partition start    = ',trim(output_date(i)%partition%start)
      write (MDSS,10) trim(msg),'partition stride   = ',trim(output_date(i)%partition%stride)
      write (MDSS,10) trim(msg),'partition stop     = ',trim(output_date(i)%partition%stop)
!/COU      write (MDSS,10) trim(msg),'coupling start    = ',trim(output_date(i)%coupling%start)
!/COU      write (MDSS,10) trim(msg),'coupling stride   = ',trim(output_date(i)%coupling%stride)
!/COU      write (MDSS,10) trim(msg),'coupling stop     = ',trim(output_date(i)%coupling%stop)
    end do
    write (MDSS,'(a)')

10  format (a,2x,a,a)

  end subroutine report_output_date_nml

!/ ------------------------------------------------------------------- /

  subroutine report_homogeneous_input_nml (nmove, homogeneous_input)

    USE WMMDATMD, ONLY: MDSE, MDSS
    IMPLICIT NONE

    integer, intent(in)                   :: nmove
    type(homogeneous_input_t), intent(in) :: homogeneous_input(nmove)

    ! locals
    integer              :: i

    write (msg,'(a)') 'homogeneous input :'
    write (MDSS,'(a)')
    do i=1,nmove
      write (MDSS,10) trim(msg),'moving start      = ',trim(homogeneous_input(i)%moving%start)
      write (MDSS,14) trim(msg),'moving speed      = ',homogeneous_input(i)%moving%speed
      write (MDSS,14) trim(msg),'moving direction  = ',homogeneous_input(i)%moving%direction
      write (MDSS,'(a)')
    end do

10  format (a,2x,a,a)
14  format (a,2x,a,f5.2)

  end subroutine report_homogeneous_input_nml

!/ ------------------------------------------------------------------- /





end module w3namlmd

!/ ------------------------------------------------------------------- /
