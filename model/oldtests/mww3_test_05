#!/bin/sh
#############################################################################
#                                                                           #
# mww3_test_05 : Tests for static nesting (propagation only)                #
#                Telescoping nests over hurricane, with continuous moving   #
#                grid, no outer boundaries.                                 #
#                                                                           #
# Model should be compiled with the switches :                              #
#                                                                           #
#   !/FLXn !/LNn !/STn !/NLn !/BT0 !/DB0 !/TR0 !/BS0 !/XX0                  #
#                        Deep water source term only.                       #
#   !/PRn                Selecting one of the propagation schemes.          #
#   !/WNX1 !/WNT1 !/CRX1 !/CRT1      Wind and current interpolation.        #
#   !/O0 !/O1 !/O2 !/O3 !/O4 !/O5 !/O6 !/O7 !/O10                           #
#                        Sdt out output options.                            #
#   !/MGP !/MGG          Moving grid options.                               #
#                                                                           #
# No other optional switches should be used.                                #
#                                                                           #
# Grids generated in this test :                                            #
#                                                                           #
#  grd0   : 5km large grid (upon request only).                             #
#  grd1   : 50km outer grid.                                                #
#  grd2   : 15km middle grid.                                               #
#  grd3   : 5km inner grid.                                                 #
#                                                                           #
#  Remarks :                                                                #
# - Grads scripts generated by this test can be used to visualize results.  #
#   If the MPRF switch is used the grofiing data sets are copied to the     #
#   home directory for display with profile.gs.                             #
# - Script set up for parallel running :                                    #
#    a) For cluster with mpirun activate mpirun command lines and set       #
#       environment with valiables MPI and proc in section 0.               #
#    b) For IBM with poe, activale poe command lines and set environment    #
#       variables in poe jobcards at the top of the scripts.                #
#                                                                           #
#                                              Hendrik Tolman, Nov 2005     #
#                                                   Last Mod : Dec 2010     #
#                                                                           #
#    Copyright 2009 National Weather Service (NWS),                         #
#       National Oceanic and Atmospheric Administration.  All rights        #
#       reserved.  WAVEWATCH III is a trademark of the NWS.                 #
#       No unauthorized use without permission.                             #
#                                                                           #
#############################################################################

#@ shell=/bin/sh
#@ job_name=mww3_test_05
#@ output=mww3_test_05.out
#@ error=mww3_test_05.out
#@ notification=never
#@ class=dev
#@ network.MPI=csss,shared,us
#@ total_tasks=16
#@ node=1
#@ job_type=parallel
#@ wall_clock_limit=00:30:00
#@ resources=ConsumableCpus(1) ConsumableMemory(500 MB)
#@ account_no=WAV-T2O
#@ queue

# 0. Preparations -----------------------------------------------------------

  set -e

  ww3_env='.wwatch3.env'   # setup file

   input='input'
   grids='grd1 grd2 grd3'

    grd0='no '             # Run grd0 instead of others ...

    circ='yes'             # Use circular mask (otherwise square)

    Umax='45.'             # Maximum wind speed
    rmax='50.'             # Radius of maximum wind
   rmax2='1250.'           # Radius of no wind

   move_s='5.'             # Grid movement speed
   move_d='90.'            # Grid movement direction
   
#  mode=single             # Single or multi-scale model(s) key on multi
   mode=multi

  uni_pt='yes'             # Unified point output in grid '.points'

  grtype=shaded
# grtype=grfill

# t_end='19680606 000000' ; tn=' 1'
# t_end='19680606 010000' ; tn=' 2'
# t_end='19680606 030000' ; tn=' 4'
# t_end='19680606 060000' ; tn=' 7'
# t_end='19680606 120000' ; tn='13'
# t_end='19680606 180000' ; tn='19'
  t_end='19680607 000000' ; tn='25'
# t_end='19680607 120000' ; tn='37'
# t_end='19680608 000000' ; tn='49'
# t_end='19680610 000000' ; tn='97'

    MPI='yes'              # run ww3_shel and ww3_multi in MPI mode
   proc=20

  PRO2='  &PRO2 DTIME = 7200. /'
  PRO3='$ &PRO3 WDTHCG = 0., WDTHTH = 0. /'
  PRO3='$ &PRO3 WDTHCG = 2.5, WDTHTH = 2.5 /'
  MOVE='$ &MISC PMOVE = 1.0 /'

  spec_p='   1.10 0.04118 25 24 0.'
  spec_1='   1.10 0.04118 25 24 0.'
  spec_2='   1.10 0.04118 25 24 0.'
  spec_3='   1.10 0.04118 25 24 0.'

  fields='  T T T F F  T F F F F  T T F F T  T F T F F  F T F F F  F F F F F  F'

cat > buoy.1 << EOF
       0.E3   800.E3  'cN        '
    -550.E3   550.E3  'cNW       '
    -800.E3     0.E3  'cW        '
    -550.E3  -550.E3  'cSW       '
       0.E3  -800.E3  'cS        '
     550.E3  -550.E3  'cSE       '
     800.E3     0.E3  'cE        '
     550.E3   550.E3  'cNE       '
EOF

cat > buoy.2 << EOF
       0.E3   210.E3  'bN        '
    -150.E3   150.E3  'bNW       '
    -210.E3     0.E3  'bW        '
    -150.E3  -150.E3  'bSW       '
       0.E3  -210.E3  'bS        '
     150.E3  -150.E3  'bSE       '
     210.E3     0.E3  'bE        '
     150.E3   150.E3  'bNE       '
EOF

cat > buoy.3 << EOF
       0.E3     0.E3  'eye       '
       0.E3    50.E3  'mN        '
     -35.E3    35.E3  'mNW       '
     -50.E3     0.E3  'mW        '
     -35.E3   -35.E3  'mSW       '
       0.E3   -50.E3  'mS        '
      35.E3   -35.E3  'mSE       '
      50.E3     0.E3  'mE        '
      35.E3    35.E3  'mNE       '
       0.E3   100.E3  'aN        '
     -70.E3    70.E3  'aNW       '
    -100.E3     0.E3  'aW        '
     -70.E3   -70.E3  'aSW       '
       0.E3  -100.E3  'aS        '
      70.E3   -70.E3  'aSE       '
     100.E3     0.E3  'aE        '
      70.E3    70.E3  'aNE       '
EOF

  nr_b1=`wc -l buoy.1 | awk '{print $1}'`
  nr_b2=`wc -l buoy.2 | awk '{print $1}'`
  nr_b3=`wc -l buoy.3 | awk '{print $1}'`

  if [ "$uni_pt" = 'yes' ]
  then
    FLAGUP='T'
    COMMUP=' '
    points='points'
  else
    FLAGUP='F'
    COMMUP='$'
    points=
  fi
  
  if [ "$grd0" = 'yes' ]
  then
    grids='grd0'
    mode='single'
  fi

  if [ "$mode" = 'multi' ]
  then
    btype=2
    winds=$input
  else
    btype=3
    winds=$grids
  fi

# 0.a Set-up variables

  path_h=`pwd`

  cd
  if [ -f $ww3_env ]
  then
    set `grep WWATCH3_DIR $ww3_env` ; shift
    main_dir="$*"
    set `grep WWATCH3_TMP $ww3_env` ; shift
    temp_dir="$*"
  else
    echo "*** Set-up file $ww3_env not found ***"
    exit
  fi

  path_w="$temp_dir"              # work directory
  path_e="$main_dir/exe"          # path for executables
  path_a="$main_dir/aux"          # path for aux files and scripts
  path_o="$main_dir/test"         # path for output files
# path_o="$main_dir/work"

# 0.b Clean-up

  mv $path_h/buoy.? $path_w/.

  cd $path_w

  cat buoy.3 buoy.2 buoy.1 | sed -e 's/\.E3//g' -e "s/'//g" > $path_o/buoy.all

  echo ' ' ; echo ' '
  echo '                  ======> TEST RUN WAVEWATCH III <====== '
  echo '                    ==================================   '
  echo '                          test static nesting (hurricane)'
  echo ' '

# 1. Grid pre-processor -----------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '|  Grid preprocessor |'
  echo '+--------------------+'
  echo ' '

  rm -f mod_def.*

  if [ "$circ" = 'yes' ]
  then
    CIRC='T'
  else
    CIRC='F'
  fi

cat > grid.f << EOF 
      program grid
!   
      integer :: mask(523,523), nx, nxc, ny, nyc, mout
      real    :: dx, dy
      logical :: circ
!
      read (*,*) nx, nxc, ny, nyc, dx, dy, circ, r_max, mout
!
      do ix=1, nx
        do iy=1, ny
          rx     = dx * real(ix-nxc)
          ry     = dy * real(iy-nyc)
          radius = sqrt ( rx**2 + ry**2 )
          if ( .not . circ ) then
              mask(ix,iy) = 1
            else
              if ( radius .gt. r_max ) then
                  mask(ix,iy) = 3
                else
                  mask(ix,iy) = 1
                end if
            endif
          if ( ix.eq.1 .or. iy.eq.1 .or. ix.eq.nx .or. iy.eq.ny ) then
              if ( mask(ix,iy) .eq. 1 ) mask(ix,iy) = mout
            end if
          end do
        end do
!
      if ( circ .and. mout.eq.2 ) then
          do ix=2, nx-1
            do iy=2, ny-1
              if ( mask(ix,iy) .eq. 1 .and.
     &           ( mask(ix-1,iy  ).eq.3 .or. mask(ix+1,iy  ).eq.3 .or.
     &             mask(ix  ,iy-1).eq.3 .or. mask(ix  ,iy+1).eq.3 ) )
     &             mask(ix,iy) = 2
              end do
            end do
        end if
!
      open (21, file='grid.data')
      write (21,900) nx, ny, dx, dy, real(1-nxc)*dx, real(1-nyc)*dy, 
     &               nx*ny
      do iy=1,ny
        write (21,'(25i3)') (mask(ix,iy),ix=1,nx)
        end do
      write (21,902)
!
  900 format ( I6,5X,I6 /
     &         2(F9.2,'E3'),'   1.'/
     &         2(F9.2,'E3'),'   1.'/'$'/
     &   '  -0.1 0.25  10  -1000. 4 1 ''(....)'' ''UNIT'' ''input''' /
     &         '$'/I6,'*1'/'$'/
     &         '   10 1 1 ''(....)'' ''UNIT'' ''mapsta.inp'''/'$')
  901 format ('(40i1)')
  902 format ('$'/'   0.  0.  0.  0.  0 '/'$' )
!
      end
EOF

  f77 grid.f

  rm -f grid.f

  for grid in $grids $points $input
  do

    case $grid in 
    'input' ) echo "523 262 523 262  5.  5. F 0. 3" | ./a.out
              time='  200.  200.  200.  5.' 
              spec=$spec_1 ;;
     'inp2' ) echo "55 28 55 28 15. 15. F  0. 3" | ./a.out
              time='  600.  600.  600.  5.' 
              spec=$spec_1 ;;
    'points') echo '55 28 55 28 50. 50. F 0. 3' | ./a.out
              time=' 1800. 1800. 1800.  5.' 
              spec=$spec_p ;;
     'grd0' ) echo "523 262 523 262  5.  5. F 0. 3" | ./a.out
              time='  200.  200.  200.  5.' 
              spec=$spec_3 ;;
     'grd1' ) echo '55 28 55 28 50. 50. F 0. 3' | ./a.out
              time=' 1800. 1800. 1800.  5.' 
              spec=$spec_1 ;;
     'grd2' ) echo "51 26 51 26 15. 15. $CIRC 382.5 $btype" | ./a.out
              time='  600.  600.  600.  5.' 
              spec=$spec_2 ;;
     'grd3' ) echo "51 26 51 26  5.  5. $CIRC 127.5 $btype" | ./a.out
              time='  200.  200.  200.  5.' 
              spec=$spec_3 ;;
        *   ) echo 'Houston, we have a problem ....' ; exit 1 ;;
    esac

cat > ww3_grid.inp << EOF
$ WAVEWATCH III Grid preprocessor input file
$ ------------------------------------------
  'Hurricane grid $grid           '
$
$spec
$
   F T T T F T
$time
$
$PRO2
$PRO3
$MOVE
END OF NAMELISTS
$
 'RECT' F 'NONE'
EOF

    cat grid.data >> ww3_grid.inp
    rm -f grid.data

    echo "   Screen ouput routed to $path_o/ww3_grid.$grid.out"
    $path_e/ww3_grid > $path_o/ww3_grid.$grid.out

    rm -f ww3_grid.inp 
    mv mod_def.ww3 mod_def.$grid

  done

  rm -f a.out

# 2. Initial conditions -----------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '| Initial conditions |'
  echo '+--------------------+'
  echo ' '

cat > ww3_strt.inp << EOF
$ WAVEWATCH III Initial conditions input file
$ -------------------------------------------
  1
   0.10 0.0025  270. 10 -270.E3 30.E3 0.E3 999.E6  0.00
EOF

  for grid in $grids
  do
    rm -f mod_def.ww3
    ln -s mod_def.$grid mod_def.ww3
    echo "   Screen ouput routed to $path_o/ww3_strt.$grid.out"
    $path_e/ww3_strt > $path_o/ww3_strt.$grid.out
    mv restart.ww3 restart.$grid
  done

  rm -f ww3_strt.inp mod_def.ww3

# 3. Input fields -----------------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '| Input data         |'
  echo '+--------------------+'
  echo ' '

  echo '   Generating input wind fields ...'

cat > wind.f << EOF
      program winds
c
      integer :: nx, nxc, ny, nyc
      real    :: ux(523,523), uy(523,523), dx, dy, rmax, rmax2
c
      read (*,*) nx, nxc, ny, nyc, dx, dy, Umax, rmax, rmax2
c
      do ix=1, nx
        do iy=1, ny
          rx     = real(ix-nxc) * dx
          ry     = real(iy-nyc) * dy
          radius = sqrt ( rx**2 + ry**2 )
          if ( radius.lt.0.01*rmax .or. radius.gt.rmax2) then
              ux(ix,iy) = 0.
              uy(ix,iy) = 0.
            else
              if ( radius .le. rmax ) then
                  wind   = Umax * radius / rmax
                else
                  wind   = Umax * rmax / radius
                end if
              ux(ix,iy) = - ry * wind / radius
              uy(ix,iy) =   rx * wind / radius
            end if
          end do
        end do
c
      open (21, file='wind.data')
      write (21,'(i10.8,i7.6)') 19680606, 0
      do iy=1,ny
        write (21,'(12f8.3)') (ux(ix,iy),ix=1,nx)
        end do
      do iy=1,ny
        write (21,'(12f8.3)') (uy(ix,iy),ix=1,nx)
        end do
      close (21)
c
      end
EOF

  f77 wind.f

  rm -f wind.f

cat > ww3_prep.inp << EOF
$ WAVEWATCH III Field preprocessor input file
$ -------------------------------------------
   'WND' 'AI' T T
$
  'NAME' 1 1 '(..T..)' '(..F..)'
  20 'wind.data'
EOF

  for grid in $winds
  do

    case $grid in
    'input' ) echo "523 262 523 262  5.  5. $Umax $rmax $rmax2" | ./a.out ;;
     'inp2' ) echo "55 28 55 28 15. 15. $Umax $rmax $rmax2" | ./a.out ;;
     'grd0' ) echo "523 262 523 262  5.  5. $Umax $rmax $rmax2" | ./a.out ;;
     'grd1' ) echo "55 28 55 28 50. 50. $Umax $rmax $rmax2" | ./a.out ;;
     'grd2' ) echo "51 26 51 26 15. 15. $Umax $rmax $rmax2" | ./a.out ;;
     'grd3' ) echo "51 26 51 26  5.  5. $Umax $rmax $rmax2" | ./a.out ;;
        *   ) echo 'Houston, we have a problem ....' ; exit 1 ;;
    esac

    ln -s mod_def.$grid mod_def.ww3

    echo "   Screen ouput routed to $path_o/ww3_prep.$grid.out"
    $path_e/ww3_prep > $path_o/ww3_prep.$grid.out

    rm -f wind.data mod_def.ww3
    mv wind.ww3 wind.$grid

  done

  rm -f a.out ww3_prep.inp

# 4. Main program -----------------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '|    Main program    |'
  echo '+--------------------+'
  echo ' '

if [ "$mode" = 'multi' ]
then

cat > ww3_multi.inp << EOF
$ WAVEWATCH III multi-scale input file
$ ------------------------------------
  3 1 $FLAGUP 1 T T
$
  'input' F F T F F F F
$ 'inp2'  F F T F F F F
$
$COMMUP 'points'
$
  'grd1'  'no' 'no' 'input' 'no' 'no' 'no' 'no'   1  1  0.00 1.00  F
  'grd2'  'no' 'no' 'input' 'no' 'no' 'no' 'no'   2  1  0.00 1.00  F
  'grd3'  'no' 'no' 'input' 'no' 'no' 'no' 'no'   3  1  0.00 1.00  F
$ 'grd1'  'no' 'no' 'input' 'no' 'no' 'no' 'no'   1  1  0.00 0.50  F
$ 'grd2'  'no' 'no' 'input' 'no' 'no' 'no' 'no'   2  1  0.25 0.75  F
$ 'grd3'  'no' 'no' 'input' 'no' 'no' 'no' 'no'   3  1  0.50 1.00  F
$
   19680606 000000   $t_end
$
    T T
$
   19680606 000000   3600  $t_end
$fields
EOF

if [ "$uni_pt" = 'yes' ]
then

cat >> ww3_multi.inp << EOF
   19680606 000000   3600  19680608 000000
EOF

  cat buoy.3 >> ww3_multi.inp
  cat buoy.2 >> ww3_multi.inp
  cat buoy.1 >> ww3_multi.inp
  nr_p=`expr $nr_b3 + $nr_b2 + $nr_b1`

cat >> ww3_multi.inp << EOF
       0.E3     0.E3  'STOPSTRING'
EOF

else

cat >> ww3_multi.inp << EOF
   19680606 000000      0  19680608 000000
EOF

fi

cat >> ww3_multi.inp << EOF
$
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
$
EOF

if [ "$uni_pt" != 'yes' ]
then

cat >> ww3_multi.inp << EOF
  'grd1'  2
   19680606 000000   3600  $t_end
EOF
  cat buoy.3 >> ww3_multi.inp
  cat buoy.2 >> ww3_multi.inp
  cat buoy.1 >> ww3_multi.inp
  nr_1=`expr $nr_b3 + $nr_b2 + $nr_b1`
cat >> ww3_multi.inp << EOF
       0.E3     0.E3  'STOPSTRING'
$
  'grd2'  2
   19680606 000000   3600  $t_end
EOF
  cat buoy.3 >> ww3_multi.inp
  cat buoy.2 >> ww3_multi.inp
  nr_2=`expr $nr_b3 + $nr_b2`
cat >> ww3_multi.inp << EOF
       0.E3     0.E3  'STOPSTRING'
$
  'grd3'  2
   19680606 000000   3600  $t_end
EOF
  cat buoy.3 >> ww3_multi.inp
  nr_3=$nr_b3
cat >> ww3_multi.inp << EOF
       0.E3     0.E3  'STOPSTRING'
EOF

fi

cat >> ww3_multi.inp << EOF
$
  'the_end'  0
$
  'MOV' 19680606 000000   $move_s  $move_d
  'STP'
$
$ End of input file
EOF

  echo "   Running multi-scale model ..."
  echo "   Screen output routed to $path_o/ww3_multi.out"

  if [ "$MPI" = 'yes' ]
  then
    mpirun -np $proc $path_e/ww3_multi # > $path_o/ww3_multi.out
#   poe  $path_e/ww3_multi # > $path_o/ww3_multi.out
  else
    $path_e/ww3_multi # > $path_o/ww3_multi.out
  fi

  echo "   Log files routed to $path_o"
  mv log.* $path_o/.

  rm -f ww3_multi.inp
  rm -f restart.*
  rm -f wind.*

# rm -f test*.mww3
# rm -f test*.grd?

  set +e
  nr_test=`ls test* 2> /dev/null | wc -w | awk '{ print $1}'`
  if [ "$nr_test" != '0' ]
  then
    for file in `ls test* 2> /dev/null`
    do
      size=`wc -w $file | awk '{print $1}'`
      if [ "$size" = 0 ] ; then
        rm -f $file ; fi
    done
  fi

  nr_test=`ls test* 2> /dev/null | wc -w | awk '{ print $1}'`
  if [ "$nr_test" != '0' ]
  then
    echo "   Output file test[nnn].[m]ww3 routed to $path_o"
    mv test* $path_o/.
  fi

  nr_prof=`ls prf*.mww3 2> /dev/null | wc -w | awk '{ print $1}'`
  if [ "$nr_prof" != '0' ]
  then
    echo "   Profiling file prf.*.mww3 routed to $path_o"
    mv prf*.mww3 $path_o/. 2> /dev/null
  fi

  nr_part=`ls partition.* 2> /dev/null | wc -w | awk '{ print $1}'`
  if [ "$nr_part" != '0' ]
  then
    echo "   Partition file partition.* routed to $path_o"
    mv partition.* $path_o/. 2> /dev/null
  fi

  rm -f buoy.?

  set -e
  
else

  echo "   Running individual models ..."

  for mod in $grids
  do

cat > ww3_shel.inp << EOF
$ WAVEWATCH III shell input file
$ ------------------------------
   F F
   F F
   T F
   F
   F
   F
   F
$
   19680606 000000 
   $t_end
$
   1
$
   19680606 000000   3600  19680608 000000
$fields
   19680606 000000   3600  19680608 000000
EOF

  if [ "$mod" = 'grd0' ]
  then
    nr_0=`expr $nr_b3 + $nr_b2 + $nr_b1`
    cat buoy.3 >> ww3_shel.inp
    cat buoy.2 >> ww3_shel.inp
    cat buoy.1 >> ww3_shel.inp
  fi

  if [ "$mod" = 'grd1' ]
  then
    nr_1=`expr $nr_b3 + $nr_b2 + $nr_b1`
    cat buoy.3 >> ww3_shel.inp
    cat buoy.2 >> ww3_shel.inp
    cat buoy.1 >> ww3_shel.inp
 fi

  if [ "$mod" = 'grd2' ]
  then
    nr_2=`expr $nr_b3 + $nr_b2`
    cat buoy.3 >> ww3_shel.inp
    cat buoy.2 >> ww3_shel.inp
  fi

  if [ "$mod" = 'grd3' ]
  then
    nr_3=$nr_b3
    cat buoy.3 >> ww3_shel.inp
  fi

cat >> ww3_shel.inp << EOF
       0.E3     0.E3  'STOPSTRING'
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
   19680606 000000    720  19680608 000000
   19680606 000000      0  19680608 000000
$  
  'MOV' 19680606 000000   $move_s  $move_d
  'STP'
$  
$ End of input file
EOF

    echo ' '
    echo "   Running model $mod ..."

    rm -f mod_def.ww3 restart.ww3 wind.ww3
    ln -s mod_def.$mod mod_def.ww3
    ln -s restart.$mod restart.ww3
    ln -s wind.$mod wind.ww3
#   echo "   Screen ouput routed to $path_o/ww3_shel.$mod.out"

    if [ "$MPI" = 'yes' ]
    then
      mpirun -np $proc $path_e/ww3_shel # > $path_o/ww3_shel.$mod.out
#     poe $path_e/ww3_shel # > $path_o/ww3_shel.$mod.out
    else
      $path_e/ww3_shel # > $path_o/ww3_shel.$mod.out
    fi

    echo "   Log and output files renamed to xxx.$mod"
    mv log.ww3 $path_o/log.$mod
    mv out_grd.ww3 out_grd.$mod
    mv out_pnt.ww3 out_pnt.$mod
    if [ -f partition.ww3 ] ; then
      mv partition.ww3 partition.$mod ; fi
    rm -f mod_def.ww3 restart.ww3 ww3_shel.inp wind.ww3
    rm -f test*.ww3

  done

  nr_part=`ls partition.* 2> /dev/null | wc -w | awk '{ print $1}'`
  if [ "$nr_part" != '0' ]
  then
    echo "   Partition file partition.* routed to $path_o"
    mv partition.* $path_o/. 2> /dev/null
  fi

  rm -f buoy.? wind.* restart.*
fi

# exit 99

# 4. Gridded output ---------------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '|   Gridded output   |'
  echo '+--------------------+'
  echo ' '

cat > gx_outf.inp << EOF
$ WAVEWATCH III Grid output post-processing
$ -----------------------------------------
  19680606 000000  3600. $tn
$
$fields
$
  0 999 0 999  T T
$
$ End of input file
EOF

  for mod in $grids
  do
    echo "   GrADS data for $mod ..."
    echo "      Screen ouput routed to $path_o/gx_outf.$mod.out"
    ln -s mod_def.$mod mod_def.ww3
    ln -s out_grd.$mod out_grd.ww3

    $path_e/gx_outf > $path_o/gx_outf.$mod.out

    echo "      ww3.ctl routed to $path_o/$mod.ctl"
    
    case $mod in 
      'grd2' )  sed -e "s/ww3\.grads/ww3\.$mod/g" \
                    -e "s/37\.5/3\.75/g" \
                    -e "s/1\.50/0\.15/g" \
                                          ww3.ctl > $path_o/$mod.ctl ;;
      'grd3' )  sed -e "s/ww3\.grads/ww3\.$mod/g" \
                    -e "s/12\.5/1\.25/g" \
                    -e "s/0\.50/0\.05/g" \
                                          ww3.ctl > $path_o/$mod.ctl ;;
        *    )  sed -e "s/ww3\.grads/ww3\.$mod/g" ww3.ctl \
                                                  > $path_o/$mod.ctl ;;
    esac
    
#   sed -e "s/ww3\.grads/ww3\.$mod/g" \
#       -e "s/0\.25/2\.50/g" ww3.ctl > $path_o/$mod.ctl
    rm -f ww3.ctl
    echo "      ww3.grads routed to $path_o/ww3.$mod"
    mv ww3.grads $path_o/ww3.$mod

    rm -f mod_def.ww3 out_grd.ww3

  done

  rm -f gx_outf.inp out_grd.*

  echo ' '
  echo "   Plotting script put in $path_o/map.gs_tmpl"

cat > $path_o/map.gs_tmpl << EOF
*
* map.gs  : Imbedded GrADS script for test cases
* ----------------------------------------------------------------
*           Scripts used :
*              colorset.gs : Sets up shading colors
*
* General set up

  t1 =  1
  tn = $tn
  ts =  1

  plot_map = 'yes'
  plot_act = 'yes'
  plot_msk = 'yes'
  plot_hs  = 'yes' ; hs_type = -1
  plot_con = 'yes'
  plot_dir = 'yes'
  plot_wnd = 'yes'
  plot_bys = 'no '
  plot_lab = 'yes'
  pan = '(c)'

  if ( hs_type = -1 )
    hspar = 'hs'
    thpar = 'peakd'
  endif
  if ( hs_type = 0 )
    hspar = 'phs00'
    thpar = 'pth00'
  endif
  if ( hs_type = 1 )
    hspar = 'phs01'
    thpar = 'pth01'
  endif
  if ( hs_type = 2 )
    hspar = 'phs02' 
    thpar = 'pth02'
  endif
  if ( hs_type = 3 )
    hspar = 'phs03' 
    thpar = 'pth03'
  endif
  if ( hs_type = 4 )
    hspar = 'phs04' 
    thpar = 'pth04'
  endif
  if ( hs_type = 5 )
    hspar = 'phs05' 
    thpar = 'pth05'
  endif

  plot_1 = 'yes'
  plot_2 = 'yes'
  plot_3 = 'yes'

  xpl = 1.0
  xph = 7.5
  ypl = 2.5
  yph = 9.0

* xml = -250
* xmh =  250
* yml = -250
* ymh =  250

  xml = -500
  xmh =  500
  yml = -500
  ymh =  500

* xml = -750
* xmh =  750
* yml = -750
* ymh =  750

* xml = -1000
* xmh =  1000
* yml = -1000
* ymh =  1000

* xml = -1350
* xmh =  1350
* yml = -1350
* ymh =  1350

  vskip1 = 1
  vskip2 = 4
  vskip3 = 8
  
  wsc1 = 10.0
  wsc2 = 17.5
  wsc3 = 35.0

  clevs = '0.5 1. 2. 3. 4. 5. 6. 8. 10. 12. 14.'
* clevs = '1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11.'
  ccols = '21 23  24  26  27  29  30  32  33  35  36  38'
  
  if ( plot_act = 'yes' )
    col_act = 69
  else
    col_act = 70
  endif
  
  if ( plot_msk = 'yes' )
    col_msk = 71
  else
    col_msk = 70
  endif

  strsiz = ( xph - xpl ) * 0.03

  pdx = ( xph - xpl ) * 0.005
  strsiz2 = ( xph - xpl ) * 0.02

  'set display color white'
  'run colorset.gs'

  gdate="yyyy/mm/dd"
  '!date -u "+%Y/%m/%d" > tmp_grads_gdate'
  result = read (tmp_grads_gdate)
  gdate = sublin(result,2)
  '!rm -f tmp_grads_gdate'

* Set buoy data from buoy.data

  '!cat buoy.all | wc -l > tmp_grads_nbuoys'
  result = read (tmp_grads_nbuoys)
  line   = sublin(result,2)
  nr     = subwrd(line,1)
  '!rm -f tmp_grads_nbuoys'

  i = 1
  while ( i <= nr )
    result = read (buoy.all)
    line   = sublin(result,2)
    x.i = subwrd(line,1)
    y.i = subwrd(line,2)
    s.i = subwrd(line,3)
    i = i + 1
  endwhile

* ID output to screen

  say ' '
  say '----------------------'
  say '*** Running map.gs ***'
  say '----------------------'
  say ' ' 
  say 'Number of ouptput points : ' nr
  say 'Time steps from ' t1 ' through ' tn ' with step ' ts

* Loop over time steps

  'open grd1'
  'open grd2'
  'open grd3'

  i = 1
  t = t1

  '!rm -f plot.grads.*'

  while ( t <= tn )
    'set t ' t

    'query time'
    gradsdate = subwrd(result,3)
    test = substr ( gradsdate, 3, 1 )
    if ( test='Z' )
      year = substr ( gradsdate, 9, 4 )
      mnth = substr ( gradsdate, 6, 3 )
      day  = substr ( gradsdate, 4, 2 )
      hour = substr ( gradsdate, 1, 2 )
      min  = '00'
    else
      year = substr ( gradsdate, 12, 4 )
        mnth = substr ( gradsdate, 9, 3 )
      day  = substr ( gradsdate, 7, 2 )
      hour = substr ( gradsdate, 1, 2 )
      min  = substr ( gradsdate, 4, 2 )
    endif

    month= '??'
    if (mnth='JAN'); month= '01'; endif;
    if (mnth='FEB'); month= '02'; endif;
    if (mnth='MAR'); month= '03'; endif;
    if (mnth='APR'); month= '04'; endif;
    if (mnth='MAY'); month= '05'; endif;
    if (mnth='JUN'); month= '06'; endif;
    if (mnth='JUL'); month= '07'; endif;
    if (mnth='AUG'); month= '08'; endif;
    if (mnth='SEP'); month= '09'; endif;
    if (mnth='OCT'); month= '10'; endif;
    if (mnth='NOV'); month= '11'; endif;
    if (mnth='DEC'); month= '12'; endif;

*   vdate = year '/' month '/' day ' ' hour ':' min 'z'
*   vdate = pan ' ' hour ':' min 'z'
    vdate = hour ':' min 'z'

    say '   processing time step ' t ', time is ' vdate

* Basic plot set up

    'enable print plot.grads.' t
    'clear'
    'set grads off'
    'set lon ' xml / 100 ' ' xmh / 100
    'set lat ' yml / 100 ' ' ymh / 100
    'set xlint 2.'
    'set ylint 2.'
*   'set xlint 3.'
*   'set ylint 3.'
    'set xlab %.0f00'
    'set ylab %.0f00'
    'set grid on 3 60'
    'set mpdraw off'

    'set parea ' xpl ' ' xph ' ' ypl ' ' yph
    'set mproj scaled'

    'set line 70'
    'draw recf 1. 2.5 7.5 9.'
    'draw recf ' xpl ' ' ypl ' ' xph ' ' yph

* Plot outer grid -------------------------------------------------------- *

    if ( plot_1 = 'yes' )

* Plot map

      if ( plot_map = 'yes' )
        'set gxout grfill'
        'set clevs -4.5 -3.5 -2.5 -1.5 -0.5  0.5 1.5'
        'set ccols 60  ' col_msk '  67   68   63   62   0  ' col_act
        'd map.1'
      endif

* Plot Hs

      if ( plot_hs = 'yes' )
        'set gxout $grtype'
        'set clevs ' clevs
        'set ccols ' ccols
        'd ' hspar '.1'
  
        if ( plot_con = 'yes' )
          'set gxout contour'
          'set cthick 1'
          'set ccolor 60'
          'set clevs ' clevs
          'set clab off'
          'd ' hspar '.1'
        endif

      endif

* Plot directions

      if ( plot_dir = 'yes' )
        'set gxout vector'
        'set cthick 3'
        'set arrscl 0.25'
        'set arrlab off'
        'set ccolor 1'
        'd skip(cos(' thpar '.1),' vskip1 ');skip(sin(' thpar '.1),' vskip1 ')'
      endif

* Plot wind

      if ( plot_wnd = 'yes' )
        'set gxout vector'
        'set cthick 3'
        'set arrscl 0.25 ' wsc1
        'set arrlab off'
        'set ccolor 2'
        'd skip(wu.1,' vskip1 ');skip(wv.1,' vskip1 ')'
      endif

    endif

* Plot middle grid ------------------------------------------------------- *

    if ( plot_2 = 'yes' )

* Plot map

      if ( plot_map = 'yes' )
        'set gxout grfill'
        'set clevs -4.5 -3.5 -2.5 -1.5 -0.5  0.5 1.5'
        'set ccols 60  ' col_msk '  67   68   63   62   0  ' col_act
        'd map.2'
      endif

* Plot Hs

      if ( plot_hs = 'yes' )
        'set gxout $grtype'
        'set clevs ' clevs
        'set ccols ' ccols
        'd ' hspar '.2'
  
        if ( plot_con = 'yes' )
          'set gxout contour'
          'set cthick 1'
          'set ccolor 60'
          'set clevs ' clevs
          'set clab off'
          'd ' hspar '.2'
        endif

      endif

* Plot directions

      if ( plot_dir = 'yes' )
        'set gxout vector'
        'set cthick 3'
        'set arrscl 0.25'
        'set arrlab off'
        'set ccolor 1'
        'd skip(cos(' thpar '.2),' vskip2 ');skip(sin(' thpar '.2),' vskip2 ')'
      endif

* Plot wind

      if ( plot_wnd = 'yes' )
        'set gxout vector'
        'set cthick 3'
        'set arrscl 0.25 ' wsc2
        'set arrlab off'
        'set ccolor 2'
        'd skip(wu.2,' vskip2 ');skip(wv.2,' vskip2 ')'
      endif

    endif

* Plot inner grid -------------------------------------------------------- *

    if ( plot_3 = 'yes' )

* Plot map

      if ( plot_map = 'yes' )
        'set gxout grfill'
        'set clevs -4.5 -3.5 -2.5 -1.5 -0.5  0.5 1.5'
        'set ccols 60  ' col_msk '  67   68   63   62   0  ' col_act
        'd map.3'
      endif

* Plot Hs

      if ( plot_hs = 'yes' )
        'set gxout $grtype'
        'set clevs ' clevs
        'set ccols ' ccols
        'd ' hspar '.3'
  
        if ( plot_con = 'yes' )
          'set gxout contour'
          'set cthick 1'
          'set ccolor 60'
          'set clevs ' clevs
          'set clab off'
          'd ' hspar '.3'
        endif

      endif

* Plot directions

      if ( plot_dir = 'yes' )
        'set gxout vector'
        'set cthick 3'
        'set arrscl 0.125'
        'set arrlab off'
        'set ccolor 1'
        'd skip(cos(' thpar '.3),' vskip3 ');skip(sin(' thpar '.3),' vskip3 ')'
      endif
      
* Plot wind

      if ( plot_wnd = 'yes' )
        'set gxout vector'
        'set cthick 3'
        'set arrscl 0.25 ' wsc3
        'set arrlab off'
        'set ccolor 2'
        'd skip(wu.3,' vskip3 ');skip(wv.3,' vskip3 ')'
      endif

    endif

* Plot output locations -------------------------------------------------- *

    'set strsiz ' strsiz2

    if ( plot_bys = 'yes' )
      j = 1
      'set line 1'
      'set string 1 l'

      while ( j <= nr )
        if ( x.j < xmh ) & (x.j > xml ) & ( y.j < ymh ) & ( y.j > yml )
          xb = xpl + ( xph - xpl ) * ( x.j - xml ) / ( xmh - xml )
          yb = ypl + ( yph - ypl ) * ( y.j - yml ) / ( ymh - yml )
          'draw recf ' xb-pdx ' ' yb-pdx ' ' xb+pdx ' ' yb+pdx
*         'draw string ' xb + 0.05*strsiz2 ' ' yb + 0.8*strsiz2 ' ' s.j
        endif
        j = j + 1
      endwhile
    endif
 
* Panel and date marker

    if ( plot_lab = 'yes' )
      'set string 0 c'
      'set strsiz ' strsiz
*     'draw string 1.7 8.30 ' pan
      'draw string 2.3 8.55 ' vdate
    endif
 
* Finalize

    'print'
    'disable print'
    pull OK
    t = t + ts
    i = i + 1
  endwhile

* End of loop over time steps

  say ' '
  say '----------------------'
  say '*** End of map.gs  ***'
  say '----------------------'
  say ' ' 

  'quit'

* end of map.gs
EOF

# 5. Point output -----------------------------------------------------------
    
  echo ' '
  echo '+--------------------+'
  echo '|    Point output    |'
  echo '+--------------------+'
  echo ' '
  
cat > gx_outp.inp_tmpl << EOF
$ WAVEWATCH III Grid output post-processing
$ -----------------------------------------
  19680606 000000  3600. $tn
$ 
POINTS
 -1
$
  T F F F F F
$ 
$ End of input file
EOF

  out_mods=`ls out_pnt.* | sed 's/out\_pnt\.//g'`

  for mod in $out_mods
  do
    echo "   GrADS point output for $mod ..."
    case $mod in
     'points') nr=$nr_p ;;
      'grd0' ) nr=$nr_0 ;;
      'grd1' ) nr=$nr_1 ;;
      'grd2' ) nr=$nr_2 ;;
      'grd3' ) nr=$nr_3 ;;
         *   ) nr=0     ;;
    esac
    
    i=1
    string=
    
    while [ "$i" -le "$nr" ]
    do
      if [ -z "$string" ]
      then
        string=$i
      else
        string="$string \n $i"
      fi
      i=`expr $i + 1`
    done

    sed "s/POINTS/$string/g" gx_outp.inp_tmpl > gx_outp.inp

    echo "      Screen ouput routed to $path_o/gx_outp.$mod.out"
    ln -s mod_def.$mod mod_def.ww3
    ln -s out_pnt.$mod out_pnt.ww3

    $path_e/gx_outp > $path_o/gx_outp.$mod.out

    if [ "$mod" = 'points' ]
    then
      echo "      ww3.spec.ctl routed to $path_o"
      mv ww3.spec.ctl $path_o/.
      echo "      ww3.spec.grads routed to $path_o"
      mv ww3.spec.grads $path_o/.
      echo "      ww3.mean.grads routed to $path_o"
      mv ww3.mean.grads $path_o/.
    else
      echo "      ww3.spec.ctl routed to $path_o/$mod.spec.ctl"
      sed -e "s/ww3\.spec\.grads/ww3\.spec\.$mod/g" \
                                       ww3.spec.ctl > $path_o/$mod.spec.ctl
      rm -f ww3.spec.ctl
      echo "      ww3.spec.grads routed to $path_o/ww3.spec.$mod"
      mv ww3.spec.grads $path_o/ww3.spec.$mod
      echo "      ww3.mean.grads routed to $path_o/ww3.mean.$mod"
      mv ww3.mean.grads $path_o/ww3.mean.$mod
    fi

    rm -f mod_def.ww3 out_pnt.ww3 gx_outp.inp
  done

# echo ' '
# echo "   Plotting script put in $path_o/spec05.gs_tmpl"

  rm -f gx_outp.inp_tmpl out_pnt.*

# 6. End, cleaning up -------------------------------------------------------

  echo ' ' ; echo "Cleaning-up `pwd`"
  rm -f mod_def.* log.*

  echo ' ' ; echo ' '
  echo '                  ======>  END OF WAVEWATCH III  <====== '
  echo '                    ==================================   '
  echo ' '

# End of mww3_test_05 -------------------------------------------------------
