#!/bin/sh
#############################################################################
#                                                                           #
# mww3_test_03 : Overlapping grid test (propagation only)                   #
#                Six grids with two ranks.                                  #
#                                                                           #
# Model should be compiled with the switches :                              #
#                                                                           #
#   !/FLXn !/LN0 !/ST0 !/NL0 !/BT0 !/DB0 !/TR0 !/BS0 !/XX0                  #
#                        No source terms needed.                            #
#   !/PRn                Selecting one of the propagation schemes.          #
#   !/O0 !/O1 !/O2 !/O3 !/O4 !/O5 !/O6 !/O7 !/O10 !/O11                     #
#                        Sdt out output options.                            #
#                                                                           #
# Grids generated in this test :                                            #
#                                                                           #
#  low1-3 : Three low-resolution grids with constant depth.                 #
#  hgh1-3 : Three high resolution grids with shallow water / shore          #
#           (optional)                                                      #
#                                                                           #
# No other optional switches should be used.                                #
#                                                                           #
# Remarks :                                                                 #
# - Grads scripts generated by this test can be used to visualize results.  #
#   If the MPRF switch is used the grofiing data sets are copied to the     #
#   home directory for display with profile.gs.                             #
# - Script set up for parallel running :                                    #
#    a) For cluster with mpirun activate mpirun command lines and set       #
#       environment with valiables MPI and proc in section 0.               #
#    b) For IBM with poe, activale poe command lines and set environment    #
#       variables in poe jobcards at the top of the scripts.                #
#                                                                           #
#                                              Hendrik Tolman, Feb 2006     #
#                                                   Last Mod : Dec 2010     #
#                                                                           #
#    Copyright 2009 National Weather Service (NWS),                         #
#       National Oceanic and Atmospheric Administration.  All rights        #
#       reserved.  WAVEWATCH III is a trademark of the NWS.                 #
#       No unauthorized use without permission.                             #
#                                                                           #
#############################################################################

#@ shell=/bin/sh
#@ job_name=mww3_test_03
#@ output=mww3_test_03.out
#@ error=mww3_test_03.out
#@ notification=never
#@ class=dev
#@ network.MPI=csss,shared,us
#@ total_tasks=6
#@ node=1
#@ job_type=parallel
#@ wall_clock_limit=00:01:00
#@ resources=ConsumableCpus(1) ConsumableMemory(500 MB)
#@ account_no=WAV-T2O
#@ queue

# 0. Preparations -----------------------------------------------------------

  set -e

  ww3_env='.wwatch3.env'   # setup file

   lowm='no'               # master low-res map instead of three

   high='yes'              # Add high resolution grids
   hghm='no'               # master high-res map instead of three

   cbnd='no'               # cross-shore boundary points included
   smap='no'               # Add sea points to GrADS map.
   bmap='yes'              # Add boundary points to GrADS map.

   xl0='  0.0'
   xh0='500.0'
   yl0='  0.0'
   yh0='500.0'
   dx0=' 10.0'
  low0=" $xl0 $xh0 $yl0 $yh0 $dx0 600. 'Low resolution grid 0 '"
 slow0="   1.03 0.075 20 24 0."

   xl1='  0.0'
   xh1='500.0'
   yl1='  0.0'
   yh1='270.0'
   dx1=' 10.0'
  low1=" $xl1 $xh1 $yl1 $yh1 $dx1 600. 'Low resolution grid 1 '"
 slow1="   1.03 0.075 20 24 0."

   xl2='  0.0'
   xh2='290.0'
   yl2='210.0'
   yh2='500.0'
   dx2=' 10.0'
  low2=" $xl2 $xh2 $yl2 $yh2 $dx2 600. 'Low resolution grid 2 '"
 slow2="   1.03 0.075 20 24 0."

   xl3='240.0'
   xh3='500.0'
   yl3='190.0'
   yh3='500.0'
   dx3=' 10.0'
  low3=" $xl3 $xh3 $yl3 $yh3 $dx3 600. 'Low resolution grid 3 '"
 slow3="   1.03 0.075 20 24 0."

   xl4='  0.0'
   xh4='500.0'
   yl4='210.0'
   yh4='500.0'
   dx4='  5.0'
  hgh0=" $xl4 $xh4 $yl4 $yh4 $dx4 300. -0.5 45. 'High resolution grid 0 '"
 shgh0="   1.03 0.075 20 24 0."

   xl5='  0.0'
   xh5='190.0'
   yl5='215.0'
   yh5='500.0'
   dx5='  5.0'
  hgh1=" $xl5 $xh5 $yl5 $yh5 $dx5 300. 21. 45. 'High resolution grid 1 '"
 shgh1="   1.03 0.075 20 24 0."

   xl6=' 35.0'
   xh6='380.0'
   yl6='290.0'
   yh6='500.0'
   dx6='  5.0'
  hgh2=" $xl6 $xh6 $yl6 $yh6 $dx6 300. 8. 25. 'High resolution grid 2 '"
 shgh2="   1.03 0.075 20 24 0."

   xl7='285.0'
   xh7='500.0'
   yl7='355.0'
   yh7='500.0'
   dx7='  5.0'
  hgh3=" $xl7 $xh7 $yl7 $yh7 $dx7 300. -5. 12. 'High resolution grid 3 '"
 shgh3="   1.03 0.075 20 24 0."

  grtype=shaded
# grtype=grfill

# t_end='19680606 001000' ; tn='1' 
# t_end='19680606 010000' ; tn='2'
# t_end='19680606 030000' ; tn='4'
  t_end='19680606 060000' ; tn='7'
# t_end='19680606 120000' ; tn='13'

    MPI='yes'              # run ww3_multi in MPI mode
   proc=6

  PROP2="$ \&PRO2 DTIME = 21600. \/"
  PROP3="$ \&PRO3 WDTHCG = 0., WDTHTH = 0. \/"

# 0.a Set-up variables

  cd
  if [ -f $ww3_env ]
  then
    set `grep WWATCH3_DIR $ww3_env` ; shift
    main_dir="$*"
    set `grep WWATCH3_TMP $ww3_env` ; shift
    temp_dir="$*"
  else
    echo "*** Set-up file $ww3_env not found ***"
    exit
  fi

  path_w="$temp_dir"              # work directory
  path_e="$main_dir/exe"          # path for executables
  path_a="$main_dir/aux"          # path for aux files and scripts
  path_o="$main_dir/test"         # path for output files
# path_o="$main_dir/work"

  if [ "$lowm" = 'yes' ]
  then
    mods='low0'
    grdx1='low0'
    grdx2='low0'
    grdx3='low0'
    xl1="$xl0" ; xh1="$xh0" ; yl1="$yl0" ; yh1="$yh0"
    xl2="$xl0" ; xh2="$xh0" ; yl2="$yl0" ; yh2="$yh0"
    xl3="$xl0" ; xh3="$xh0" ; yl3="$yl0" ; yh3="$yh0"
  else
    mods='low1 low2 low3'
    grdx1='low1'
    grdx2='low2'
    grdx3='low3'
  fi

  if [ "$high" = 'yes' ]
  then
    if [ "$hghm" = 'yes' ]
    then
      mods="$mods hgh0"
      grdx4='hgh0'
      grdx5='hgh0'
      grdx6='hgh0'
      xl5="$xl4" ; xh5="$xh4" ; yl5="$yl4" ; yh5="$yh4"
      xl6="$xl4" ; xh6="$xh4" ; yl6="$yl4" ; yh5="$yh4"
      xl7="$xl4" ; xh7="$xh4" ; yl7="$yl4" ; yh7="$yh4"
    else
      mods="$mods hgh1 hgh2 hgh3"
      grdx4='hgh1'
      grdx5='hgh2'
      grdx6='hgh3'
    fi
  else
    grdx4=$grdx1
    grdx5=$grdx2
    grdx6=$grdx3
    xl5="$xl0" ; xh5="$xh0" ; yl5="$yl0" ; yh5="$yh0"
    xl6="$xl0" ; xh6="$xh0" ; yl6="$yl0" ; yh6="$yh0"
    xl7="$xl0" ; xh7="$xh0" ; yl7="$yl0" ; yh7="$yh0"
  fi

  NR=`echo $mods | wc -w | awk '{ print $1}'`

  if [ "$cbnd" = 'yes' ]
  then
    LBN='!'
    LBY=' '
  else
    LBN=' '
    LBY='!'
  fi

  if [ "$bmap" = 'yes' ]
  then
    BOU='T'
  else
    BOU='F'
  fi

  if [ "$smap" = 'yes' ]
  then
    SEA='T'
  else
    SEA='F'
  fi

# 0.b Clean-up

  cd $path_w

  echo ' ' ; echo ' '
  echo '                  ======> TEST RUN WAVEWATCH III <====== '
  echo '                    ==================================   '
  echo '                        test overlapping grids (propagation)'
  echo ' '

# 1. Grid pre-processor -----------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '|  Grid preprocessor |'
  echo '+--------------------+'
  echo ' '

  rm -f mod_def.*

  echo '   Making grid programs ...'
  echo ' '

cat > grid1.f << EOF 
      program grid1
!   
      real              :: xmin, xmax, ymin, ymax, dxy, dt
      character(len=22) :: ID
!
      read (*,*) xmin, xmax, ymin, ymax, dxy, dt, ID
      nx     = nint((xmax-xmin)/dxy) + 3
      ny     = nint((ymax-ymin)/dxy) + 3
      xmin   = xmin - dxy
      ymin   = ymin - dxy
!
      write (*,900) ID, dt, dt, dt, 5.
      write (*,901) nx, ny, dxy, dxy, xmin, ymin, nx*ny
!
  900 format ( '$ WAVEWATCH III Grid preprocessor input file'/
     &         '$ ------------------------------------------'/
     &         '   ''',A,''''/'$'/'SPEC'/
     &         '$'/'   F T T T F F '/'$'/2X,4F8.1/'$'/
     &         'PROP2'/'PROP3'/'PROP4'/'END OF NAMELISTS'/'$'/
     &         '    ''RECT'' F ''NONE''')
  901 format ( I6,5X,I6 /
     &         2(F9.2,'E3'),'   1.'/
     &         2(F9.2,'E3'),'   1.'/'$'/
     &   '  -0.1  10.0  10  -250. 4 1 ''(....)'' ''UNIT'' ''input''' /
     &         '$'/I6,'*1'/'$'/
     &         '   10 1 1 ''(....)'' ''PART'' ''mapsta.inp'''/'$'/
     &         '   0   0   F'/'   0   0   F'/'   0   0'/'$'/
     &         '   0.  0.  0.  0.  0 '/'$')
!
      end
EOF

cat > grid2.f << EOF 
      program grid2
!   
      real              :: xmin, xmax, ymin, ymax, dxy, dt, ang0, angn
      real              :: xo = 500., yo = -500.
      real              :: r0 = 1000., rd = 900., rc = 875., dmax = 250.
      real              :: depth(1000,1000)
      integer           :: mask(1000,1000)
      character(len=22) :: ID
!
      read (*,*) xmin, xmax, ymin, ymax, dxy, dt, ang0, angn, ID
      nx     = nint((xmax-xmin)/dxy) + 3
      ny     = nint((ymax-ymin)/dxy) + 3
      xmin   = xmin - dxy
      ymin   = ymin - dxy
!
      if ( nx.gt.1000 .or. ny.gt.1000 ) then
          write (*,*) ' ARRAY DIMENSIONS TOO SMALL ...'
          stop
        end if
!
      do ix=1, nx
        x      = xmin + real(ix-1)*dxy
        do iy=1, ny
          mask(ix,iy) = 1
          y      = ymin + real(iy-1)*dxy
          R      = sqrt ( (x-xo)**2 + (y-yo)**2 ) 
          depth(ix,iy) = max(0.,min(dmax,(R-r0)/(rd-r0)*dmax),0.)
          ang = asin((xo-x)/r) / 3.14159 * 180.
          if ( depth(ix,iy) .lt. 1. ) mask(ix,iy) = 0
          if ( R .lt. rc ) mask(ix,iy) = 3
!         if ( mask(ix,iy).eq.1 .and.
!    &         ( ang.lt.ang0 .or. ang.gt.angn ) ) mask(ix,iy) = 3
          if ( ang.lt.ang0 .or. ang.gt.angn ) mask(ix,iy) = 3
          end do
        end do
!
      do ix=2, nx-1
        x      = xmin + real(ix-1)*dxy
        do iy=2, ny-2
          y      = ymin + real(iy-1)*dxy
          R      = sqrt ( (x-xo)**2 + (y-yo)**2 ) 
$LBN         if ( mask(ix,iy).eq.1 .and. R.lt.rc+dxy ) then
$LBY         if ( mask(ix,iy) .eq. 1 ) then
              if ( mask(ix-1,iy  ) .eq. 3  .or.
     &             mask(ix+1,iy  ) .eq. 3  .or.
     &             mask(ix  ,iy-1) .eq. 3  .or.
     &             mask(ix  ,iy+1) .eq. 3 ) mask(ix,iy) = 2 
            end if
          end do
        end do
!
      do iy=1, ny
        if ( mask( 1,iy). ge. 1 ) mask( 1,iy) = 3
        if ( mask(nx,iy). ge. 1 ) mask(nx,iy) = 3
        end do
!
      do ix=1, nx
        if ( mask(ix, 1). ge. 1 ) mask(ix, 1) = 3
        if ( mask(ix,ny). ge. 1 ) mask(ix,ny) = 3
        end do
!
      write (*,900) ID, dt, dt, dt, 5.
      write (*,901) nx, ny, dxy, dxy, xmin, ymin
      do iy=ny,1,-1
        write (*,902) (depth(ix,iy),ix=1,nx)
        end do
      write (*,903)
      do iy=ny,1,-1
        write (*,904) (mask(ix,iy),ix=1,nx)
        end do
      write (*,905)
!
  900 format ( '$ WAVEWATCH III Grid preprocessor input file'/
     &         '$ ------------------------------------------'/
     &         '   ''',A,''''/'$'/'SPEC'/
     &         '$'/'   F T T T F F '/'$'/2X,4F8.1/'$'/
     &         'PROP2'/'PROP3'/'PROP4'/'END OF NAMELISTS'/'$'/
     &         '    ''RECT'' F ''NONE''')
  901 format ( I6,5X,I6 /
     &         2(F9.2,'E3'),'   1.'/
     &         2(F9.2,'E3'),'   1.'/'$'/
     &   '  -0.1  10.0  10  -1. 3 1 ''(....)'' ''UNIT'' ''input'''/'$')
  902 format ( 10f8.2 )
  903 format ( '$'/'   10 3 1 ''(....)'' ''UNIT'' ''input'''/'$')
  904 format ( 64i2 )
  905 format ( '$'/'   0.  0.  0.  0.  0 '/'$')
!
      end
EOF

  f77 grid1.f -o grid1.x 2> /dev/null
  f77 grid2.f -o grid2.x 2> /dev/null

  rm -f grid1.f grid2.f

  for grid in $mods
  do

    case $grid in 
     'low0' ) echo "$low0" | ./grid1.x > ww3_grid.tmp ; spec=$slow0 ;;
     'low1' ) echo "$low1" | ./grid1.x > ww3_grid.tmp ; spec=$slow1 ;;
     'low2' ) echo "$low2" | ./grid1.x > ww3_grid.tmp ; spec=$slow2 ;;
     'low3' ) echo "$low3" | ./grid1.x > ww3_grid.tmp ; spec=$slow3 ;;
     'hgh0' ) echo "$hgh0" | ./grid2.x > ww3_grid.tmp ; spec=$shgh0 ;;
     'hgh1' ) echo "$hgh1" | ./grid2.x > ww3_grid.tmp ; spec=$shgh1 ;;
     'hgh2' ) echo "$hgh2" | ./grid2.x > ww3_grid.tmp ; spec=$shgh2 ;;
     'hgh3' ) echo "$hgh3" | ./grid2.x > ww3_grid.tmp ; spec=$shgh3 ;;
        *   ) echo 'Houston, we have a problem ....' ; exit 1 ;;
    esac

    sed -e "s/SPEC/$spec/g"   \
        -e "s/PROP2/$PROP2/g" \
        -e "s/PROP3/$PROP3/g" \
        -e "s/PROP4/$PROP4/g"    ww3_grid.tmp > ww3_grid.inp

    rm -f ww3_grid.tmp

    echo "   Screen ouput routed to $path_o/ww3_grid.$grid.out"
    $path_e/ww3_grid > $path_o/ww3_grid.$grid.out

    rm -f ww3_grid.inp 
    mv mod_def.ww3 mod_def.$grid

  done

  rm -f grid?.x

# 2. Initial conditions -----------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '| Initial conditions |'
  echo '+--------------------+' 
  echo ' '
  
cat > ww3_strt.inp << EOF
$ WAVEWATCH III Initial conditions input file
$ -------------------------------------------
  1
   0.10 0.0001  150. 100 350.E3 40.E3 150.E3 40.E3  10.0
EOF
    
  for grid in $mods
  do
    rm -f mod_def.ww3
    ln -s mod_def.$grid mod_def.ww3
    echo "   Screen ouput routed to $path_o/ww3_strt.$grid.out"
    $path_e/ww3_strt > $path_o/ww3_strt.$grid.out
    mv restart.ww3 restart.$grid
  done

  rm -f ww3_strt.inp mod_def.ww3

# 3. Input fields -----------------------------------------------------------

  echo ' ' 
  echo '+--------------------+'
  echo '| Input data         |'
  echo '+--------------------+'
  echo ' '
  echo '   Not needed for present test.'
  
# 4. Main program -----------------------------------------------------------
  
  echo ' '
  echo '+--------------------+'
  echo '|    Main program    |'
  echo '+--------------------+'
  echo ' '

cat > ww3_multi.inp << EOF
$ WAVEWATCH III multi-scale input file
$ ------------------------------------
  $NR 0 F 1 F F
EOF

  inp='ww3_multi.inp'
  flags="'no' 'no' 'no' 'no' 'no' 'no' 'no'"
  
  for mod in $mods
  do
    case $mod in
     'low0') echo " 'low0'  $flags  1  1  0.00 1.00  F" >> $inp ;;
     'low1') echo " 'low1'  $flags  1  1  0.00 0.33  F" >> $inp ;;
     'low2') echo " 'low2'  $flags  1  1  0.33 0.67  F" >> $inp ;;
     'low3') echo " 'low3'  $flags  1  1  0.67 1.00  F" >> $inp ;;
#    'low1') echo " 'low1'  $flags  1  1  0.00 1.00  F" >> $inp ;;
#    'low2') echo " 'low2'  $flags  1  1  0.00 1.00  F" >> $inp ;;
#    'low3') echo " 'low3'  $flags  1  1  0.00 1.00  F" >> $inp ;;
     'hgh0') echo " 'hgh0'  $flags  2  1  0.00 1.00  F" >> $inp ;;
     'hgh1') echo " 'hgh1'  $flags  2  1  0.00 0.33  F" >> $inp ;;
     'hgh2') echo " 'hgh2'  $flags  2  1  0.33 0.67  F" >> $inp ;;
     'hgh3') echo " 'hgh3'  $flags  2  1  0.67 1.00  F" >> $inp ;;
#    'hgh1') echo " 'hgh1'  $flags  2  1  0.00 1.00  F" >> $inp ;;
#    'hgh2') echo " 'hgh2'  $flags  2  1  0.00 1.00  F" >> $inp ;;
#    'hgh3') echo " 'hgh3'  $flags  2  1  0.00 1.00  F" >> $inp ;;
    esac
  done

cat >> ww3_multi.inp << EOF
$
   19680606 000000   $t_end
$
  T T
$
$  19680606 000000   3600  19680608 000000
   19680606 000000    600  19680608 000000
     T T T T T  T T T T T  T T T T T  T T T T T  T T T T T  T T T T T  T
   19680606 000000    600  19680608 000000
     200.E3 400.E3  'point_A   '
       0.E3   0.E3  'STOPSTRING'
   19680606 000000      0  19680608 000000
   19680606 001000      1  19680606 001000
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
$
  'the_end'  0
$
  'STP'
$
$ End of input file
EOF

  echo "   Running multi-scale model ..."
# echo "   Screen output routed to $path_o/ww3_multi.out"

  if [ "$MPI" = 'yes' ]
  then
    mpirun -np $proc $path_e/ww3_multi # > $path_o/ww3_multi.out
#   poe $path_e/ww3_multi # > $path_o/ww3_multi.out
  else
    $path_e/ww3_multi # > $path_o/ww3_multi.out
  fi

  echo "   Log files routed to $path_o"
  mv log.* $path_o/.

# rm -f ww3_multi.in
  rm -f restart.*

# rm -f test*.low?    
# rm -f test*.hgh?   

  set +e
  nr_test=`ls test* 2> /dev/null | wc -w | awk '{ print $1}'`
  if [ "$nr_test" != '0' ]
  then
    for file in `ls test* 2> /dev/null`
    do
      size=`wc -w $file | awk '{print $1}'`
      if [ "$size" = 0 ] ; then
        rm -f $file ; fi
    done
  fi

  nr_test=`ls test* 2> /dev/null | wc -w | awk '{ print $1}'`
  if [ "$nr_test" != '0' ]
  then
    echo "   Output file test[nnn].[m]ww3 routed to $path_o"
    mv test* $path_o/.
  fi

  nr_prof=`ls prf*.mww3 2> /dev/null | wc -w | awk '{ print $1}'`
  if [ "$nr_prof" != '0' ]
  then
    echo "   Profiling file prf.*.mww3 routed to $path_o"
    mv prf*.mww3 $path_o/. 2> /dev/null
  fi

  nr_part=`ls partition.* 2> /dev/null | wc -w | awk '{ print $1}'`
  if [ "$nr_part" != '0' ]
  then
    echo "   Partition file partition.* routed to $path_o"
    mv partition.* $path_o/. 2> /dev/null
  fi

  rm -f prf*.mww3
  set -e

# exit 99

# 4. Gridded output ---------------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '|   Gridded output   |'
  echo '+--------------------+'
  echo ' '

cat > gx_outf.inp << EOF
$ WAVEWATCH III Grid output post-processing
$ -----------------------------------------
  19680606 000000  3600. 49
$
  T F F F F  T F F F F  T T F F F  F F F F F  F F F F F  F F F F F  F
$
  0 999 0 999  $SEA $BOU
$
$ End of input file
EOF

  for mod in $mods
  do
    echo "   GrADS data for $mod ..."
    echo "      Screen ouput routed to $path_o/gx_outf.$mod.out"
    ln -s mod_def.$mod mod_def.ww3
    ln -s out_grd.$mod out_grd.ww3

    $path_e/gx_outf > $path_o/gx_outf.$mod.out

    echo "      ww3.ctl routed to $path_o/$mod.ctl"
    sed -e "s/ww3\.grads/ww3\.$mod/g" \
        -e "s/0\.25/2\.50/g" ww3.ctl > $path_o/$mod.ctl
    rm -f ww3.ctl
    echo "      ww3.grads routed to $path_o/ww3.$mod"
    mv ww3.grads $path_o/ww3.$mod

    rm -f mod_def.ww3 out_grd.ww3

  done

  rm -f gx_outf.inp out_grd.*

  echo "   Plotting script put in $path_o/map.gs_tmpl"

cat > $path_o/map.gs_tmpl << EOF
*
* map.gs  : Imbedded GrADS script for test cases
* ----------------------------------------------------------------
*           Scripts used :
*              colorset.gs : Sets up shading colors
*
* General set up

  t1 =  1
  tn = $tn
  ts =  1

  plot_mpl = 'no'
  plot_mph = 'yes'
  plot_act = 'yes'
  plot_msk = 'yes'
  plot_hs  = 'yes'
  plot_con = 'yes'
  plot_dir = 'no'
  plot_dpt = 'yes'
  plot_box = 'yes'
  plot_bys = 'yes'

  plot_lab = 'yes'
  lab_col = 0
* lab_col = 1
* lab_col = 3
  pan = '(a)'

* Flags for low1-3 and hgh1-3

  grd.1 = 'yes'
  grd.2 = 'yes'
  grd.3 = 'yes'
  grd.4 = 'yes'
  grd.5 = 'yes'
  grd.6 = 'yes'

  xbl.1 = $xl1
  xbh.1 = $xh1
  ybl.1 = $yl1
  ybh.1 = $yh1

  xbl.2 = $xl2
  xbh.2 = $xh2
  ybl.2 = $yl2
  ybh.2 = $yh2

  xbl.3 = $xl3
  xbh.3 = $xh3
  ybl.3 = $yl3
  ybh.3 = $yh3

  xbl.4 = $xl5
  xbh.4 = $xh5
  ybl.4 = $yl5
  ybh.4 = $yh5

  xbl.5 = $xl6
  xbh.5 = $xh6
  ybl.5 = $yl6
  ybh.5 = $yh6

  xbl.6 = $xl7
  xbh.6 = $xh7
  ybl.6 = $yl7
  ybh.6 = $yh7

  xpl = 1.0
  xph = 7.5
  ypl = 2.5
  yph = 9.0

  xml =  -15
  xmh =  515
  yml =  -15
  ymh =  515

  clevs = '0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1'
  ccols = '21 23  24  26  27  29  30  32  33  35  36  38'

  if ( plot_act = 'yes' )
    col_act = 69
  else
    col_act = 70
  endif

  if ( plot_msk = 'yes' )
    col_msk = 71
  else
    col_msk = 70
  endif

  pdx = ( xph - xpl ) * 0.01
  strsiz = ( xph - xpl ) * 0.03

  'set display color white'
  'run colorset.gs'

  gdate="yyyy/mm/dd"
  '!date -u "+%Y/%m/%d" > tmp_grads_gdate'
  result = read (tmp_grads_gdate)
  gdate = sublin(result,2)
  '!rm -f tmp_grads_gdate'

  nr = 1
  x.1 = 200.
  y.1 = 400.
  s.1 = ' '

* ID output to screen

  say ' '
  say '----------------------'
  say '*** Running map.gs ***'
  say '----------------------'
  say ' ' 
  say 'Time steps from ' t1 ' through ' tn ' with step ' ts

* Open files

  'open $grdx1'
  'open $grdx2'
  'open $grdx3'
  'open $grdx4'
  'open $grdx5'
  'open $grdx6'

* Loop over time steps

  i = 1
  t = t1

  '!rm -f plot.grads.*'

  while ( t <= tn )
    'set t ' t

    'query time'
    gradsdate = subwrd(result,3)
    test = substr ( gradsdate, 3, 1 )
    if ( test='Z' )
      year = substr ( gradsdate, 9, 4 )
      mnth = substr ( gradsdate, 6, 3 )
      day  = substr ( gradsdate, 4, 2 )
      hour = substr ( gradsdate, 1, 2 )
      min  = '00'
    else
      year = substr ( gradsdate, 12, 4 )
        mnth = substr ( gradsdate, 9, 3 )
      day  = substr ( gradsdate, 7, 2 )
      hour = substr ( gradsdate, 1, 2 )
      min  = substr ( gradsdate, 4, 2 )
    endif

    month= '??'
    if (mnth='JAN'); month= '01'; endif;
    if (mnth='FEB'); month= '02'; endif;
    if (mnth='MAR'); month= '03'; endif;
    if (mnth='APR'); month= '04'; endif;
    if (mnth='MAY'); month= '05'; endif;
    if (mnth='JUN'); month= '06'; endif;
    if (mnth='JUL'); month= '07'; endif;
    if (mnth='AUG'); month= '08'; endif;
    if (mnth='SEP'); month= '09'; endif;
    if (mnth='OCT'); month= '10'; endif;
    if (mnth='NOV'); month= '11'; endif;
    if (mnth='DEC'); month= '12'; endif;

*   vdate = year '/' month '/' day ' ' hour ':' min 'z'
*   vdate = pan ' ' hour ':' min 'z'
*   vdate = pan ' ' hour ':' min
    vdate = hour ':' min 'z'

    say '   processing time step ' t ', time is ' vdate

* Basic plot set up

    'enable print plot.grads.' t
    'clear'
    'set grads off'

    'set lon ' xml / 10 ' ' xmh / 10
    'set lat ' yml / 10 ' ' ymh / 10
    'set xlint 10'
    'set ylint 10'
    'set xlab %.0f0'
    'set ylab %.0f0'
    'set grid on 3 60'
    'set mpdraw off'

    'set parea ' xpl ' ' xph ' ' ypl ' ' yph
    'set mproj scaled'

    if ( plot_mpl = 'yes' | plot_mph = 'yes' ) 
      'set line 70'
      'draw recf ' xpl ' ' ypl ' ' xph ' ' yph
    endif

* loop over grids

    j = 1
    while ( j <= 6 )
      if ( grd.j = 'yes' )
        say '      processing grid ' j ', flag = ' grd.j

* Plot map

        if ( plot_mpl = 'yes' & j <= 3 )
          'set gxout grfill'
          'set clevs -3.5 -2.5 -1.5 -0.5  0.5 1.5'
          'set ccols ' col_msk '  67   68   63   62   0  ' col_act
          'd map.' j
        endif

        if ( plot_mph = 'yes' & j >= 4 )
          'set gxout grfill'
          'set clevs -3.5 -2.5 -1.5 -0.5  0.5 1.5'
          'set ccols ' col_msk '  67   68   63   62   0  ' col_act
          'd map.' j
        endif

* Plot Hs

        if ( plot_hs = 'yes' )
          'set gxout $grtype'
          'set clevs ' clevs
          'set ccols ' ccols
          'd hs.' j ' / 10'
        endif

        if ( plot_con = 'yes' )
          'set gxout contour'
          'set cthick 1'
          'set ccolor 60'
          'set clevs ' clevs
          'set clab off'
          'd hs.' j ' / 10'
        endif

* Plot directions

        if ( plot_dir = 'yes' )
          'set gxout vector'
          'set cthick 3'
          'set arrscl 0.25'
          'set arrlab off'
          'set ccolor 1'
          if ( j <= 3 )
            k = 3
          else
            k = 6
          endif
          'd skip(cos(PEAKD.' j '),' k ');skip(sin(PEAKD.' j '),' k ')'
        endif

        if ( plot_dpt = 'yes' & j >=4 )
          'set gxout contour'
          'set cthick 1'
          'set ccolor 60'
          'set cint 50'
          'set clab off'
          'd depth.' j
        endif

      endif
      j = j + 1
    endwhile

* Plot boundary boxes

    j = 1
    while ( j <= 6 )
      if ( grd.j = 'yes'  & plot_box = 'yes' )
        xblp = xpl + ( xph - xpl ) * ( xbl.j - xml ) / ( xmh - xml )
        yblp = ypl + ( yph - ypl ) * ( ybl.j - yml ) / ( ymh - yml )
        xbhp = xpl + ( xph - xpl ) * ( xbh.j - xml ) / ( xmh - xml )
        ybhp = ypl + ( yph - ypl ) * ( ybh.j - yml ) / ( ymh - yml )
        if ( j <= 3 )
          'set line 2 ' j ' 10'
        else
          'set line 3 ' j - 3 ' 10'
        endif
        'draw rec ' xblp ' ' yblp ' ' xbhp ' ' ybhp
      endif
      j = j + 1
    endwhile

* Plot output locations

    'set strsiz ' 1.0 * pdx

    if ( plot_bys = 'yes' )
      j = 1
      while ( j <= nr )
        xb = xpl + ( xph - xpl ) * ( x.j - xml ) / ( xmh - xml )
        yb = ypl + ( yph - ypl ) * ( y.j - yml ) / ( ymh - yml )
        'set line 1'
        'draw recf ' xb-pdx ' ' yb-pdx ' ' xb+pdx ' ' yb+pdx
*       'set string 1 c'
*       'draw string ' xb + 3.0*pdx ' ' yb + 3.0*pdx ' ' s.j
        j = j + 1 
      endwhile
    endif
 
* Panel and date marker

    if ( plot_lab = 'yes' )
      'set string ' lab_col ' l'
      'set strsiz ' strsiz
*     'draw string 1.25 8.55 ' pan
      'draw string 1.25 8.55 ' vdate
    endif
 
* Finalize

    'print'
    'disable print'
    pull OK
    t = t + ts
    i = i + 1
  endwhile

* End of loop over time steps

  say ' '
  say '----------------------'
  say '*** End of map.gs  ***'
  say '----------------------'
  say ' ' 

  'quit'

* end of map.gs
EOF

# 5. Point output -----------------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '|    Point output    |'
  echo '+--------------------+'
  echo ' '

cat > ww3_outp.inp << EOF
$ WAVEWATCH III Point output post-processing
$ ------------------------------------------
  19680606 000000   600.  73
$
  1
 -1
$
  2
  2  50
$
$ End of input file
EOF

  for mod in $mods
  do
    if [ -f out_pnt.$mod ]
    then
      echo "   Point output for $mod ..."
      echo "      Screen ouput routed to $path_o/ww3_outp.$mod.out"
      ln -s mod_def.$mod mod_def.ww3
      ln -s out_pnt.$mod out_pnt.ww3

      $path_e/ww3_outp > $path_o/ww3_outp.$mod.out

      echo "      tab50.ww3 routed to $path_o/$mod.tab"
      mv tab50.ww3 $path_o/$mod.tab

      rm -f mod_def.ww3 out_pnt.ww3
    fi
  done


# 6. End, cleaning up -------------------------------------------------------

  echo ' ' ; echo "Cleaning-up `pwd`"
  rm -f mod_def.* log.*

  echo ' ' ; echo ' '
  echo '                  ======>  END OF WAVEWATCH III  <====== '
  echo '                    ==================================   '
  echo ' '

# End of mww3_test_03 -------------------------------------------------------
