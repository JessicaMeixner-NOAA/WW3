#!/bin/sh
#############################################################################
#                                                                           #
# mww3_test_02 : Tests for static nesting (propagation only)                #
#                Single nest basic test.                                    #
#                                                                           #
# Model should be compiled with the switches :                              #
#                                                                           #
#   !/FLXn !/LN0 !/ST0 !/NL0 !/BT0 !/DB0 !/TR0 !/BS0 !/XX0                  #
#                        No source terms needed.                            #
#   !/PRn                Selecting one of the propagation schemes.          #
#   !/O0 !/O1 !/O2 !/O3 !/O4 !/O5 !/O6 !/O7 !/O10                           #
#                        Sdt out output options.                            #
#                                                                           #
# No other optional switches should be used.                                #
#                                                                           #
# Grids generated in this test :                                            #
#                                                                           #
#  outer  : The outer grid as used by all runs (25km).                      #
#  course : Inner grid with same resolution (25km).                         #
#  fine   : Inner grid with high resolution (12.5km).                       #
#  tiny   : Inner grid with high resolution (5km).                          #
#  respec : Inner grid with different spectral resolution (25km).           #
#                                                                           #
# Remarks :                                                                 #
# - Grads scripts generated by this test can be used to visualize results.  #
#   If the MPRF switch is used the grofiing data sets are copied to the     #
#   home directory for display with profile.gs.                             #
# - Script set up for parallel running :                                    #
#    a) For cluster with mpirun activate mpirun command lines and set       #
#       environment with valiables MPI and proc in section 0.               #
#    b) For IBM with poe, activale poe command lines and set environment    #
#       variables in poe jobcards at the top of the scripts.                #
#    c) For SGI with MPIT several environment setting are needed in the     #
#       head of the script, as well as job cards and using the mpiexec_mpt  #
#       to start the code to run in the parallel environment.               #
#    d) In present form, IBM qsub directives are disabled to avoid unwanted #
#       translation by msub on zeus.                                        #
#                                                                           #
#                                              Hendrik Tolman, Sep 2005     #
#                                                   Last Mod : March 2012   #
#                                                                           #
#    Copyright 2009-2012 National Weather Service (NWS),                    #
#       National Oceanic and Atmospheric Administration.  All rights        #
#       reserved.  WAVEWATCH III is a trademark of the NWS.                 #
#       No unauthorized use without permission.                             #
#                                                                           #
#############################################################################

# #@ shell=/bin/sh
# #@ job_name=mww3_test_02
# #@ output=mww3_test_02.out
# #@ error=mww3_test_02.out
# #@ notification=never
# #@ class=dev
# #@ network.MPI=csss,shared,us
# #@ total_tasks=6
# #@ node=1
# #@ job_type=parallel
# #@ wall_clock_limit=00:01:00
# #@ resources=ConsumableCpus(1) ConsumableMemory(500 MB)
# #@ account_no=WAV-T2O
# #@ queue

#PBS -l procs=6
# #PBS -l mem=1G
#PBS -q batch
#PBS -l walltime=05:00
#PBS -A omd
#PBS -N mww3_test_02
#PBS -j oe
#PBS -o mww3_test_02.out

# 0. Preparations -----------------------------------------------------------

  set -e

  ww3_env='.wwatch3.env'   # setup file

   mod1=outer              # Outer model to run

#  mod2=course             # Inner model to run, same as outer (25km)
   mod2=fine               #                     12.5km reolsution
#  mod2=tiny               #                     5km reolsution
#  mod2=respec             #                     new spectral resolution

#  mode=single             # Single or multi-grid model(s) key on single
   mode=multi

# rerun='yes'              # rerun inner grid with ww3_shel using data
                           # dumped by ww3_multi
  grtype=shaded
# grtype=grfill

# t_end='19680606 010000' ; tn='2'
# t_end='19680606 060000' ; tn='7'
# t_end='19680606 120000' ; tn='13'
# t_end='19680607 000000' ; tn='25'
# t_end='19680607 120000' ; tn='37'
  t_end='19680608 000000' ; tn='49'

    MPI='yes'              # run ww3_multi in MPI mode
   proc=6                  # used for mpirun only

# zeus MPIT settings

  MPI_BUFS_PER_PROC=128
  MPI_BUFS_PER_HOST=128
  MPI_GROUP_MAX=128

# 0.a Set-up variables

  cd
  if [ -f $ww3_env ]
  then
    set `grep WWATCH3_DIR $ww3_env` ; shift
    main_dir="$*"
    set `grep WWATCH3_TMP $ww3_env` ; shift
    temp_dir="$*"
  else
    echo "*** Set-up file $ww3_env not found ***"
    exit
  fi

  path_w="$temp_dir"              # work directory
  path_e="$main_dir/exe"          # path for executables
  path_a="$main_dir/aux"          # path for aux files and scripts
  path_o="$main_dir/test"         # path for output files
  path_o="$main_dir/work"

# 0.b Clean-up

  cd $path_w

  echo ' ' ; echo ' '
  echo '                  ======> TEST RUN WAVEWATCH III <====== '
  echo '                    ==================================   '
  echo '                        test static nesting (propagation)'
  echo ' '

# 1. Grid pre-processor -----------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '|  Grid preprocessor |'
  echo '+--------------------+'
  echo ' '

  rm -f mod_def.*

cat > ww3_grid.inp << EOF
$ WAVEWATCH III Grid preprocessor input file
$ ------------------------------------------
  'The outer grid @ 25 km        '
$
   1.1 0.04177 25 24 0.
$
   F T T F F F
   900.  900.  900.   15.
$
  &PRO2 DTIME = 0. /
$ &PRO2 DTIME = 21600. /
$ &PRO3 WDTHCG = 0., WDTHTH = 0. /
END OF NAMELISTS
$
   'RECT' F 'NONE'
   43   43
    25.E3   25.E3   1.
   -25.E3  -25.E3   1.
$
  -0.1 0.25  10  -1000. 4 1 '(....)' 'UNIT' 'input'
$
  1849*1
$
   10 1 1 '(....)' 'PART' 'mapsta.inp'
$
   0  0  F
   0  0  F
   0  0
$
EOF

  if [ "$mode" = 'single' ]
  then
    if [ "$mod2" = 'tiny' ]
    then
      echo '   600.E3 600.E3  5.E3  0.E3  60' >> ww3_grid.inp
      echo '   900.E3 600.E3  0.E3  5.E3  60' >> ww3_grid.inp
      echo '   900.E3 900.E3 -5.E3  0.E3  60' >> ww3_grid.inp
      echo '   600.E3 900.E3  0.E3 -5.E3  60' >> ww3_grid.inp
      echo '     0.     0.    0.    0.     0' >> ww3_grid.inp
    else
      if [ "$mod2" = 'fine' ]
      then
        echo '   600.E3 600.E3  12.5E3   0.0E3  24' >> ww3_grid.inp
        echo '   900.E3 600.E3   0.0E3  12.5E3  24' >> ww3_grid.inp
        echo '   900.E3 900.E3 -12.5E3   0.0E3  24' >> ww3_grid.inp
        echo '   600.E3 900.E3   0.0E3 -12.5E3  24' >> ww3_grid.inp
        echo '     0.     0.     0.      0.      0' >> ww3_grid.inp
      else
        echo '   600.E3 600.E3  25.E3   0.E3  12' >> ww3_grid.inp
        echo '   900.E3 600.E3   0.E3  25.E3  12' >> ww3_grid.inp
        echo '   900.E3 900.E3 -25.E3   0.E3  12' >> ww3_grid.inp
        echo '   600.E3 900.E3   0.E3 -25.E3  12' >> ww3_grid.inp
        echo '     0.     0.     0.     0.     0' >> ww3_grid.inp
      fi
    fi
  else
    echo '     0.     0.     0.     0.     0' >> ww3_grid.inp
  fi

  echo "   Screen ouput routed to $path_o/ww3_grid.$mod1.out"
  $path_e/ww3_grid > $path_o/ww3_grid.$mod1.out

  rm -f ww3_grid.inp mapsta.ww3 mask.ww3
  mv mod_def.ww3 mod_def.$mod1

  echo '$ WAVEWATCH III Grid preprocessor input file'         > ww3_grid.inp
  echo '$ ------------------------------------------'        >> ww3_grid.inp
  case $mod2 in
   'tiny'   ) echo "  'Fine (5km) inner nest         '"      >> ww3_grid.inp ;;
   'fine'   ) echo "  'Fine (12.5km) inner nest      '"      >> ww3_grid.inp ;;
   'respec' ) echo "  'Change in spectral resolution '"      >> ww3_grid.inp ;;
     *      ) echo "  'Course inner nest             '"      >> ww3_grid.inp ;;
  esac
  echo '$'                                                   >> ww3_grid.inp
  if [ "$mod2" = 'respec' ]
  then
#   echo '   1.07 0.050 45 48 0.50'                          >> ww3_grid.inp
#   echo '   1.1 0.04177 25 48 0.50'                         >> ww3_grid.inp
    echo '   1.1 0.04177 26 24 0.'                           >> ww3_grid.inp
  else
    echo '   1.1 0.04177 25 24 0.'                           >> ww3_grid.inp
  fi
  echo '$'                                                   >> ww3_grid.inp
  echo '   F T T F F F'                                      >> ww3_grid.inp
  if [ "$mod2" = 'tiny' ]
  then
    echo '   225.  225.  225.   15.'                         >> ww3_grid.inp
  else
    if [ "$mod2" = 'fine' ]
    then
      echo '   450.  450.  450.   15.'                       >> ww3_grid.inp
    else
      echo '   900.  900.  900.   15.'                       >> ww3_grid.inp
    fi
  fi
  echo '$'                                                   >> ww3_grid.inp
  echo '$ &PRO2 DTIME = 21600. /'                            >> ww3_grid.inp
  echo '  &PRO3 WDTHCG = 0., WDTHTH = 0. /'                  >> ww3_grid.inp
  echo '  &PRO4 RNFAC = 0., RSFAC = 0. /'                    >> ww3_grid.inp
  echo 'END OF NAMELISTS'                                    >> ww3_grid.inp
  echo '$'                                                   >> ww3_grid.inp
  echo "'RECT' F F"                                          >> ww3_grid.inp
  if [ "$mod2" = 'tiny' ]
  then
    echo '   61   61'                                        >> ww3_grid.inp
    echo '     5.E3    5.E3   1.'                            >> ww3_grid.inp
    echo '   600.E3  600.E3   1.'                            >> ww3_grid.inp
  else
    if [ "$mod2" = 'fine' ]
    then
      echo '   25   25'                                      >> ww3_grid.inp
      echo '    12.5E3   12.5E3   1.'                        >> ww3_grid.inp
      echo '   600.0E3  600.0E3   1.'                        >> ww3_grid.inp
    else
      echo '   13   13'                                      >> ww3_grid.inp
      echo '    25.E3   25.E3   1.'                          >> ww3_grid.inp
      echo '   600.E3  600.E3   1.'                          >> ww3_grid.inp
    fi
  fi
  echo '$'                                                   >> ww3_grid.inp
  echo "  -0.1 0.25  10  -1000. 4 1 '(....)' 'UNIT' 'input'" >> ww3_grid.inp
  echo '$'                                                   >> ww3_grid.inp
  echo '   3721*1'                                           >> ww3_grid.inp
  echo '$'                                                   >> ww3_grid.inp
  echo "   10 1 1 '(....)' 'PART' 'mapsta.inp'"              >> ww3_grid.inp
  echo '$'                                                   >> ww3_grid.inp
  echo '   1  1  T'                                          >> ww3_grid.inp
  if [ "$mod2" = 'tiny' ]
  then
    echo '   1 61  T'                                        >> ww3_grid.inp
    echo '  61 61  T'                                        >> ww3_grid.inp
    echo '  61  1  T'                                        >> ww3_grid.inp
    echo '   1  1  T'                                        >> ww3_grid.inp
  else
    if [ "$mod2" = 'fine' ]
    then
      echo '   1 25  T'                                      >> ww3_grid.inp
      echo '  25 25  T'                                      >> ww3_grid.inp
      echo '  25  1  T'                                      >> ww3_grid.inp
      echo '   1  1  T'                                      >> ww3_grid.inp
    else
      echo '   1 13  T'                                      >> ww3_grid.inp
      echo '  13 13  T'                                      >> ww3_grid.inp
      echo '  13  1  T'                                      >> ww3_grid.inp
      echo '   1  1  T'                                      >> ww3_grid.inp
    fi
  fi
  echo '   0  0  F'                                          >> ww3_grid.inp
  echo '$'                                                   >> ww3_grid.inp
  echo '   0  0  F'                                          >> ww3_grid.inp
  echo '   0  0'                                             >> ww3_grid.inp
  echo '$'                                                   >> ww3_grid.inp
  echo '   0. 0. 0. 0.  0'                                   >> ww3_grid.inp


  echo "   Screen ouput routed to $path_o/ww3_grid.$mod2.out"
  $path_e/ww3_grid > $path_o/ww3_grid.$mod2.out

  rm -f ww3_grid.inp mapsta.ww3 mask.ww3
  mv mod_def.ww3 mod_def.$mod2

# 2. Initial conditions -----------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '| Initial conditions |'
  echo '+--------------------+'
  echo ' '

cat > ww3_strt.inp << EOF
$ WAVEWATCH III Initial conditions input file
$ -------------------------------------------
  1
   0.10 0.0001  225. 100 250.E3 75.E3 250.E3 75.E3  10.0
$  0.10 0.0001  225. 100 600.E3 75.E3 600.E3 75.E3  10.0
EOF

  for grid in $mod1 $mod2
  do
    rm -f mod_def.ww3
    ln -s mod_def.$grid mod_def.ww3
    echo "   Screen ouput routed to $path_o/ww3_strt.$grid.out"
    $path_e/ww3_strt > $path_o/ww3_strt.$grid.out
    mv restart.ww3 restart.$grid
  done

  rm -f ww3_strt.inp mod_def.ww3

# 3. Input fields -----------------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '| Input data         |'
  echo '+--------------------+'
  echo ' '
  echo '   Not needed for present test.'

# 4. Main program -----------------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '|    Main program    |'
  echo '+--------------------+'
  echo ' '

cat > ww3_shel.inp << EOF
$ WAVEWATCH III shell input file
$ ------------------------------
   F T
   F T
   F T
   F
   F
   F
   F
$
   19680606 000000
   $t_end
$
   1
   19680606 000000    900  19680608 000000
     T T T T T  T T T T T  T T T T T  T T T T T  T T T T T
     T T T T T  T
   19680606 000000    900  19680608 000000
     750.E3 750.E3  'point_A   '
       0.E3   0.E3  'STOPSTRING'
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
   19680606 000000    900  19680608 000000
   19680606 000000      0  19680608 000000
$
   'STP'
$
$ End of input file
EOF

  if [ "$rerun" = 'yes' ] ;  then
    RERUN='T' ;  else
    RERUN='F' ;  fi

cat > ww3_multi.inp << EOF
$ WAVEWATCH III multi-scale input file
$ ------------------------------------
  2 0 F 1 F F
$
  '$mod1' 'no' 'no' 'no' 'no' 'no' 'no' 'no'   1  1  0.00 1.00  F
  '$mod2' 'no' 'no' 'no' 'no' 'no' 'no' 'no'   2  1  0.00 1.00  $RERUN
$ '$mod1' 'no' 'no' 'no' 'no' 'no' 'no' 'no'   1  1  0.50 1.00  F
$ '$mod2' 'no' 'no' 'no' 'no' 'no' 'no' 'no'   2  1  0.00 0.50  $RERUN
$ '$mod1' 'no' 'no' 'no' 'no' 'no' 'no' 'no'   1  1  0.25 1.00  F
$ '$mod2' 'no' 'no' 'no' 'no' 'no' 'no' 'no'   2  1  0.00 0.75  $RERUN
$
   19680606 000000   $t_end
$
   T  T
$
   19680606 000000   3600  19680608 000000
     T T T T T  T T T T T  T T T T T  T T T T T  T T T T T
     T T T T T  T
   19680606 000000   3600  19680608 000000
     750.E3 750.E3  'point_A   '
       0.E3   0.E3  'STOPSTRING'
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
$
  'the_end'  0
$
  'STP'
$
$ End of input file
EOF

  if [ "$mode" = 'single' ]
  then
    echo "   Running individual models ..."

    for mod in $mod1 $mod2
    do
      ln -s mod_def.$mod mod_def.ww3
      ln -s restart.$mod restart.ww3
#     echo "   Screen ouput routed to $path_o/ww3_shel.$mod.out"

      if [ "$MPI" = 'yes' ]
      then
        mpiexec_mpt -np $PBS_NP $path_e/ww3_shel # > $path_o/ww3_shel.$mod.out
#       mpirun -np $proc $path_e/ww3_shel # > $path_o/ww3_shel.$mod.out
#       poe $path_e/ww3_shel # > $path_o/ww3_shel.$mod.out
      else
        $path_e/ww3_shel # > $path_o/ww3_shel.$mod.out
      fi

      echo "   Log and output files renamed to xxx.$mod"
      mv log.ww3 log.$mod
      cp log.$mod $path_o/.
      mv out_grd.ww3 out_grd.$mod
      mv out_pnt.ww3 out_pnt.$mod
      rm -f mod_def.ww3
      rm -f restart.ww3
      rm -f nest.ww3
      if [ -f nest1.ww3 ] ;  then
        mv nest1.ww3 nest.ww3 ; fi
    done

  else
    echo "   Running multi-scale model ..."

#   echo "   Screen output routed to $path_o/ww3_multi.out"

    if [ "$MPI" = 'yes' ]
    then
      mpiexec_mpt -np $PBS_NP $path_e/ww3_multi # > $path_o/ww3_multi.out
#     mpirun -np $proc $path_e/ww3_multi # > $path_o/ww3_multi.out
#     poe $path_e/ww3_multi # > $path_o/ww3_multi.out
    else
      $path_e/ww3_multi # > $path_o/ww3_multi.out
    fi

    echo "   Log files routed to $path_o"
    mv log.* $path_o/.

  fi

  if [ "$rerun" = 'yes' ] && [ "$mode" = 'multi' ]
  then
    echo "   Rerunning inner model ..."

    rm -f log.$mod2
    rm -f out_pnt.$mod2
    rm -f out_grd.$mod2
    ln -s mod_def.$mod2 mod_def.ww3
    ln -s restart.$mod2 restart.ww3
    ln -s nest.$mod2    nest.ww3
    echo "   Screen ouput routed to $path_o/ww3_shel.$mod2.out"

    if [ "$MPI" = 'yes' ]
    then
      mpiexec_mpt -np $PBS_NP $path_e/ww3_shel # > $path_o/ww3_shel.$mod2.out
#     mpirun -np $proc $path_e/ww3_shel # > $path_o/ww3_shel.$mod2.out
#     poe $path_e/ww3_shel # > $path_o/ww3_shel.$mod2.out
    else
      $path_e/ww3_shel # > $path_o/ww3_shel.$mod2.out
    fi

    echo "   Log and output files renamed to xxx.$mod2"
    mv log.ww3 log.$mod
    cp log.$mod $path_o/.
    mv out_grd.ww3 out_grd.$mod2
    mv out_pnt.ww3 out_pnt.$mod2
    rm -f mod_def.ww3
    rm -f restart.ww3
  fi

  rm -f ww3_shel.inp
  rm -f ww3_multi.inp
  rm -f restart.*
  rm -f nest*.*

  set +e
  nr_test=`ls test* 2> /dev/null | wc -w | awk '{ print $1}'`
  if [ "$nr_test" != '0' ]
  then
    for file in `ls test* 2> /dev/null`
    do
      size=`wc -w $file | awk '{print $1}'`
      if [ "$size" = 0 ] ; then
        rm -f $file ; fi
    done
  fi

  nr_test=`ls test* 2> /dev/null | wc -w | awk '{ print $1}'`
  if [ "$nr_test" != '0' ]
  then
    echo "   Output file test[nnn].[m]ww3 routed to $path_o"
    mv test* $path_o/.
  fi

  nr_prof=`ls prf*.mww3 2> /dev/null | wc -w | awk '{ print $1}'`
  if [ "$nr_prof" != '0' ]
  then
    echo "   Profiling file prf.*.mww3 routed to $path_o"
    mv prf*.mww3 $path_o/. 2> /dev/null
  fi

  nr_part=`ls partition.* 2> /dev/null | wc -w | awk '{ print $1}'`
  if [ "$nr_part" != '0' ]
  then
    echo "   Partition file partition.* routed to $path_o"
    mv partition.* $path_o/. 2> /dev/null
  fi

  rm -f prf*.mww3

  set -e

# exit 99

# 4. Gridded output ---------------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '|   Gridded output   |'
  echo '+--------------------+'
  echo ' '

cat > gx_outf.inp << EOF
$ WAVEWATCH III Grid output post-processing
$ -----------------------------------------
  19680606 000000  3600. 49
$
  F F F F F  T F F F F  T T F F F  F F F F F  F F F F F F  F F F F F  F
$
  0 999 0 999  T T
$
$ End of input file
EOF

  for mod in $mod1 $mod2
  do
    echo "   GrADS data for $mod ..."
    echo "      Screen ouput routed to $path_o/gx_outf.$mod.out"
    ln -s mod_def.$mod mod_def.ww3
    ln -s out_grd.$mod out_grd.ww3

    $path_e/gx_outf > $path_o/gx_outf.$mod.out

    echo "      ww3.ctl routed to $path_o/$mod.ctl"
    sed -e "s/ww3\.grads/ww3\.$mod/g" \
        -e "s/0\.25/2\.50/g" ww3.ctl > $path_o/$mod.ctl
    rm -f ww3.ctl
    echo "      ww3.grads routed to $path_o/ww3.$mod"
    mv ww3.grads $path_o/ww3.$mod

    rm -f mod_def.ww3 out_grd.ww3

  done

  rm -f gx_outf.inp out_grd.*

  echo "      Plotting script put in $path_o/map.gs_tmpl"

cat > $path_o/map.gs_tmpl << EOF
*
* map.gs  : Imbedded GrADS script for test cases
* ----------------------------------------------------------------
*           Scripts used :
*              colorset.gs : Sets up shading colors
*
* General set up

  t1 =  1
  tn = $tn
  ts =  1

  plot_map = 'yes'
  plot_act = 'yes'
  plot_msk = 'yes'
  plot_hs  = 'yes'
  plot_con = 'yes'
  plot_dir = 'no'
  plot_bys = 'yes'
  plot_lab = 'yes'
  plot_box = 'yes'
  pan = '(-)'

  plot_1 = 'yes'
  plot_2 = 'yes'

  xpl = 1.0
  xph = 7.5
  ypl = 2.5
  yph = 9.0

  xml =  -25
  xmh = 1025
  yml =  -25
  ymh = 1025

* xml =  400
* xmh = 1000
* yml =  400
* ymh = 1000

  clevs = '0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1'
  ccols = '21 23  24  26  27  29  30  32  33  35  36  38'

  if ( plot_act = 'yes' )
    col_act = 69
  else
    col_act = 70
  endif

  if ( plot_msk = 'yes' )
    col_msk = 71
  else
    col_msk = 70
  endif

  pdx = ( xph - xpl ) * 0.01
  strsiz = ( xph - xpl ) * 0.03

  'set display color white'
  'run colorset.gs'

  gdate="yyyy/mm/dd"
  '!date -u "+%Y/%m/%d" > tmp_grads_gdate'
  result = read (tmp_grads_gdate)
  gdate = sublin(result,2)
  '!rm -f tmp_grads_gdate'

* Set buoy data from buoy.data

* '!sed -e "s/\./ /g"  -e "s/\_/ /g" buoy.data > tmp_grads_buoy'

  nr = 1
  x.1 = 750.
  y.1 = 750.
  s.1 = ' '

* ID output to screen

  say ' '
  say '----------------------'
  say '*** Running map.gs ***'
  say '----------------------'
  say ' ' 
  say 'Number of ouptput points : ' nr
  say 'Time steps from ' t1 ' through ' tn ' with step ' ts

* Loop over time steps

  'open outer'
  'open $mod2'

  i = 1
  t = t1

  '!rm -f plot.grads.*'

  while ( t <= tn )
    'set t ' t

    'query time'
    gradsdate = subwrd(result,3)
    test = substr ( gradsdate, 3, 1 )
    if ( test='Z' )
      year = substr ( gradsdate, 9, 4 )
      mnth = substr ( gradsdate, 6, 3 )
      day  = substr ( gradsdate, 4, 2 )
      hour = substr ( gradsdate, 1, 2 )
      min  = '00'
    else
      year = substr ( gradsdate, 12, 4 )
        mnth = substr ( gradsdate, 9, 3 )
      day  = substr ( gradsdate, 7, 2 )
      hour = substr ( gradsdate, 1, 2 )
      min  = substr ( gradsdate, 4, 2 )
    endif

    month= '??'
    if (mnth='JAN'); month= '01'; endif;
    if (mnth='FEB'); month= '02'; endif;
    if (mnth='MAR'); month= '03'; endif;
    if (mnth='APR'); month= '04'; endif;
    if (mnth='MAY'); month= '05'; endif;
    if (mnth='JUN'); month= '06'; endif;
    if (mnth='JUL'); month= '07'; endif;
    if (mnth='AUG'); month= '08'; endif;
    if (mnth='SEP'); month= '09'; endif;
    if (mnth='OCT'); month= '10'; endif;
    if (mnth='NOV'); month= '11'; endif;
    if (mnth='DEC'); month= '12'; endif;

*   vdate = year '/' month '/' day ' ' hour ':' min 'z'
*   vdate = pan ' ' hour ':' min 'z'
    vdate = hour ':' min 'z'

    say '   processing time step ' t ', time is ' vdate

* Basic plot set up

    'enable print plot.grads.' t
    'clear'
    'set grads off'
    'set lon ' xml / 10 ' ' xmh / 10
    'set lat ' yml / 10 ' ' ymh / 10
    'set xlint 10'
    'set ylint 10'
    'set xlab %.0f0'
    'set ylab %.0f0'
    'set grid on 3 60'
    'set mpdraw off'

    'set parea ' xpl ' ' xph ' ' ypl ' ' yph
    'set mproj scaled'

* Plot map

    if ( plot_map = 'yes' )
      'set line 70'
      'draw recf 1. 2.5 7.5 9.'
      'draw recf ' xpl ' ' ypl ' ' xph ' ' yph

      if ( plot_1 = 'yes' )
        'set gxout grfill'
        'set clevs -3.5 -2.5 -1.5 -0.5  0.5 1.5'
        'set ccols ' col_msk '  67   68   63   62   0  ' col_act
        'd map.1'
      endif

      if ( plot_2 = 'yes' )
        'set gxout grfill'
        'set clevs -3.5 -2.5 -1.5 -0.5  0.5 1.5'
        'set ccols ' col_msk '  67   68   63   62   0  ' col_act
        'd map.2'
      endif

    endif

* Plot Hs

    if ( plot_hs = 'yes' ) & ( plot_1 = 'yes' )
      'set gxout $grtype'
      'set clevs ' clevs
      'set ccols ' ccols
      'd hs.1 / 10'
  
      if ( plot_con = 'yes' )
        'set gxout contour'
        'set cthick 1'
        'set ccolor 60'
        'set clevs ' clevs
        'set clab off'
        'd hs.1 / 10'
      endif
    endif

    if ( plot_hs = 'yes' ) & ( plot_2 = 'yes' ) & ( t > 1 )
*   if ( plot_hs = 'yes' ) & ( plot_2 = 'yes' )
      xbl = xpl + ( xph - xpl ) * ( 600. - xml ) / ( xmh - xml )
      ybl = ypl + ( yph - ypl ) * ( 600. - yml ) / ( ymh - yml )
      xbh = xpl + ( xph - xpl ) * ( 900. - xml ) / ( xmh - xml )
      ybh = ypl + ( yph - ypl ) * ( 900. - yml ) / ( ymh - yml )
      'set line 21'
      'draw recf ' xbl ' ' ybl ' ' xbh ' ' ybh

      'set gxout $grtype'
      'set clevs ' clevs
      'set ccols ' ccols
      'd hs.2 / 10'
  
      if ( plot_con = 'yes' )
        'set gxout contour'
        'set cthick 1'
        'set ccolor 60'
        'set clevs ' clevs
        'set clab off'
        'd hs.2 / 10'
      endif
    endif

* Plot directions

    if ( plot_dir = 'yes' ) & ( plot_1 = 'yes' )
      'set gxout vector'
      'set cthick 3'
      'set arrscl 0.25'
      'set arrlab off'
      'set ccolor 1'
      'd skip(cos(PEAKD.1),2);skip(sin(PEAKD.1),2)'
    endif

    if ( plot_dir = 'yes' ) & ( plot_2 = 'yes' )
      'set gxout vector'
      'set cthick 3'
      'set arrscl 0.25'
      'set arrlab off'
      'set ccolor 5'
      'd skip(cos(PEAKD.1),2);skip(sin(PEAKD.2),2)'
    endif

* Plot output locations

    'set strsiz ' 1.0 * pdx

    if ( plot_bys = 'yes' )
      j = 1
      while ( j <= nr )
        xb = xpl + ( xph - xpl ) * ( x.j - xml ) / ( xmh - xml )
        yb = ypl + ( yph - ypl ) * ( y.j - yml ) / ( ymh - yml )
        'set line 1'
        'draw recf ' xb-pdx ' ' yb-pdx ' ' xb+pdx ' ' yb+pdx
*       'set string 1 c'
*       'draw string ' xb + 3.0*pdx ' ' yb + 3.0*pdx ' ' s.j
        j = j + 1
      endwhile
    endif

* Plot boundary box

    if ( plot_box = 'yes' )
      xbl = xpl + ( xph - xpl ) * ( 600. - xml ) / ( xmh - xml )
      ybl = ypl + ( yph - ypl ) * ( 600. - yml ) / ( ymh - yml )
      xbh = xpl + ( xph - xpl ) * ( 900. - xml ) / ( xmh - xml )
      ybh = ypl + ( yph - ypl ) * ( 900. - yml ) / ( ymh - yml )
      'set line 2 1 10'
      'draw rec ' xbl ' ' ybl ' ' xbh ' ' ybh
    endif
 
* Panel and date marker

    if ( plot_lab = 'yes' )
      if ( plot_hs = 'yes' ) & ( plot_1 = 'yes' )
        'set string 0 l'
      else
        'set string 1 l'
      endif
      'set strsiz ' strsiz
*     'draw string 1.25 8.55 ' pan
      'draw string 1.25 8.55 ' vdate
    endif
 
* Finalize

    'print'
    'disable print'
    pull OK
    t = t + ts
    i = i + 1
  endwhile

* End of loop over time steps

  say ' '
  say '----------------------'
  say '*** End of map.gs  ***'
  say '----------------------'
  say ' ' 

  'quit'

* end of map.gs
EOF

# 5. Point output -----------------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '|    Point output    |'
  echo '+--------------------+'
  echo ' '

cat > ww3_outp.inp << EOF
$ WAVEWATCH III Point output post-processing
$ ------------------------------------------
  19680606 000000   900.  193
$
  1
 -1
$
  2
  2  50
$
$ End of input file
EOF

  for mod in $mod1 $mod2
  do
    echo "   Point output for $mod ..."
    echo "      Screen ouput routed to $path_o/ww3_outp.$mod.out"
    ln -s mod_def.$mod mod_def.ww3
    ln -s out_pnt.$mod out_pnt.ww3

    $path_e/ww3_outp > $path_o/ww3_outp.$mod.out

    echo "      tab50.ww3 routed to $path_o/$mod.tab"
    mv tab50.ww3 $path_o/$mod.tab

    rm -f mod_def.ww3 out_pnt.ww3
  done

  rm -f ww3_outp.inp out_pnt.*

# 6. End, cleaning up -------------------------------------------------------

  echo ' ' ; echo "Cleaning-up `pwd`"
  rm -f mod_def.* log.*

  echo ' ' ; echo ' '
  echo '                  ======>  END OF WAVEWATCH III  <====== '
  echo '                    ==================================   '
  echo ' '

# End of mww3_test_02 -------------------------------------------------------
