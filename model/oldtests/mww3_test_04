#!/bin/sh
#############################################################################
#                                                                           #
# mww3_test_04 : Tests for static nesting (propagation only)                #
#                Propagation test with lateral boundary data from file      #
#                (1-D run) and inner grid with shallow water and/or         #
#                currents.                                                  #
#                                                                           #
# Model should be compiled with the switches :                              #
#                                                                           #
#   !/FLXn !/LN0 !/ST0 !/NL0 !/BT0 !/DB0 !/TR0 !/BS0 !/XX0                  #
#                        No source terms needed.                            #
#   !/PRn                Selecting one of the propagation schemes.          #
#   !/O0 !/O1 !/O2 !/O3 !/O4 !/O5 !/O6 !/O7 !/O10                           #
#                        Sdt out output options.                            #
#                                                                           #
# No other optional switches should be used.                                #
#                                                                           #
# Grids generated in this test :                                            #
#                                                                           #
#  bound  : The separate grid for generating boundary conditions.           #
#  outer  : The outer grid as used by all runs (10km).                      #
#  inner  : Inner grid with high resolution (5km).                          #
#                                                                           #
#  Remarks :                                                                #
#  - Note that the outer boundary data is generated by a 1-D model, with    #
#    one version of the script running this as a separate ww3_shel, the     #
#    other option integrating it in ww3_multi as the third model.           #
#  - Choice of governing euqations in WAVEWATCH III implies that it is      #
#    not possible to do a purely monochromatic proagation over currents,    #
#    as changes in wavenumbers are modeled as proaption in k-space.         #
# - Grads scripts generated by this test can be used to visualize results.  #
#   If the MPRF switch is used the grofiing data sets are copied to the     #
#   home directory for display with profile.gs.                             #
# - Script set up for parallel running :                                    #
#    a) For cluster with mpirun activate mpirun command lines and set       #
#       environment with valiables MPI and proc in section 0.               #
#    b) For IBM with poe, activale poe command lines and set environment    #
#       variables in poe jobcards at the top of the scripts.                #
#    c) For SGI with MPIT several environment setting are needed in the     #
#       head of the script, as well as job cards and using the mpiexec_mpt  #
#       to start the code to run in the parallel environment.               #
#    d) In present form, IBM qsub directives disabled to avoid unwanted     #
#       translation by msub on zeus.                                        #
#                                                                           #
#                                              Hendrik Tolman, Jun 2002     #
#                                                 Last Mod : March 2012     #
#                                                                           #
#    Copyright 2009-2012 National Weather Service (NWS),                    #
#       National Oceanic and Atmospheric Administration.  All rights        #
#       reserved.  WAVEWATCH III is a trademark of the NWS.                 #
#       No unauthorized use without permission.                             #
#                                                                           #
#############################################################################

# #@ shell=/bin/sh
# #@ job_name=mww3_test_04
# #@ output=mww3_test_04.out
# #@ error=mww3_test_04.out
# #@ notification=never
# #@ class=dev
# #@ network.MPI=csss,shared,us
# #@ total_tasks=6
# #@ node=1
# #@ job_type=parallel
# #@ wall_clock_limit=00:03:00
# #@ resources=ConsumableCpus(1) ConsumableMemory(500 MB)
# #@ account_no=WAV-T2O
# #@ queue

#PBS -l procs=6
# #PBS -l mem=1G
#PBS -q batch
#PBS -l walltime=05:00
#PBS -A omd
#PBS -N mww3_test_04
#PBS -j oe
#PBS -o mww3_test_04.out

# 0. Preparations -----------------------------------------------------------

  set -e

  ww3_env='.wwatch3.env'   # setup file

#     f77=f77
#     f77=pgf90
      f77=ifort

   shoal='no '             # Use shoal in grid (otherwise deep)
    dmin=' 15.'            # Minimum depth, if <0, there be a shoal.

    curr='yes'             # Use anular current in inner grid
    Rmax='50.'             # Radius of maximum velocity
    Umax='1.0'             # Maximum current velocity

    circ='yes'             # Use circular mask (otherwise square)

#  mode=single             # Single or multi-scale model(s) key on multi
   mode=multi

  uni_pt='yes'             # Unified point output in grid '.points'

  grtype=shaded
# grtype=grfill

# t_end='19680606 000000' ; tn='1'
# t_end='19680606 010000' ; tn='2'
# t_end='19680606 060000' ; tn='7'
# t_end='19680606 120000' ; tn='13'
# t_end='19680607 000000' ; tn='25'
# t_end='19680607 120000' ; tn='37'
# t_end='19680608 000000' ; tn='49'
  t_end='19680607 120000' ; tn='109'

    MPI='yes'              # run ww3_shel and ww3_multi in MPI mode
   proc=4                  # used for mpirun only

  PRO2='  &PRO2 DTIME = 7200. /'
  PRO3='  &PRO3 WDTHCG = 1.50, WDTHTH = 1.50 /'
# PRO3='  &PRO3 WDTHCG = 0., WDTHTH = 0. /'

  spec_o='   1.03 0.075 20 24 0.'
# spec_o='   1.03 0.075 20 48 0.'
  time_o='   720.  720.  720.   15.'

  spec_i='   1.03 0.075 20 24 0.'
# spec_i='   1.03 0.075 20 48 0.'
  time_i='   360.  360.  180.   15.'
# time_i='   360.  360.   90.   15.'

  spec_p='   1.03 0.075 20 24 0.'
# spec_p='   1.03 0.075 20 48 0.'
  time_p='   720.  720.  720.   15.'

cat > buoy.inner << EOF
    -100.E3    50.E3  'A1        '
    -100.E3     0.E3  'A2        '
    -100.E3   -50.E3  'A3        '
       0.E3   100.E3  'B1        '
       0.E3    50.E3  'B2        '
       0.E3     0.E3  'B3        '
       0.E3   -50.E3  'B4        '
       0.E3  -100.E3  'B5        '
     100.E3    50.E3  'C1        '
     100.E3     0.E3  'C2        '
     100.E3   -50.E3  'C3        '
EOF

cat > buoy.outer << EOF
    -270.E3     0.E3  'IN        '
     300.E3     0.E3  'OUT       '
     200.E3   200.E3  'D1        '
     200.E3   150.E3  'D2        '
     200.E3   100.E3  'D3        '
     200.E3    50.E3  'D4        '
     200.E3     0.E3  'D5        '
     200.E3   -50.E3  'D6        '
     200.E3  -100.E3  'D7        '
     200.E3  -150.E3  'D8        '
     200.E3  -200.E3  'D9        '
EOF

  nr_bi=`wc -l buoy.inner | awk '{print $1}'`
  nr_bo=`wc -l buoy.outer | awk '{print $1}'`

  if [ "$mode" = 'single' ]
  then
    uni_pts='no'
  fi

  if [ "$uni_pt" = 'yes' ]
  then
    FLAGUP='T'
    COMMUP=' '
    points='points'
  else
    FLAGUP='F'
    COMMUP='$'
    points=
  fi

# zeus MPIT settings

  MPI_BUFS_PER_PROC=128
  MPI_BUFS_PER_HOST=128
  MPI_GROUP_MAX=128

# 0.a Set-up variables

  path_h=`pwd`

  cd
  if [ -f $ww3_env ]
  then
    set `grep WWATCH3_DIR $ww3_env` ; shift
    main_dir="$*"
    set `grep WWATCH3_TMP $ww3_env` ; shift
    temp_dir="$*"
  else
    echo "*** Set-up file $ww3_env not found ***"
    exit
  fi

  path_w="$temp_dir"              # work directory
  path_e="$main_dir/exe"          # path for executables
  path_a="$main_dir/aux"          # path for aux files and scripts
  path_o="$main_dir/test"         # path for output files
  path_o="$main_dir/work"

# 0.b Clean-up

  mv $path_h/buoy.outer $path_w/.
  mv $path_h/buoy.inner $path_w/.

  cd $path_w

  cat buoy.inner buoy.outer | sed -e 's/\.E3//g' -e "s/'//g" > $path_o/buoy.all

  echo ' ' ; echo ' '
  echo '                  ======> TEST RUN WAVEWATCH III <====== '
  echo '                    ==================================   '
  echo '                        test static nesting (propagation)'
  echo ' '

# 1. Grid pre-processor -----------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '|  Grid preprocessor |'
  echo '+--------------------+'
  echo ' '

  rm -f mod_def.*

  echo "   Generate data for inner grid ..."

  if [ "$shoal" = 'yes' ]
  then
    SHOAL='.TRUE.'
  else
    SHOAL='.FALSE.'
  fi

  if [ "$circ" = 'yes' ]
  then
    CIRC='.TRUE.'
  else
    CIRC='.FALSE.'
  fi
  
  if [ "$curr" = 'yes' ]
  then
    CURR="'native'"
    CURF='T'
  else
    CURR="'no'"
    CURF='F'
  fi

cat > grid.f << EOF
      program grid
c
      real depth(51,51)
      integer mask(51,51)
      logical shoal, circ
c
      shoal  = $SHOAL
      circ   = $CIRC
      dx     = 5.
      dmin   = $dmin
      bdepth = 0.025
      r_max  = 25.5 * dx
c
      do ix=1, 51
        do iy=1, 51
          radius = real(ix-26)**2 + (iy-26)**2
          radius = dx * sqrt(radius)
          if ( .not . shoal ) then
              depth(ix,iy) = -250.
            else
              depth(ix,iy) = - min( 250., dmin+radius**2*bdepth )
            endif
          if ( .not . circ ) then
              mask(ix,iy) = 1
            else
              if ( radius .gt. r_max ) then
                  mask(ix,iy) = 3
                else
                  mask(ix,iy) = 1
                end if
            endif
          if ( ix.eq.1 .or. iy.eq.1 .or. ix.eq.51 .or. iy.eq.51. ) then
              if ( mask(ix,iy) .eq. 1 ) mask(ix,iy) = 2
            end if
          end do
        end do
c
      if ( circ ) then
          do ix=2, 50
            do iy=2, 50
              if ( mask(ix,iy) .eq. 1 .and.
     &           ( mask(ix-1,iy  ).eq.3 .or. mask(ix+1,iy  ).eq.3 .or.
     &             mask(ix  ,iy-1).eq.3 .or. mask(ix  ,iy+1).eq.3 ) )
     &             mask(ix,iy) = 2
              end do
            end do
        end if
c
      open (21, file='depth.data')
      do iy=1,51
        write (21,'(12f8.1)') (depth(ix,iy),ix=1,51)
        end do
      close (21)
c
      open (21, file='mask.data')
      do iy=1,51
        write (21,'(30i3)') (mask(ix,iy),ix=1,51)
        end do
      close (21)
c
      open (21, file='boundary.data')
      do ix=1,51
        do iy=1,51
          x      = -130. + real(ix)*5.
          y      = -130. + real(iy)*5.
          if ( mask(ix,iy).eq.2 ) write (21,900) x, y, 1
          end do
        end do
      write (21,900) 0., 0., 0
      close (21)
c
  900 format (3x,2(f6.0,'E3'),'   1.E3   1.E3  ',i3)
c
      end 
EOF

  $f77 grid.f

  ./a.out

  rm -f grid.f a.out

  echo "   Generate ww3_grid.inp for all grids ..."

cat > ww3_grid.bound.inp << EOF
$ WAVEWATCH III Grid preprocessor input file
$ ------------------------------------------
  'The Boundary data grid        '
$
$spec_o
$
   F T F F F F
$time_o
$
$PRO2
$PRO3
$
END OF NAMELISTS
$
   'RECT' F 'NONE'
   55   57
    10.E3   10.E3   1.
  -270.E3 -280.E3   1.
$
  -0.1 0.25  10  -250. 4 1 '(....)' 'UNIT' 'input'
$
  3135*1
$
   10 1 1 '(....)' 'PART' 'mapsta.inp'
$
   1  2  T
   1 56  T
   0  0  F
$
   2  3  T
  55  3  T
  55 55  T
   2 55  T
   0  0  F
$
  28 28
   0  0
$
   -270.E3  -260.E3    0.E3   10.E3   53
   -270.E3  -270.E3   10.E3    0.E3   54
   -270.E3   270.E3   10.E3    0.E3   54
      0.       0.      0.      0.      0
$
EOF

cat > ww3_grid.outer.inp << EOF
$ WAVEWATCH III Grid preprocessor input file
$ ------------------------------------------
  'The outer grid @ 10 km        '
$
$spec_o
$
   F T T T F F
$time_o
$
$PRO2
$PRO3
END OF NAMELISTS
$
   'RECT' F 'NONE'
   55   55
    10.E3   10.E3   1.
  -270.E3 -270.E3   1.
$
  -0.1 0.25  10  -250. 4 1 '(....)' 'UNIT' 'input'
$
  3192*1
$
   10 1 1 '(....)' 'PART' 'mapsta.inp'
$
  54  1  T
   1  1  T
   1 55  T
  54 55  T
   0  0  F
   0  0  F
   0  0
$
EOF

  cat boundary.data >> ww3_grid.outer.inp
  echo '$'          >> ww3_grid.outer.inp 
  rm -f boundary.data

cat > ww3_grid.inner.inp << EOF
$ WAVEWATCH III Grid preprocessor input file
$ ------------------------------------------
  'The inner grid @  5 km        '
$
$spec_i
$
   F T T T $CURF F
$time_i
$
$PRO2
$PRO3
END OF NAMELISTS
$
   'RECT' F 'NONE'
   51   51
     5.E3    5.E3   1.
  -125.E3 -125.E3   1.
$
  -0.1 0.25  21  1. 3 1 '(....)' 'NAME' 'depth.data'
$
   22 3 1 '(....)' 'NAME' 'mask.data'
$
   0. 0. 0. 0. 0
$
EOF

# Here follows the grid for point output. Only the spectral info is used,
# the rest are dummy data

cat > ww3_grid.points.inp << EOF
$ WAVEWATCH III Grid preprocessor input file
$ ------------------------------------------
  'Point output mww3_test_04     '
$
$spec_p
$
   F T T T T F
$time_p
$
END OF NAMELISTS
$
    'RECT' F 'NONE'
    3    3
     5.E3    5.E3   1.
    -5.E3   -5.E3   1.
$
  -0.1 0.25  10  -100. 3 1 '(....)' 'UNIT' 'dummy'
$
   1 1 1
   1 1 1
   1 1 1
$
   10 3 1 '(....)' 'PART' 'dummy' 
   0   0   F
   0   0   F
   0   0
$
   0. 0. 0. 0. 0
$
EOF

  echo ' '

  for mod in bound outer inner $points
  do
    mv ww3_grid.$mod.inp ww3_grid.inp
    echo "   Screen ouput routed to $path_o/ww3_grid.$mod.out"

    $path_e/ww3_grid > $path_o/ww3_grid.$mod.out

    rm -f ww3_grid.inp mapsta.ww3 mask.ww3
    mv mod_def.ww3 mod_def.$mod
  done

  rm -f ww3_grid.*.inp

# 2. Initial conditions -----------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '| Initial conditions |'
  echo '+--------------------+'
  echo ' '

cat > ww3_strt.inp << EOF
$ WAVEWATCH III Initial conditions input file
$ -------------------------------------------
  1
$  0.10 0.0025  270. 20 -270.E3 30.E3 0.E3 999.E6  2.50
$  0.10 0.0025  270. 15 -270.E3 30.E3 0.E3 999.E6  2.50
   0.10 0.0025  270. 10 -270.E3 90.E3 0.E3 999.E6  2.50
$  0.10 0.0025  270.  5 -270.E3 30.E3 0.E3 999.E6  2.50
EOF

  for grid in bound outer inner
  do
    rm -f mod_def.ww3
    ln -s mod_def.$grid mod_def.ww3
    echo "   Screen ouput routed to $path_o/ww3_strt.$grid.out"
    $path_e/ww3_strt > $path_o/ww3_strt.$grid.out
    mv restart.ww3 restart.$grid
  done

  rm -f ww3_strt.inp mod_def.ww3 mask.data depth.data
  

# 3. Input fields -----------------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '| Input data         |'
  echo '+--------------------+'
  echo ' '

  if [ "$curr" != 'yes' ]
  then
    echo '   Not needed for present test.'
  else
    echo '   Generating input current field ...'

cat > current.f << EOF
      program current
c
      real ux(51,51), uy(51,51)
c
      dx     = 5.
      Rmax   = $Rmax
      Umax   = $Umax
c
      do ix=1, 51
        do iy=1, 51
          rx     = real(ix-26) * dx
          ry     = real(iy-26) * dx
          radius = sqrt ( rx**2 + ry**2 )
          if ( radius .lt. 0.5*dx ) then
              ux(ix,iy) = 0.
              uy(ix,iy) = 0.
            else
              curr = Umax * ( 1. - (radius/Rmax-1.)**2 )
              curr = max ( curr , 0. )
              ux(ix,iy) = - ry * curr / radius
              uy(ix,iy) =   rx * curr / radius
            end if
          end do
        end do
c
      open (21, file='current.data')
      write (21,'(i10.8,i7.6)') 19680606, 0
      do iy=1,51
        write (21,'(12f8.3)') (ux(ix,iy),ix=1,51)
        end do
      do iy=1,51
        write (21,'(12f8.3)') (uy(ix,iy),ix=1,51)
        end do
      close (21)
c
      end 
EOF

  $f77 current.f

  ./a.out

cat > ww3_prep.inp << EOF
$ WAVEWATCH III Field preprocessor input file
$ -------------------------------------------
   'CUR' 'AI' T T
$
  'NAME' 1 1 '(..T..)' '(..F..)' 
  20 'current.data'
EOF

    ln -s mod_def.inner mod_def.ww3

    echo ' '
    echo "   Screen ouput routed to $path_o/ww3_prep.inner.out"
    $path_e/ww3_prep > $path_o/ww3_prep.inner.out

    rm -f current.f a.out f ww3_prep.inp mask.ww3 current.data mod_def.ww3
    mv current.ww3 current.inner
  
  fi

# 4. Main program -----------------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '|    Main program    |'
  echo '+--------------------+'
  echo ' '

  if [ "$mode" = 'multi' ]
  then
    echo '   Running in multi-scale mode.'

cat > ww3_multi.inp << EOF
$ WAVEWATCH III multi-scale input file
$ ------------------------------------
  3 0 $FLAGUP 1 T T
$
$COMMUP 'points'
$
  'bound'  'no' 'no' 'no' 'no' 'no' 'no' 'no'  1  1  0.00 1.00  F"
  'outer'  'no' 'no' 'no' 'no' 'no' 'no' 'no'  2  1  0.00 1.00  F
  'inner'  'no' $CURR 'no' 'no' 'no' 'no' 'no'  3  1  0.00 1.00  F"
$ 'bound'  'no' 'no' 'no' 'no' 'no' 'no' 'no'  1  1  0.00 0.15  F"
$ 'outer'  'no' 'no' 'no' 'no' 'no' 'no' 'no'  2  1  0.15 0.50  F
$ 'inner'  'no' $CURR 'no' 'no' 'no' 'no' 'no'  3  1  0.50 1.00  F"
$
   19680606 000000   $t_end
$
     T F
$
   19680606 000000   1200  19680608 000000
     T T T T T  T T T T T  T T T T T  T T T T T  T T T T T  T T T T T  T
EOF

if [ "$uni_pt" = 'yes' ]
then

cat >> ww3_multi.inp << EOF
   19680606 000000   3600  19680608 000000
EOF

  cat buoy.inner >> ww3_multi.inp
  cat buoy.outer >> ww3_multi.inp
  nr_i=$nr_bi
  nr_o=$nr_bo
  nr_p=`expr $nr_bi + $nr_bo`
cat >> ww3_multi.inp << EOF
       0.E3     0.E3  'STOPSTRING'
$
   19680606 000000      0  19680608 000000
   19680606 011200      0  19680606 011200
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
EOF

else
cat >> ww3_multi.inp << EOF
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
   19680606 011200      0  19680606 011200
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
$
  'inner'  2
   19680606 000000   3600  19680608 000000
EOF
  cat buoy.inner >> ww3_multi.inp
  nr_i=$nr_bi
cat >> ww3_multi.inp << EOF
       0.E3     0.E3  'STOPSTRING'
$
  'outer'  2
   19680606 000000   3600  19680608 000000
EOF
# cat buoy.inner >> ww3_multi.inp
  cat buoy.outer >> ww3_multi.inp
  nr_o=`expr $nr_bi + $nr_bo`
  nr_o=$nr_bo
cat >> ww3_multi.inp << EOF
       0.E3     0.E3  'STOPSTRING'
EOF

fi

cat >> ww3_multi.inp << EOF
$
  'the_end'  0
$
  'STP'
$
$ End of input file
EOF

    echo "   Running multi-scale model ..."
#   echo "   Screen output routed to $path_o/ww3_multi.out"

    if [ "$MPI" = 'yes' ]
    then
      mpiexec_mpt -np $PBS_NP $path_e/ww3_multi # > $path_o/ww3_multi.out
#     mpirun -np $proc $path_e/ww3_multi # > $path_o/ww3_multi.out
#     poe $path_e/ww3_multi # > $path_o/ww3_multi.out
    else
      $path_e/ww3_multi # > $path_o/ww3_multi.out
    fi

    echo "   Log files routed to $path_o"
    mv log.* $path_o/.

    rm -f ww3_shel.inp
    rm -f ww3_multi.inp

#   rm -f test*.mww3

    set +e
    nr_test=`ls test* 2> /dev/null | wc -w | awk '{ print $1}'`
    if [ "$nr_test" != '0' ]
    then
      for file in `ls test* 2> /dev/null`
      do
        size=`wc -w $file | awk '{print $1}'`
        if [ "$size" = 0 ] ; then
          rm -f $file ; fi
      done
    fi

    nr_test=`ls test* 2> /dev/null | wc -w | awk '{ print $1}'`
    if [ "$nr_test" != '0' ]
    then
      echo "   Output file test[nnn].[m]ww3 routed to $path_o"
      mv test* $path_o/.
    fi

    nr_prof=`ls prf*.mww3 2> /dev/null | wc -w | awk '{ print $1}'`
    if [ "$nr_prof" != '0' ]
    then
      echo "   Profiling file prf.*.mww3 routed to $path_o"
      mv prf*.mww3 $path_o/. 2> /dev/null
    fi

    nr_part=`ls partition.* 2> /dev/null | wc -w | awk '{ print $1}'`
    if [ "$nr_part" != '0' ]
    then
      echo "   Partition file partition.* routed to $path_o"
      mv partition.* $path_o/. 2> /dev/null
    fi

    rm -f prf*.mww3
    set -e

  else
    echo '   Running in one-way nested mode mode.'

cat > ww3_shel.bound.inp << EOF
$ WAVEWATCH III shell input file
$ ------------------------------
   F T
   F T
   F T
   F
   F
   F
   F
$
   19680606 000000
   $t_end
$
   1
$
   19680606 000000   3600  19680608 000000
     T T T T T  T T T T T  T T T T T  T T T T T  T T T T T  T T T T T  T
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
$
   'STP'
$
$ End of input file
EOF

cat > ww3_shel.outer.inp << EOF
$ WAVEWATCH III shell input file
$ ------------------------------
   F T
   F T
   F T
   F
   F
   F
   F
$
   19680606 000000
   $t_end
$
   1
$
   19680606 000000   3600  19680608 000000
     T T T T T  T T T T T  T T T T T  T T T T T  T T T T T  T T T T T  T
   19680606 000000   3600  19680608 000000
EOF
cat buoy.inner >> ww3_shel.outer.inp
cat buoy.outer >> ww3_shel.outer.inp
cat >> ww3_shel.outer.inp << EOF
       0.E3     0.E3  'STOPSTRING'
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
$
   'STP'
$
$ End of input file
EOF

cat > ww3_shel.inner.inp << EOF
$ WAVEWATCH III shell input file
$ ------------------------------
   F F
   $CURF F
   F F
   F
   F
   F
   F
$
   19680606 000000
   $t_end
$
   1
$
   19680606 000000   1200  19680608 000000
     T T T T T  T T T T T  T T T T T  T T T T T  T T T T T  T T T T T  T
   19680606 000000   3600  19680608 000000
EOF
cat buoy.inner >> ww3_shel.inner.inp
cat >> ww3_shel.inner.inp << EOF
       0.E3     0.E3  'STOPSTRING'
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
   19680606 000000      0  19680608 000000
$
   'STP'
$
$ End of input file
EOF

    for mod in bound outer inner
    do
      echo ' '
      echo "   Running model $mod ..."

      mv ww3_shel.$mod.inp ww3_shel.inp
      rm -f mod_def.ww3 restart.ww3
      ln -s mod_def.$mod mod_def.ww3
      ln -s restart.$mod restart.ww3
      if [ -f current.$mod ] ;  then
            ln -s current.$mod current.ww3 ; fi
      echo "   Screen ouput routed to $path_o/ww3_shel.$mod.out"

      if [ "$MPI" = 'yes' ]
      then
        mpiexec_mpt -np $PBS_NP $path_e/ww3_shel > $path_o/ww3_shel.$mod.out
#       mpirun -np $proc $path_e/ww3_shel > $path_o/ww3_shel.$mod.out
#       poe $path_e/ww3_shel > $path_o/ww3_shel.$mod.out
      else
        $path_e/ww3_shel > $path_o/ww3_shel.$mod.out
      fi

      echo "   Log and output files renamed to xxx.$mod"
      mv log.ww3 $path_o/log.$mod
      mv out_grd.ww3 out_grd.$mod
      rm -f mod_def.ww3 restart.ww3 ww3_shel.inp current.ww3
      rm -f test*.ww3
      if [ -f partition.ww3 ] ;  then
            mv partition.ww3 partition.$mod ; fi
      if [ -f out_pnt.ww3 ] ;  then
            mv out_pnt.ww3 out_pnt.$mod ; fi
      if [ -f nest1.ww3 ] ;  then
            mv nest1.ww3 nest.ww3 ; fi

    done

    nr_part=`ls partition.* 2> /dev/null | wc -w | awk '{ print $1}'`
    if [ "$nr_part" != '0' ]
    then
      echo "   Partition file partition.* routed to $path_o"
      mv partition.* $path_o/. 2> /dev/null
    fi

  fi

  rm -f nest.* current.* restart.* buoy.inner buoy.outer

# exit 99

# 4. Gridded output ---------------------------------------------------------

  echo ' '
  echo '+--------------------+'
  echo '|   Gridded output   |'
  echo '+--------------------+'
  echo ' '

cat > gx_outf.inp << EOF
$ WAVEWATCH III Grid output post-processing
$ -----------------------------------------
  19680606 000000  1200. $tn
$
  T T F F F  T F F F F  T T F F T  T F T F F  F T F F F  F F F F F  F
$
  0 999 0 999  T F
$
$ End of input file
EOF

  for mod in bound outer inner
  do
    echo "   GrADS data for $mod ..."
    echo "      Screen ouput routed to $path_o/gx_outf.$mod.out"
    ln -s mod_def.$mod mod_def.ww3
    ln -s out_grd.$mod out_grd.ww3

    $path_e/gx_outf > $path_o/gx_outf.$mod.out

    echo "      ww3.ctl routed to $path_o/$mod.ctl"
    sed -e "s/ww3\.grads/ww3\.$mod/g" \
        -e "s/0\.25/2\.50/g" ww3.ctl > $path_o/$mod.ctl
    rm -f ww3.ctl
    echo "      ww3.grads routed to $path_o/ww3.$mod"
    mv ww3.grads $path_o/ww3.$mod

    rm -f mod_def.ww3 out_grd.ww3

  done

  rm -f gx_outf.inp out_grd.*

  echo ' '
  echo "   Plotting script put in $path_o/map.gs_tmpl"

cat > $path_o/map.gs_tmpl << EOF
*
* map.gs  : Imbedded GrADS script for test cases
* ----------------------------------------------------------------
*           Scripts used :
*              colorset.gs : Sets up shading colors
*
* General set up

  t1 =  1
  tn = $tn
  ts =  1

  plot_map = 'yes'
  plot_act = 'yes'
  plot_msk = 'yes'
  plot_hs  = 'yes' ; hs_type = -1
  plot_con = 'yes'
  plot_dir = 'no '
  plot_dpt = 'no '
  plot_cur = 'no '
  plot_bys = 'no '
  plot_lab = 'yes'
  pan = '(a)'

  if ( hs_type = -1 )
    hspar = 'hs'
  endif
  if ( hs_type = 0 )
    hspar = 'phs00'
  endif
  if ( hs_type = 1 )
    hspar = 'phs01'
  endif
  if ( hs_type = 2 )
    hspar = 'phs02'
  endif

  plot_1 = 'yes'
  plot_2 = 'yes'
  plot_3 = 'yes'

  xpl = 1.0
  xph = 7.5
  ypl = 2.5
  yph = 9.0

  xml = -250
  xmh =  250
  yml = -250
  ymh =  250

* xml = -290
* xmh =  290
* yml = -290
* ymh =  290

* clevs = '0.70 1.10 1.50 1.90 2.30 2.70 3.10 3.50 3.90 4.30 4.70'
  clevs = '1.60 1.80 2.00 2.20 2.40 2.60 2.80 3.00 3.20 3.40 3.60'
* clevs = '2.05 2.15 2.25 2.35 2.45 2.55 2.65 2.75 2.85 2.95 3.05'
  ccols = '21 23  24  26  27  29  30  32  33  35  36  38'
  
  if ( plot_act = 'yes' )
    col_act = 69
  else
    col_act = 70
  endif
  
  if ( plot_msk = 'yes' )
    col_msk = 71
  else
    col_msk = 70
  endif

  strsiz = ( xph - xpl ) * 0.03

  pdx = ( xph - xpl ) * 0.005
  strsiz2 = ( xph - xpl ) * 0.02

  'set display color white'
  'run colorset.gs'

  gdate="yyyy/mm/dd"
  '!date -u "+%Y/%m/%d" > tmp_grads_gdate'
  result = read (tmp_grads_gdate)
  gdate = sublin(result,2)
  '!rm -f tmp_grads_gdate'

* Set buoy data from buoy.data

  '!cat buoy.all | wc -l > tmp_grads_nbuoys'
  result = read (tmp_grads_nbuoys)
  line   = sublin(result,2)
  nr     = subwrd(line,1)
  '!rm -f tmp_grads_nbuoys'

  i = 1
  while ( i <= nr )
    result = read (buoy.all)
    line   = sublin(result,2)
    x.i = subwrd(line,1)
    y.i = subwrd(line,2)
    s.i = subwrd(line,3)
    i = i + 1
  endwhile

* ID output to screen

  say ' '
  say '----------------------'
  say '*** Running map.gs ***'
  say '----------------------'
  say ' ' 
  say 'Number of ouptput points : ' nr
  say 'Time steps from ' t1 ' through ' tn ' with step ' ts

* Loop over time steps

  'open bound'
  'open outer'
  'open inner'

  i = 1
  t = t1

  '!rm -f plot.grads.*'

  while ( t <= tn )
    'set t ' t

    'query time'
    gradsdate = subwrd(result,3)
    test = substr ( gradsdate, 3, 1 )
    if ( test='Z' )
      year = substr ( gradsdate, 9, 4 )
      mnth = substr ( gradsdate, 6, 3 )
      day  = substr ( gradsdate, 4, 2 )
      hour = substr ( gradsdate, 1, 2 )
      min  = '00'
    else
      year = substr ( gradsdate, 12, 4 )
        mnth = substr ( gradsdate, 9, 3 )
      day  = substr ( gradsdate, 7, 2 )
      hour = substr ( gradsdate, 1, 2 )
      min  = substr ( gradsdate, 4, 2 )
    endif

    month= '??'
    if (mnth='JAN'); month= '01'; endif;
    if (mnth='FEB'); month= '02'; endif;
    if (mnth='MAR'); month= '03'; endif;
    if (mnth='APR'); month= '04'; endif;
    if (mnth='MAY'); month= '05'; endif;
    if (mnth='JUN'); month= '06'; endif;
    if (mnth='JUL'); month= '07'; endif;
    if (mnth='AUG'); month= '08'; endif;
    if (mnth='SEP'); month= '09'; endif;
    if (mnth='OCT'); month= '10'; endif;
    if (mnth='NOV'); month= '11'; endif;
    if (mnth='DEC'); month= '12'; endif;

*   vdate = year '/' month '/' day ' ' hour ':' min 'z'
*   vdate = pan ' ' hour ':' min 'z'
    vdate = hour ':' min 'z'

    say '   processing time step ' t ', time is ' vdate

* Basic plot set up

    'enable print plot.grads.' t
    'clear'
    'set grads off'
    'set lon ' xml / 10 ' ' xmh / 10
    'set lat ' yml / 10 ' ' ymh / 10
    'set xlint 10'
    'set ylint 10'
    'set xlab %.0f0'
    'set ylab %.0f0'
    'set grid on 3 60'
    'set mpdraw off'

    'set parea ' xpl ' ' xph ' ' ypl ' ' yph
    'set mproj scaled'
    
    if ( plot_map = 'yes' )
      'set line 70'
      'draw recf 1. 2.5 7.5 9.'
      'draw recf ' xpl ' ' ypl ' ' xph ' ' yph
    endif

* Plot bound grid -------------------------------------------------------- *

    if ( plot_1 = 'yes' )

* Plot map

      if ( plot_map = 'yes' )
        'set gxout grfill'
        'set clevs -4.5 -3.5 -2.5 -1.5 -0.5  0.5 1.5'
        'set ccols 60  ' col_msk '  67   68   63   62   0  ' col_act
        'd map.1'
      endif

    endif

* Plot outer grid -------------------------------------------------------- *

    if ( plot_2 = 'yes' )

* Plot map

      if ( plot_map = 'yes' )
        'set gxout grfill'
        'set clevs -4.5 -3.5 -2.5 -1.5 -0.5  0.5 1.5'
        'set ccols 60  ' col_msk '  67   68   63   62   0  ' col_act
        'd map.2'
      endif

* Plot Hs

      if ( plot_hs = 'yes' )
        'set gxout $grtype'
        'set clevs ' clevs
        'set ccols ' ccols
        'd ' hspar '.2'
  
        if ( plot_con = 'yes' )
          'set gxout contour'
          'set cthick 1'
          'set ccolor 60'
          'set clevs ' clevs
          'set clab off'
          'd ' hspar '.2'
        endif

      endif

* Plot directions

      if ( plot_dir = 'yes' )
        'set gxout vector'
        'set cthick 3'
        'set arrscl 0.25'
        'set arrlab off'
        'set ccolor 1'
        'd skip(cos(PEAKD.2),4);skip(sin(PEAKD.2),4)'
      endif

    endif

* Plot inner grid -------------------------------------------------------- *

    if ( plot_3 = 'yes' )

* Plot map

      if ( plot_map = 'yes' )
        'set gxout grfill'
        'set clevs -4.5 -3.5 -2.5 -1.5 -0.5  0.5 1.5'
        'set ccols 60  ' col_msk '  67   68   63   62   0  ' col_act
        'd map.3'
      endif

* Plot Hs

      if ( plot_hs = 'yes' )
        'set gxout $grtype'
        'set clevs ' clevs
        'set ccols ' ccols
        'd ' hspar '.3'
  
        if ( plot_con = 'yes' )
          'set gxout contour'
          'set cthick 1'
          'set ccolor 60'
          'set clevs ' clevs
          'set clab off'
          'd ' hspar '.3'
        endif

      endif

* Plot directions

      if ( plot_dir = 'yes' )
        'set gxout vector'
        'set cthick 3'
        'set arrscl 0.125'
        'set arrlab off'
        'set ccolor 1'
        'd skip(cos(PEAKD.3),4);skip(sin(PEAKD.3),4)'
      endif

* Plot depth

      if ( plot_dpt = 'yes' )
        'set gxout contour'
        'set cthick 1'
        'set ccolor 60'
        'set clevs 25 50 100 150 225'
        'set clab off'
        'd depth.3'
      endif

* Plot current

      if ( plot_cur = 'yes' )
        'set gxout vector'
        'set cthick 3'
        'set arrscl 0.25 1.0'
        'set arrlab off'
        'set ccolor 4'
        'd skip(cx.3,4);skip(cy.3,4)'
      endif

    endif

* Plot output locations -------------------------------------------------- *

    'set strsiz ' strsiz2

    if ( plot_bys = 'yes' )
      j = 1
      while ( j <= nr )
        xb = xpl + ( xph - xpl ) * ( x.j - xml ) / ( xmh - xml )
        yb = ypl + ( yph - ypl ) * ( y.j - yml ) / ( ymh - yml )
        'set line 1'
        'draw recf ' xb-pdx ' ' yb-pdx ' ' xb+pdx ' ' yb+pdx
        'set string 1 l'
        'draw string ' xb + 0.05*strsiz2 ' ' yb + 0.8*strsiz2 ' ' s.j
        j = j + 1
      endwhile
    endif
 
* Panel and date marker

    if ( plot_lab = 'yes' )
      'set string 1 c'
      'set strsiz ' strsiz
*     'draw string 1.3 8.55 ' pan
*     'draw string 1.6 8.45 ' pan
      'draw string 2.3 8.55 ' vdate
    endif
 
* Finalize

    'print'
    'disable print'
    pull OK
    t = t + ts
    i = i + 1
  endwhile

* End of loop over time steps

  say ' '
  say '----------------------'
  say '*** End of map.gs  ***'
  say '----------------------'
  say ' ' 

  'quit'

* end of map.gs
EOF

  echo ' '

# 5. Point output -----------------------------------------------------------
   
  echo ' '
  echo '+--------------------+'
  echo '|    Point output    |'
  echo '+--------------------+'
  echo ' '

cat > gx_outp.inp_tmpl << EOF
$ WAVEWATCH III Point output post-processing
$ ------------------------------------------
  19680606 000000  3600. $tn
$ 
POINTS
 -1
$
  T F F F F F 
$ 
$ End of input file
EOF

cat > ww3_outp.inp_tmpl << EOF
$ WAVEWATCH III Point output post-processing
$ ------------------------------------------
  $t_end 000000  3600. 1
$ 
POINTS
 -1
$
  2
  2  50
$ 
$ End of input file
EOF

  out_mods=`ls out_pnt.* | sed 's/out\_pnt\.//g'`

  for mod in $out_mods
  do
    case $mod in
      'inner' ) nr=$nr_i ;;
      'outer' ) nr=$nr_o ;;
      'points') nr=$nr_p ;;
         *    ) nr=0     ;;
    esac
    
    i=1
    rm -f tmpfile
    
    while [ "$i" -le "$nr" ]
    do
      echo "$i" >> tmpfile
      i=`expr $i + 1`
    done

    sed -e "/POINTS/r tmpfile" \
        -e "s/POINTS/\$/g" gx_outp.inp_tmpl  > gx_outp.inp
    sed -e "/POINTS/r tmpfile" \
        -e "s/POINTS/\$/g" ww3_outp.inp_tmpl  > ww3_outp.inp
    rm -f tmpfile
    
    ln -s mod_def.$mod mod_def.ww3
    ln -s out_pnt.$mod out_pnt.ww3

    echo "   GrADS point output for $mod ..."
    echo "      Screen ouput routed to $path_o/gx_outp.$mod.out"

    $path_e/gx_outp > $path_o/gx_outp.$mod.out

    if [ "$mod" = 'points' ]
    then
      echo "      ww3.spec.ctl routed to $path_o"
      mv ww3.spec.ctl $path_o/.
      echo "      ww3.spec.grads routed to $path_o"
      mv ww3.spec.grads $path_o/.
      echo "      ww3.mean.grads routed to $path_o"
      mv ww3.mean.grads $path_o/.
    else
      echo "      ww3.spec.ctl routed to $path_o/$mod.spec.ctl"
      sed -e "s/ww3\.spec\.grads/ww3\.spec\.$mod/g" \
	                               ww3.spec.ctl > $path_o/$mod.spec.ctl
      rm -f ww3.spec.ctl
      echo "      ww3.spec.grads routed to $path_o/ww3.spec.$mod"
      mv ww3.spec.grads $path_o/ww3.spec.$mod
      echo "      ww3.mean.grads routed to $path_o/ww3.mean.$mod"
      mv ww3.mean.grads $path_o/ww3.mean.$mod
    fi

#   echo "   Tabular point output for $mod ..."
#   echo "      Screen ouput routed to $path_o/ww3_outp.$mod.out"

#   $path_e/ww3_outp > $path_o/ww3_outp.$mod.out
  
#   echo "      tab50.ww3 routed to $path_o/tab50.$mod"
#   mv tab50.ww3 $path_o/tab50.$mod

    rm -f mod_def.ww3 out_pnt.ww3 gx_outp.inp ww3_outp.inp
  done

  echo ' '
  echo "   Use spec.gs for plotting unified point output"
  echo "   Plotting script put in $path_o/spec04.gs_tmpl"
  echo "       (use for comparing outer and inner data)."

cat > $path_o/spec04.gs_tmpl << EOF
*
* spec04.gs    : Imbedded GrADS plots of wave spectra
* ----------------------------------------------------------------
*                Based on spec.gs
*
* General set up - - - - - - - - - - - - - - - - - - - - - - - - -
*
  display=white
*
* color : color or b&w   [yes/---]
*
  color = 'yes'
*
    dth = 15
    dfr =  0.025
    fmx =  0.15
*
  'enable print plot.grads'
  'set display color ' display
  'clear'
*
  'set rgb 41   0   0 255'
  'set rgb 42   0 102 255'
  'set rgb 43   0 153 255'
  'set rgb 44   0 204 255'
  'set rgb 45   0 255 255'
  'set rgb 46 153 255 255'
  'set rgb 47 204 255 255'
  'set rgb 48 255 255 255'
  'set rgb 58 255 255 255'
  'set rgb 57 255 255 204'
  'set rgb 56 255 255 153'
  'set rgb 55 255 255   0'
  'set rgb 54 255 204   0'
  'set rgb 53 255 153   0'
  'set rgb 52 255 102   0'
  'set rgb 51 255   0   0'
*
  'set rgb 63 204 204 204'
  'set rgb 64   0   0 255'
  'set rgb 65 255   0   0'
  'set rgb 66 204 204 204'
*
  gdate="yyyy/mm/dd"
  '!date -u "+%Y/%m/%d" > tmp_grads_gdate'
  result = read (tmp_grads_gdate)
  gdate = sublin(result,2)
  '!rm -f tmp_grads_gdate'
*
  'q gxinfo'
  line = sublin(result,2)
  xmax = subwrd(line,4)
  ymax = subwrd(line,6)
*
  say ' '
  say '-------------------------'
  say '*** Running spec04.gs ***'
  say '-------------------------'
  say ' '
*
* Open data files  - - - - - - - - - - - - - - - - - - - - - - - -
* outer grid
*
  'open outer.spec'
*
  fmin = 1.e20
  fmax = -1.e20
*
  'set gxout stat'
  'set lev 1'
*
  'q file 1'
  line = sublin(result,5)
  ntime.1 = subwrd(line,12)
  line = sublin(result,6)
  nloc.1 = subwrd(line,5)
*
  say ' '
  say 'Data for outer grid :'
  say '---------------------'
  say 'Nr. of times : ' ntime.1
  say 'Nr. of loc.  : ' nloc.1
*
  iloc = 1
  while ( iloc <= nloc.1 )
    iline = 6 + iloc
    line = sublin(result,iline)
    par_ID.1.iloc = subwrd(line,1)
    loc_ID.1.iloc = substr(line,17,10)
    say '   location ' iloc ' is called ' loc_ID.1.iloc ' and stored as ' par_ID.1.iloc
    iloc = iloc + 1
  endwhile
*
  itime = 1
  while ( itime <= ntime.1 )
    'set t ' itime
    iloc = 1
    while ( iloc <= nloc.1 )
      result = read (ww3.mean.outer)
      line = sublin(result,2)
      ua.iloc.itime.1 = subwrd(line,5)
      ux.iloc.itime.1 = subwrd(line,6)
      uy.iloc.itime.1 = subwrd(line,7)
      ca.iloc.itime.1 = subwrd(line,9)
      cx.iloc.itime.1 = subwrd(line,10)
      cy.iloc.itime.1 = subwrd(line,11)
      hs.iloc.itime.1 = subwrd(line,12)
      'd ' par_ID.1.iloc
      line = sublin(result,8)
      lmin = subwrd(line,4)
      lmax = subwrd(line,5)
      if ( lmin < fmin) ; fmin = lmin ; endif
      if ( lmax > fmax) ; fmax = lmax ; endif
      iloc = iloc + 1
    endwhile
  itime = itime + 1
  endwhile
*
* inner grid
*
  'open inner.spec'
*
  'q file 2'
  line = sublin(result,5)
  ntime.2 = subwrd(line,12)
  line = sublin(result,6)
  nloc.2 = subwrd(line,5)
*
  say ' '
  say 'Data for inner grid :'
  say '---------------------'
  say 'Nr. of times : ' ntime.2
  say 'Nr. of loc.  : ' nloc.2
*
  iloc = 1
  while ( iloc <= nloc.2 )
    iline = 6 + iloc
    line = sublin(result,iline)
    par_ID.2.iloc = subwrd(line,1)
    loc_ID.2.iloc = substr(line,17,10)
    say '   location ' iloc ' is called ' loc_ID.2.iloc ' and stored as ' par_ID.2.iloc
    iloc = iloc + 1
  endwhile
*
  itime = 1
  while ( itime <= ntime.2 )
    'set t ' itime
    iloc = 1
    while ( iloc <= nloc.2 )
      result = read (ww3.mean.inner)
      line = sublin(result,2)
      ua.iloc.itime.2 = subwrd(line,5)
      ux.iloc.itime.2 = subwrd(line,6)
      uy.iloc.itime.2 = subwrd(line,7)
      ca.iloc.itime.2 = subwrd(line,9)
      cx.iloc.itime.2 = subwrd(line,10)
      cy.iloc.itime.2 = subwrd(line,11)
      hs.iloc.itime.2 = subwrd(line,12)
      'd ' par_ID.2.iloc
      line = sublin(result,8)
      lmin = subwrd(line,4)
      lmax = subwrd(line,5)
      if ( lmin < fmin) ; fmin = lmin ; endif
      if ( lmax > fmax) ; fmax = lmax ; endif
      iloc = iloc + 1
    endwhile
  itime = itime + 1
  endwhile
*
  say ' '
  say 'Done, min and max for spectrum are ' fmin ' and ' fmax

  fmax = 64
* fmax = 256
  say '              max set to ' fmax
*
* Generic page setup - - - - - - - - - - - - - - - - - - - - - - -
*
  say ' '
  say 'Setting up the page ...'
*
  st1 = ''
  st2 = ''
*
  xtc = 0.5 * xmax
  yt1 = 9.1
  yt2 = 1.8
  yt3 = 2.0
  size1 = 0.25
  size2 = 0.12
  size3 = 0.12
  nc = 25
*
  pw  = 6.
  sx  = 0.
  sy  = 0.
  xp = 0.5 * ( xmax - pw )
  yp = 0.5 * ( ymax - pw )
*
* Actual plotting loop - - - - - - - - - - - - - - - - - - - - - -
*
  say ' '
  say 'Ready for actual plotting ...'

  say '   First model, point number and time step'
  pull first
* m = subwrd(first,1)
* j = subwrd(first,2)
* i = subwrd(first,3)

  m = 1
  j = subwrd(first,1)
  i = 49

* say '   Second model (0 for ignore), point number and time step'
* pull second
* m2 = subwrd(second,1)
* j2 = subwrd(second,2)
* i2 = subwrd(second,3)

  m2 = 1
  j2 = 12
  i2 = 49

  if ( m2 = 0 )
    st1 = loc_ID.m.j
    st2 = hs.j.i.m 'm'
    par_ID2 = ''
  else
    st1 = loc_ID.m.j '-' loc_ID.m2.j2
    st2 = hs.j.i.m - hs.j2.i2.m2 'm'
    st2 = ''
    par_ID2 = par_ID.m2.j2
  endif
*
  dummy = plotspec (xp,yp,pw,dth,dfr,fmx,par_ID.m.j,m,par_ID2,m2,fmax,st1,st2,nc,ua.j.i.m,ux.j.i.m,uy.j.i.m,ca.j.i.m,cx.j.i.m,cy.j.i.m,color)
*
* End of operations  - - - - - - - - - - - - - - - - - - - - - - -
*
  'print'
*
  say ' '
  say '----------------------'
  say '*** End of spec.gs ***'
  say '----------------------'
  say ' '
*
  prompt 'Hit return to quit ...'
  pull go_on
  'quit'
*
* End of main script - - - - - - - - - - - - - - - - - - - - - - -

* ------------------------------------------------------------------------------
  function plotspec (xp0,yp0,dxyp,dxgrid,dygrid,ymax,spec,mod,spec2,mod2,scale,str1,str2,strlen,u,ux,uy,c,cx,cy,color)
*
* Function to plot a spectrum at a given location on the page with identifying
* output around it 
*
* Parameter list :
*
*   x/yp0  Lower left corner of the plot in paper coordinates.
*   dxy    Size of the plot in paper coordinates.
*   dxgrid Grid line increment for directions.
*   dygrid Grid line increment for frequencies.
*   ymax   Maximum frequency.
*   spec   Spectrum to be plotted.
*   scale  Scale (division) factor for spectrum.
*   strN   Strings around the plot, top left, clockwise, set to ''
*          to deactivate
*   strlen Number of charcters from left to right, used to scale text
*   ux/y   Wind speed and components.
*   cx/y   Current speed and components.
*   color  color of b&w [yes/---]
*   mod    file number
*
* 0. Initializations
*
  'set grads off'
  'set lon -180 180'
  'set lat ' 90-ymax ' 90'
*
* 1. Set up plot location
*
  'set parea ' xp0 ' ' xp0+dxyp ' ' yp0 ' ' yp0+dxyp
*
* 2. Set up contour intervals
*
  i = 7
  factor = 2
  level=1.0
  leveln=''
  levelp=''
*
  while ( i > 0 )
    level = level / factor
    leveln = leveln ' -' level
    levelp = level ' ' levelp
    i = i - 1
  endwhile

  levels = leveln ' ' levelp
* say levels
*
* 3. Plot spectrum
*
  'set mproj nps'
  'set grid off'
*
  if ( color = 'yes' )
    'set gxout shaded'
    'set clevs ' levels
    'set ccols 41 42 43 44 45 46 47 58 57 56 55 54 53 52 51'
    if ( spec2 = '' )
      'd ' spec '.' mod '/'scale
    else
      'd (' spec '.' mod '-' spec2 '.' mod2 ') /'scale
    endif
    current = 65
    wind    = 64
  else
    current = 66
    wind    = 63
    'set gxout contour'
    'set cthick 1'
    'set ccolor 1'
    'set cstyle 2'
    'set clab off'
    'set clevs ' leveln
    if ( spec2 = '' )
      'd ' spec '.' mod '/'scale
    else
      'd (' spec '.' mod '-' spec2 '.' mod2 ') /'scale
    endif
  endif
*
* 4. Plot grid lines manually to avoid bug
*
  'set line 66 1 3'
*
  x = 0
  while ( x < 360+0.1*dxgrid )
    'q ll2xy 'x' '90.-dygrid
    x1 = subwrd(result,1)
    y1 = subwrd(result,2)
    'q ll2xy 'x' '90.-ymax
    x2 = subwrd(result,1)
    y2 = subwrd(result,2)
   'draw line ' x1 ' ' y1 ' ' x2 ' ' y2
    x = x + dxgrid
  endwhile
*
  dx = 5
  y = dygrid
  while ( y < ymax + 0.1*dygrid )
    x = 0
    'q ll2xy 'x' '90.-y
    x2 = subwrd(result,1)
    y2 = subwrd(result,2)
    while ( x < 360 )
      x = x+dx
      x1 = x2
      y1 = y2
      'q ll2xy 'x' '90.-y
      x2 = subwrd(result,1)
      y2 = subwrd(result,2)
      'draw line ' x1 ' ' y1 ' ' x2 ' ' y2
    endwhile
    y = y + dygrid
  endwhile
*
  'set gxout contour'
  'set cthick 1'
  'set ccolor 1'
  'set cstyle 1'
  'set clab off'
  'set clevs ' levelp
  if ( spec2 = '' )
    'd ' spec '.' mod '/'scale
  else
    'd (' spec '.' mod '-' spec2 '.' mod2 ') /'scale
  endif
*
  'set gxout contour'
  'set cthick 1'
  'set ccolor 1'
  'set cstyle 2'
  'set clab off'
  'set clevs ' leveln
  if ( spec2 = '' )
    'd ' spec '.' mod '/'scale
  else
    'd (' spec '.' mod '-' spec2 '.' mod2 ') /'scale
  endif
*
* 5. Plot current and wind vector
*
  xc = xp0 + 0.5*dxyp
  yc = yp0 + 0.5*dxyp
*
* 5.a current
*
  'set line ' current ' 1 6'
*
  cmax = 1.5
  cmin = 0.1
  if ( c > cmin )
    if ( c < cmax )
      dc  = 0.375 * (dygrid/ymax) * dxyp * c / cmax
    else
      dc  = 0.375 * (dygrid/ymax) * dxyp
    endif
    dcx = dc * cx / c
    dcy = dc * cy / c
    x2 = xc - dcx
    y2 = yc - dcy
    x1 = xc + dcx
    y1 = yc + dcy
*
    'draw line ' x2 ' ' y2 ' ' x1 ' ' y1
*
    'q xy2w 'x1' 'y1
    lon = subwrd(result,3)
    lat = subwrd(result,6)
    lonh = lon + 10
    lath = 90. - 0.75*(90.-lat)
    'q ll2xy 'lonh' 'lath
    x2 = subwrd(result,1)
    y2 = subwrd(result,2)
    'draw line ' x1 ' 'y1 ' ' x2 ' ' y2
    lonh = lon - 10
    'q ll2xy 'lonh' 'lath
    x2 = subwrd(result,1)
    y2 = subwrd(result,2)
    'draw line ' x1 ' 'y1 ' ' x2 ' ' y2
*
  endif
*
* 5.b wind
*
  'set line ' wind ' 1 6'
*
  umax = 20.
  umin = 2.5
  if ( u > umin )
    if ( u < umax )
      du  = 0.375 * (dygrid/ymax) * dxyp * u / umax
    else
      du  = 0.375 * (dygrid/ymax) * dxyp
    endif
    dux = du * ux / u
    duy = du * uy / u
    x2 = xc - dux
    y2 = yc - duy
    x1 = xc + dux
    y1 = yc + duy
*
    'draw line ' x2 ' ' y2 ' ' x1 ' ' y1
*
    'q xy2w 'x1' 'y1
    lon = subwrd(result,3)
    lat = subwrd(result,6)
    lonh = lon + 10
    lath = 90. - 0.75*(90.-lat)
    'q ll2xy 'lonh' 'lath
    x2 = subwrd(result,1)
    y2 = subwrd(result,2)
    'draw line ' x1 ' 'y1 ' ' x2 ' ' y2
    lonh = lon - 10
    'q ll2xy 'lonh' 'lath
    x2 = subwrd(result,1)
    y2 = subwrd(result,2)
    'draw line ' x1 ' 'y1 ' ' x2 ' ' y2
*
  endif
*
* 6. ID text around spectrum
*
  size = dxyp / strlen
  'set strsiz ' size
*
  if ( str1 != '' )
    'set string 1 bl 4'
    'draw string ' xp0+0.50*size ' ' yp0+dxyp-1.50*size ' ' str1
  endif
*
  if ( str2 != '' )
    'set string 1 br 4'
    'draw string ' xp0+dxyp-0.50*size ' ' yp0+dxyp-1.50*size ' ' str2
  endif
*
  return
EOF

  rm -f *.inp_tmpl out_pnt.*

# 6. End, cleaning up -------------------------------------------------------

  echo ' ' ; echo "Cleaning-up `pwd`"
  rm -f mod_def.* log.*

  echo ' ' ; echo ' '
  echo '                  ======>  END OF WAVEWATCH III  <====== '
  echo '                    ==================================   '
  echo ' '

# End of mww3_test_04 -------------------------------------------------------
